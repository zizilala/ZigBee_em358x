###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     04/Feb/2015  16:38:13 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\util\serial\serial. #
#                    c                                                        #
#    Command line =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\util\serial\serial. #
#                    c -D "GENERATED_TOKEN_HEADER=\"app/builder/DoorSensor_SM #
#                    6011/DoorSensor_SM6011_tokens.h\"" -D                    #
#                    "ZA_GENERATED_HEADER=\"app/builder/DoorSensor_SM6011/Doo #
#                    rSensor_SM6011.h\"" -D LOCAL_STORAGE_BTL -D              #
#                    "BOARD_HEADER=\"app\builder\DoorSensor_SM6011\DoorSensor #
#                    _SM6011_board.h\"" -D "PLATFORM_HEADER=\"hal/micro/corte #
#                    xm3/compiler/iar.h\"" -D CORTEXM3 -D                     #
#                    CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3585 -D PHY_EM3XX -D  #
#                    "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\ #
#                    "" -D "CONFIGURATION_HEADER=\"app/framework/util/config. #
#                    h\"" -D "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/D #
#                    oorSensor_SM6011/DoorSensor_SM6011_endpoint_config.h\""  #
#                    -D "__SOURCEFILE__=\"serial.c\"" -lC                     #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \ --diag_suppress Pa050 -o C:\Ember\EmberZNet5.3.0-GA\em #
#                    35x\build\DoorSensor_SM6011\ --debug --endian=little     #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\util\serial\ -I     #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\ #
#                    DoorSensor_SM6011\..\..\..\ -I                           #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\app\framework\include\ -I                #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app #
#                    \builder\DoorSensor_SM6011\..\..\..\stack\ -I            #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\hal\ -I C:\Ember\EmberZNet5.3.0-GA\em35x #
#                    \app\builder\DoorSensor_SM6011\..\..\..\hal\..\ -Ohz     #
#                    --use_c++_inline                                         #
#    List file    =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \serial.lst                                              #
#    Object file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \serial.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Ember\EmberZNet5.3.0-GA\em35x\app\util\serial\serial.c
      1          /**
      2           * File: serial.c
      3           * Description: High Level Serial Communications
      4           *
      5           * Culprit(s):  Lee Taylor (lee@ember.com)
      6           *              Richard Kelsey (kelsey@ember.com)
      7           *              Jeff Mathews (jeff@ember.com)
      8           *
      9           * Copyright 2004 by Ember Corporation.  All rights reserved.               *80*
     10           */
     11          
     12          #include PLATFORM_HEADER
     13          #include "stack/include/ember-types.h"
     14          #include "stack/include/error.h"
     15          
     16          //Host processors do not use Ember Message Buffers.
     17          #ifndef EZSP_HOST
     18            #include "stack/include/packet-buffer.h"
     19          #endif
     20          
     21          #include "hal/hal.h"
     22          #include "serial.h"
     23          
     24          #include <stdarg.h>
     25          
     26          #ifdef EMBER_SERIAL_USE_STDIO
     27          #include <stdio.h>
     28          #endif //EMBER_SERIAL_USE_STDIO
     29          
     30          // AppBuilder and Afv2 will define the characteristics of the Serial ports here.
     31          #if defined(ZA_GENERATED_HEADER)
     32            #include ZA_GENERATED_HEADER
     33          #endif
     34          
     35          //Documentary comments:
     36          // To conserve precious flash, there is very little validity checking
     37          //  on the given parameters.  Be sure not to use an invalid port number
     38          //  or a port that is unused.
     39          // Blocking routines will always wait for room (but not buffers - if buffers
     40          //  cannot be allocated, no part of the message will be sent)
     41          // Non-blocking routines will never wait for room, and may cause partial
     42          //  messages to be sent.  If a contiguous message needs to be sent, available
     43          //  space should be checked _before_ calling the appropriate write API.
     44          
     45          //------------------------------------------------------
     46          // Determine if blocking code needs to be enabled
     47          #if defined(EMBER_SERIAL0_BLOCKING) || \
     48              defined(EMBER_SERIAL1_BLOCKING) || \
     49              defined(EMBER_SERIAL2_BLOCKING) || \
     50              defined(EMBER_SERIAL3_BLOCKING) || \
     51              defined(EMBER_SERIAL4_BLOCKING)
     52            #define EM_ENABLE_SERIAL_BLOCKING
     53          #endif
     54          #ifdef EMBER_SERIAL0_BLOCKING
     55            #define EM_SERIAL0_BLOCKSTATE TRUE
     56          #else
     57            #define EM_SERIAL0_BLOCKSTATE FALSE
     58          #endif
     59          #ifdef EMBER_SERIAL1_BLOCKING
     60            #define EM_SERIAL1_BLOCKSTATE TRUE
     61          #else
     62            #define EM_SERIAL1_BLOCKSTATE FALSE
     63          #endif
     64          #ifdef EMBER_SERIAL2_BLOCKING
     65            #define EM_SERIAL2_BLOCKSTATE TRUE
     66          #else
     67            #define EM_SERIAL2_BLOCKSTATE FALSE
     68          #endif
     69          #ifdef EMBER_SERIAL3_BLOCKING
     70            #define EM_SERIAL3_BLOCKSTATE TRUE
     71          #else
     72            #define EM_SERIAL3_BLOCKSTATE FALSE
     73          #endif
     74          #ifdef EMBER_SERIAL4_BLOCKING
     75            #define EM_SERIAL4_BLOCKSTATE TRUE
     76          #else
     77            #define EM_SERIAL4_BLOCKSTATE FALSE
     78          #endif
     79          
     80          #ifndef EMBER_SERIAL_USE_STDIO
     81          //------------------------------------------------------
     82          // Memory allocations for Queue data structures
     83          
     84          //Macros to define fifo and buffer queues, can't use a typedef becuase the size
     85          // of the fifo array in the queues can change
     86          #define DEFINE_FIFO_QUEUE(qSize, qName)             \
     87            static struct {                                   \
     88              /*! Indexes of next byte to send*/              \
     89              int16u head;                                     \
     90              /*! Index of where to enqueue next message*/    \
     91              int16u tail;                                     \
     92              /*! Number of bytes queued*/                    \
     93              volatile int16u used;                            \
     94              /*! FIFO of queue data*/                        \
     95              int8u fifo[qSize];                              \
     96            } qName;
     97          
     98          #define DEFINE_BUFFER_QUEUE(qSize, qName)           \
     99            static struct {                                   \
    100              /*! Indexes of next message to send*/           \
    101              int8u head;                                     \
    102              /*! Index of where to enqueue next message*/    \
    103              int8u tail;                                     \
    104              /*! Number of messages queued*/                 \
    105              volatile int8u used;                            \
    106              int8u dead;                                     \
    107              EmberMessageBuffer currentBuffer;               \
    108              int8u *nextByte, *lastByte;                     \
    109              /*! FIFO of messages*/                          \
    110              EmSerialBufferQueueEntry fifo[qSize];           \
    111            } qName;
    112          
    113          
    114          // Allocate Appropriate TX Queue for port 0
    115          #if EMBER_SERIAL0_MODE == EMBER_SERIAL_FIFO

   \                                 In section .bss, align 4
    116            DEFINE_FIFO_QUEUE(EMBER_SERIAL0_TX_QUEUE_SIZE,emSerial0TxQueue)
   \                     emSerial0TxQueue:
   \   00000000                      DS8 136
    117            #define EM_SERIAL0_TX_QUEUE_ADDR (&emSerial0TxQueue)
    118          #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_BUFFER
    119            DEFINE_BUFFER_QUEUE(EMBER_SERIAL0_TX_QUEUE_SIZE,emSerial0TxQueue)
    120            #define EM_SERIAL0_TX_QUEUE_ADDR (&emSerial0TxQueue)
    121          #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED || \
    122                EMBER_SERIAL0_MODE == EMBER_SERIAL_LOWLEVEL
    123            #define EM_SERIAL0_TX_QUEUE_ADDR (NULL)
    124            #define EMBER_SERIAL0_TX_QUEUE_SIZE 0
    125            #define EMBER_SERIAL0_RX_QUEUE_SIZE 0
    126          #endif
    127          
    128          // Allocate Appropriate TX Queue for port 1
    129          #if EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO

   \                                 In section .bss, align 4
    130            DEFINE_FIFO_QUEUE(EMBER_SERIAL1_TX_QUEUE_SIZE,emSerial1TxQueue)
   \                     emSerial1TxQueue:
   \   00000000                      DS8 136
    131            #define EM_SERIAL1_TX_QUEUE_ADDR (&emSerial1TxQueue)
    132          #elif EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER
    133            DEFINE_BUFFER_QUEUE(EMBER_SERIAL1_TX_QUEUE_SIZE,emSerial1TxQueue)
    134            #define EM_SERIAL1_TX_QUEUE_ADDR (&emSerial1TxQueue)
    135          #elif EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED || \
    136                EMBER_SERIAL1_MODE == EMBER_SERIAL_LOWLEVEL 
    137            #define EM_SERIAL1_TX_QUEUE_ADDR (NULL)
    138            #define EMBER_SERIAL1_TX_QUEUE_SIZE 0
    139            #define EMBER_SERIAL1_RX_QUEUE_SIZE 0
    140          #endif
    141          
    142          // Allocate Appropriate TX Queue for port 2
    143          #if EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO
    144            DEFINE_FIFO_QUEUE(EMBER_SERIAL2_TX_QUEUE_SIZE,emSerial2TxQueue)
    145            #define EM_SERIAL2_TX_QUEUE_ADDR (&emSerial2TxQueue)
    146          #elif EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER
    147            DEFINE_BUFFER_QUEUE(EMBER_SERIAL2_TX_QUEUE_SIZE,emSerial2TxQueue)
    148            #define EM_SERIAL2_TX_QUEUE_ADDR (&emSerial2TxQueue)
    149          #elif EMBER_SERIAL2_MODE == EMBER_SERIAL_UNUSED || \
    150                EMBER_SERIAL2_MODE == EMBER_SERIAL_LOWLEVEL 
    151            #define EM_SERIAL2_TX_QUEUE_ADDR (NULL)
    152            #define EMBER_SERIAL2_TX_QUEUE_SIZE 0
    153            #define EMBER_SERIAL2_RX_QUEUE_SIZE 0
    154          #endif
    155          
    156          // Allocate Appropriate TX Queue for port 3
    157          #if EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO
    158            DEFINE_FIFO_QUEUE(EMBER_SERIAL3_TX_QUEUE_SIZE,emSerial3TxQueue)
    159            #define EM_SERIAL3_TX_QUEUE_ADDR (&emSerial3TxQueue)
    160          #elif EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER
    161            DEFINE_BUFFER_QUEUE(EMBER_SERIAL3_TX_QUEUE_SIZE,emSerial3TxQueue)
    162            #define EM_SERIAL3_TX_QUEUE_ADDR (&emSerial3TxQueue)
    163          #elif EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED || \
    164                EMBER_SERIAL3_MODE == EMBER_SERIAL_LOWLEVEL 
    165            #define EM_SERIAL3_TX_QUEUE_ADDR (NULL)
    166            #define EMBER_SERIAL3_TX_QUEUE_SIZE 0
    167            #define EMBER_SERIAL3_RX_QUEUE_SIZE 0
    168          #endif
    169          
    170          // Allocate Appropriate TX Queue for port 4
    171          #if EMBER_SERIAL4_MODE == EMBER_SERIAL_FIFO
    172            DEFINE_FIFO_QUEUE(EMBER_SERIAL4_TX_QUEUE_SIZE,emSerial4TxQueue)
    173            #define EM_SERIAL4_TX_QUEUE_ADDR (&emSerial4TxQueue)
    174          #elif EMBER_SERIAL4_MODE == EMBER_SERIAL_BUFFER
    175            DEFINE_BUFFER_QUEUE(EMBER_SERIAL4_TX_QUEUE_SIZE,emSerial4TxQueue)
    176            #define EM_SERIAL4_TX_QUEUE_ADDR (&emSerial4TxQueue)
    177          #elif EMBER_SERIAL4_MODE == EMBER_SERIAL_UNUSED || \
    178                EMBER_SERIAL4_MODE == EMBER_SERIAL_LOWLEVEL 
    179            #define EM_SERIAL4_TX_QUEUE_ADDR (NULL)
    180            #define EMBER_SERIAL4_TX_QUEUE_SIZE 0
    181            #define EMBER_SERIAL4_RX_QUEUE_SIZE 0
    182          #endif
    183          
    184          // Allocate RX Queues (Always FIFOs)
    185          #if EMBER_SERIAL0_MODE != EMBER_SERIAL_UNUSED

   \                                 In section .bss, align 4
    186            DEFINE_FIFO_QUEUE(EMBER_SERIAL0_RX_QUEUE_SIZE,emSerial0RxQueue)
   \                     emSerial0RxQueue:
   \   00000000                      DS8 136
    187            #define EM_SERIAL0_RX_QUEUE_ADDR (&emSerial0RxQueue)
    188          #else
    189            #define EM_SERIAL0_RX_QUEUE_ADDR (NULL)
    190          #endif
    191          
    192          #if EMBER_SERIAL1_MODE != EMBER_SERIAL_UNUSED

   \                                 In section .bss, align 4
    193            DEFINE_FIFO_QUEUE(EMBER_SERIAL1_RX_QUEUE_SIZE,emSerial1RxQueue)
   \                     emSerial1RxQueue:
   \   00000000                      DS8 136
    194            #define EM_SERIAL1_RX_QUEUE_ADDR (&emSerial1RxQueue)
    195          #else
    196            #define EM_SERIAL1_RX_QUEUE_ADDR (NULL)
    197            #define emSerial1RxQueue (NULL)
    198          #endif
    199          
    200          #if EMBER_SERIAL2_MODE != EMBER_SERIAL_UNUSED
    201            DEFINE_FIFO_QUEUE(EMBER_SERIAL2_RX_QUEUE_SIZE,emSerial2RxQueue)
    202            #define EM_SERIAL2_RX_QUEUE_ADDR (&emSerial2RxQueue)
    203          #else
    204            #define EM_SERIAL2_RX_QUEUE_ADDR (NULL)
    205            #define emSerial2RxQueue (NULL)
    206          #endif
    207          
    208          #if EMBER_SERIAL3_MODE != EMBER_SERIAL_UNUSED
    209            DEFINE_FIFO_QUEUE(EMBER_SERIAL3_RX_QUEUE_SIZE,emSerial3RxQueue)
    210            #define EM_SERIAL3_RX_QUEUE_ADDR (&emSerial3RxQueue)
    211          #else
    212            #define EM_SERIAL3_RX_QUEUE_ADDR (NULL)
    213            #define emSerial3RxQueue (NULL)
    214          #endif
    215          
    216          #if EMBER_SERIAL4_MODE != EMBER_SERIAL_UNUSED
    217            DEFINE_FIFO_QUEUE(EMBER_SERIAL4_RX_QUEUE_SIZE,emSerial4RxQueue)
    218            #define EM_SERIAL4_RX_QUEUE_ADDR (&emSerial4RxQueue)
    219          #else
    220            #define EM_SERIAL4_RX_QUEUE_ADDR (NULL)
    221            #define emSerial4RxQueue (NULL)
    222          #endif
    223          
    224          //------------------------------------------------------
    225          // Easy access to data structures for a particular port
    226          
    227          // The FOR_EACH_PORT(CAST,PREFIX_,_SUFFIX) macro will expand in to something like:
    228          //    CAST(PREFIX_0_SUFFIX),
    229          //    CAST(PREFIX_1_SUFFIX)
    230          // with a line & number for each port of EM_NUM_SERIAL_PORTS
    231          
    232          // Data structure for referencing TX Queues
    233          //  (allows for different modes and queue sizes)
    234          void *emSerialTxQueues[EM_NUM_SERIAL_PORTS] = 
    235            { FOR_EACH_PORT( (void *),EM_SERIAL,_TX_QUEUE_ADDR ) };
    236          

   \                                 In section .text, align 4, keep-with-next
    237          int16u PGM emSerialTxQueueSizes[EM_NUM_SERIAL_PORTS] =
   \                     emSerialTxQueueSizes:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 0
   \              0x0000 0x0000
    238            { FOR_EACH_PORT( (int16u),EMBER_SERIAL,_TX_QUEUE_SIZE ) };
    239          

   \                                 In section .rodata, align 4, keep-with-next
    240          int16u PGM emSerialTxQueueMasks[EM_NUM_SERIAL_PORTS] =
   \                     emSerialTxQueueMasks:
   \   00000000   0x007F 0x007F      DC16 127, 127, 65535, 65535
   \              0xFFFF 0xFFFF
    241            { FOR_EACH_PORT( (int16u),EMBER_SERIAL,_TX_QUEUE_SIZE-1 ) };
    242          
    243          // Data structure for referencing RX Queues
    244          //  (allows for different queue sizes)
    245          EmSerialFifoQueue *emSerialRxQueues[EM_NUM_SERIAL_PORTS] = 
    246            { FOR_EACH_PORT( (EmSerialFifoQueue *),EM_SERIAL,_RX_QUEUE_ADDR ) };
    247          

   \                                 In section .rodata, align 4, keep-with-next
    248          int16u PGM emSerialRxQueueSizes[EM_NUM_SERIAL_PORTS] =
   \                     emSerialRxQueueSizes:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 0
   \              0x0000 0x0000
    249            { FOR_EACH_PORT( (int16u),EMBER_SERIAL,_RX_QUEUE_SIZE ) };
    250          
    251          // In-flash data structure for determined port mode

   \                                 In section .text, align 4, keep-with-next
    252          int8u PGM emSerialPortModes[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialPortModes:
   \   00000000   0x01 0x01          DC8 1, 1, 0, 0
   \              0x00 0x00    
    253            { FOR_EACH_PORT( (int8u),EMBER_SERIAL,_MODE ) };
    254          
    255          //Compatibility code for the AVR Atmega
    256          //If an AVR Atmega is used, then emSerialTx(/Rx)QueueWraps map to
    257          //emSerialTx(/Rx)QueueMasks, otherwise they map to emSerialTx(/Rx)QueueSizes
    258          #ifdef AVR_ATMEGA
    259          int8u PGM emSerialTxQueueWraps[EM_NUM_SERIAL_PORTS] = 
    260            { FOR_EACH_PORT( (int8u), EMBER_SERIAL,_TX_QUEUE_SIZE-1 ) };
    261          int8u PGM emSerialRxQueueWraps[EM_NUM_SERIAL_PORTS] = 
    262            { FOR_EACH_PORT( (int8u), EMBER_SERIAL,_RX_QUEUE_SIZE-1 ) };
    263          #else

   \                                 In section .text, align 4, keep-with-next
    264          int16u PGM emSerialTxQueueWraps[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialTxQueueWraps:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 0
   \              0x0000 0x0000
    265            { FOR_EACH_PORT( (int16u), EMBER_SERIAL,_TX_QUEUE_SIZE ) };

   \                                 In section .text, align 4, keep-with-next
    266          int16u PGM emSerialRxQueueWraps[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialRxQueueWraps:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 0
   \              0x0000 0x0000
    267            { FOR_EACH_PORT( (int16u), EMBER_SERIAL,_RX_QUEUE_SIZE ) };
    268          #endif
    269          
    270          #ifdef EM_ENABLE_SERIAL_BLOCKING
    271          // In-flash data structure for blocking mode

   \                                 In section .text, align 4, keep-with-next
    272          boolean PGM emSerialBlocking[EM_NUM_SERIAL_PORTS] =
   \                     emSerialBlocking:
   \   00000000   0x01 0x01          DC8 1, 1, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
    273            { FOR_EACH_PORT( (boolean),EM_SERIAL,_BLOCKSTATE ) };
    274          #endif
    275          
    276          int8u emSerialRxError[EM_NUM_SERIAL_PORTS] = {EMBER_SUCCESS,};
   \                     emSerialRxError:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    277          int16u emSerialRxErrorIndex[EM_NUM_SERIAL_PORTS] = {0,};
   \                     emSerialRxErrorIndex:
   \   00000004   0x0000 0x0000      DC16 0, 0, 0, 0
   \              0x0000 0x0000
   \                     emSerialTxQueues:
   \   0000000C   0x........         DC32 emSerial0TxQueue, emSerial1TxQueue, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \                     emSerialRxQueues:
   \   0000001C   0x........         DC32 emSerial0RxQueue, emSerial1RxQueue, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
    278          #endif //EMBER_SERIAL_USE_STDIO
    279          

   \                                 In section .text, align 4, keep-with-next
    280          static PGM int32u powers10[9] = {
   \                     powers10:
   \   00000000   0x3B9ACA00         DC32 1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100
   \              0x05F5E100   
   \              0x00989680   
   \              0x000F4240   
   \              0x000186A0   
   \              0x00002710   
   \              0x000003E8   
   \              0x00000064   
   \   00000020   0x0000000A         DC32 10
    281            1000000000,
    282            100000000,
    283            10000000,
    284            1000000,
    285            100000,
    286            10000,
    287            1000,
    288            100,
    289            10
    290          };
    291          
    292          
    293          
    294          //------------------------------------------------------
    295          // Private functions
    296          
    297          // --------------------------------
    298          // A simple printf() implementation
    299          // Supported format specifiers are:
    300          //  %% - percent sign
    301          //  %c - single byte character
    302          //  %s - ram string
    303          //  %p - flash string  (non-standard)
    304          //  %u - 2-byte unsigned decimal
    305          //  %d - 2-byte signed decimal
    306          //  %x %2x %4x - 1, 2, 4 BYTE hex value (always 0 padded) (non-standard)
    307          //    Non-standard behavior: Normally a number after a % is interpreted to be
    308          //    a minimum character width, and the value is not zero padded unless
    309          //    there is a zero before the minimum width value.
    310          //    i.e. '%2x' for the int16u value 0xb prints " b", while '%02x' would print
    311          //    "0b".
    312          //    Ember assumes the number after the % and before the 'x' to be the number
    313          //    of BYTES, and all hex values are left-justified zero padded.
    314          // 
    315          // A few macros and a function help make this readable:
    316          //   - flush the local buffer to the output
    317          //   - ensure that there is some room in the local buffer
    318          //   - add a single byte to the local buffer
    319          //   - convert a nibble to its ascii hex character
    320          //   - convert an int16u to a decimal string
    321          // Most of these only work within the emPrintfInternal() function.
    322          
    323          // Current champion is %4x which writes 8 bytes.  (%s and %p can write
    324          // more, but they do their own overflow checks).
    325          #define LOCAL_BUFFER_SIZE 16
    326          #define MAX_SINGLE_COMMAND_BYTES 8
    327          
    328          #define flushBuffer() \
    329          do { count = localBufferPointer - localBuffer;     \
    330               if (flushHandler(port, localBuffer, count) != EMBER_SUCCESS) \
    331                 goto fail;                                  \
    332               total += count;                               \
    333               localBufferPointer = localBuffer;             \
    334               (void)localBufferPointer;                     \
    335          } while (FALSE)                                           
    336          
    337          #define addByte(byte) \
    338          do { *(localBufferPointer++) = (byte); } while (FALSE)
    339          

   \                                 In section .text, align 2, keep-with-next
    340          int8u *emWriteHexInternal(int8u *charBuffer, int16u value, int8u charCount)
    341          {
   \                     emWriteHexInternal:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    342            int8u c = charCount;
   \   00000002   0x4613             MOV      R3,R2
    343            charBuffer += charCount;
   \   00000004   0x1810             ADDS     R0,R2,R0
   \   00000006   0xE002             B.N      ??emWriteHexInternal_0
    344            for (; c; c--) {
    345              int8u n = value & 0x0F;
    346              value = value >> 4;
    347              *(--charBuffer) = n + (n < 10
    348                                     ? '0'
    349                                     : 'A' - 10);
   \                     ??emWriteHexInternal_1:
   \   00000008   0x19A4             ADDS     R4,R4,R6
   \   0000000A   0x702C             STRB     R4,[R5, #+0]
   \   0000000C   0x1E5B             SUBS     R3,R3,#+1
   \                     ??emWriteHexInternal_0:
   \   0000000E   0xB2DB             UXTB     R3,R3
   \   00000010   0xB14B             CBZ.N    R3,??emWriteHexInternal_2
   \   00000012   0xF001 0x060F      AND      R6,R1,#0xF
   \   00000016   0x0909             LSRS     R1,R1,#+4
   \   00000018   0x1E45             SUBS     R5,R0,#+1
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x2E0A             CMP      R6,#+10
   \   0000001E   0xBF34             ITE      CC 
   \   00000020   0x2430             MOVCC    R4,#+48
   \   00000022   0x2437             MOVCS    R4,#+55
   \   00000024   0xE7F0             B.N      ??emWriteHexInternal_1
    350            }
    351            return charBuffer + charCount;
   \                     ??emWriteHexInternal_2:
   \   00000026   0x1810             ADDS     R0,R2,R0
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    352          }
    353          
    354          // This function will write a decimal ASCII string to buffer 
    355          // containing the passed 'value'.  Includes negative sign, if applicable.
    356          // Returns the number of bytes written.
    357          
    358          static int8u decimalStringWrite(int32s value, int8u* buffer)
    359          {
    360            int8u length = 0;
    361          
    362            // We introduce this variable to accomodate the actual value to be printed.
    363            // This is necessary for handling the case in which we print -2147483648,
    364            // since we need to flip the sign and an int32s can represent up to 2147483647
    365            // while an int32s can represent an integer as big as 4294967295.
    366            int32u printValue = (int32u)value;
    367          
    368            // If the most significant bit is set to 1, i.e., if value is negative.
    369            if (value & 0x80000000L)
    370            {
    371              buffer[length++] = '-';
    372          
    373              // Since we are assigning to an int32u we can safetly flip the sign and get
    374              // the absolute value.
    375              printValue = -value;
    376            }
    377          
    378            {
    379              int8u i;
    380              boolean printedLeadingNonZeroValue = FALSE;
    381              // To prevent using 32-bit divide or modulus,
    382              // since those operations are expensive on a 16-bit processor,
    383              // we use subtraction and a constant array with powers of 10.
    384              for (i = 0; i < 9; i++) {
    385                int8u digit = 0;
    386                while (printValue >= powers10[i]) {
    387                  printValue -= powers10[i];
    388                  digit++;
    389                }
    390                if (digit != 0 || printedLeadingNonZeroValue) {
    391                  buffer[length++] = '0' + digit;
    392                  printedLeadingNonZeroValue = TRUE;
    393                }
    394              }
    395              buffer[length++] = '0' + printValue;
    396          
    397              return length;
    398            }
    399          }
    400          
    401          // Returns number of characters written

   \                                 In section .text, align 2, keep-with-next
    402          int8u emPrintfInternal(emPrintfFlushHandler flushHandler, 
    403                                 int8u port,
    404                                 PGM_P string, 
    405                                 va_list args)
    406          {
   \                     emPrintfInternal:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x469B             MOV      R11,R3
    407            int8u localBuffer[LOCAL_BUFFER_SIZE + MAX_SINGLE_COMMAND_BYTES];
    408            int8u *localBufferPointer = localBuffer;
   \   0000000E   0xAD01             ADD      R5,SP,#+4
    409            int8u *localBufferLimit = localBuffer + LOCAL_BUFFER_SIZE;
    410            int8u count;
    411            int8u total = 0;
   \   00000010   0x2700             MOVS     R7,#+0
   \   00000012   0xA801             ADD      R0,SP,#+4
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000018   0xE01B             B.N      ??emPrintfInternal_0
    412          
    413            for (; *string; string++) {
    414              int8u next = *string;
    415              if (next != '%')
    416                addByte(next);
    417              else {
    418                string += 1;
    419                switch (*string) {
    420                case '%':
    421                  // escape for printing "%"
    422                  addByte('%');
    423                  break;
    424                case 'c':
    425                  // character
    426                  addByte(va_arg(args, unsigned int) & 0xFF);
    427                  break;
    428                case 'p': 
    429                  // only avr needs to special-case the pgm handling, all other current
    430                  //  platforms fall through to standard string handling.
    431                  #ifdef AVR_ATMEGA
    432                    {
    433                    // flash string
    434                    PGM_P arg = va_arg(args, PGM_P);
    435                    while (TRUE) {
    436                      int8u ch = *arg++;
    437                      if (ch == '\0')
    438                        break;
    439                      *(localBufferPointer++) = ch;
    440                      if (localBufferLimit <= localBufferPointer)
    441                        flushBuffer();
    442                    }
    443                    break;
    444                  }
    445                  #endif
    446                case 's': {
    447                  // string
    448                  int8u len;
    449                  int8u *arg = va_arg(args, int8u *);
    450                  flushBuffer();
    451                  for (len=0; arg[len] != '\0'; len++) {};
    452                  if (flushHandler(port, arg, len) != EMBER_SUCCESS)
    453                    goto fail;
    454                  total += len;
    455                  break; }
    456          
    457                // Note: We don't support printing unsigned 32-bit values.
    458                case 'l':         // signed 4-byte
    459                case 'u':         // unsigned 2-byte
    460                case 'd': {       // signed 2-byte
    461                  int32s value;
    462                  if (*string == 'l') {
    463                    value = va_arg(args, long int);
    464                  } else if (*string == 'u') { // Need when sizeof(int) != sizeof(int16u)
    465                    value = va_arg(args, unsigned int);
    466                  } else {
    467                    value = va_arg(args, int);
    468                  }
    469                  localBufferPointer += decimalStringWrite(value, localBufferPointer);
    470                  break;
    471                }
    472                case 'x':
    473                case 'X': {
    474                  // single hex byte (always prints 2 chars, ex: 0A)
    475                  int8u data = va_arg(args, int);
    476                 
    477                  localBufferPointer = emWriteHexInternal(localBufferPointer, data, 2);
    478                  break; }
    479                case '2':
    480                  // %2x only, 2 hex bytes (always prints 4 chars)
    481                case '4':
    482                  // %4x only, 4 hex bytes (always prints 8 chars)
    483                  string += 1;
    484                  if (*string != 'x' && *string != 'X') {
    485                    string -= 1;
    486                  } else if (*(string - 1) == '2') {
    487                    int16u data = va_arg(args, int);
    488                    localBufferPointer = emWriteHexInternal(localBufferPointer, data, 4);
    489                  } else {
    490                    int32u data = va_arg(args, int32u);
   \                     ??emPrintfInternal_1:
   \   0000001A   0xF85B 0xAB04      LDR      R10,[R11], #+4
    491                    // On the AVR at least, the code size is smaller if we limit the
    492                    // emWriteHexInternal() code to 16-bit numbers and call it twice in
    493                    // this case.  Other processors may have a different tradeoff.
    494                    localBufferPointer = emWriteHexInternal(localBufferPointer, 
    495                                                        (int16u) (data >> 16), 
    496                                                        4);
   \   0000001E   0x2204             MOVS     R2,#+4
   \   00000020   0xEA4F 0x411A      LSR      R1,R10,#+16
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       emWriteHexInternal
    497                    localBufferPointer = emWriteHexInternal(localBufferPointer, 
    498                                                        (int16u) data, 
    499                                                        4);
   \   0000002A   0x2204             MOVS     R2,#+4
   \   0000002C   0xFA1F 0xF18A      UXTH     R1,R10
   \                     ??emPrintfInternal_2:
   \   00000030   0x.... 0x....      BL       emWriteHexInternal
   \   00000034   0x4605             MOV      R5,R0
    500                  }
    501                  break;
    502                case '\0':
    503                  goto done;
    504                default: {
    505                }
    506                } //close switch.
    507              }
    508              if (localBufferLimit <= localBufferPointer)
   \                     ??emPrintfInternal_3:
   \   00000036   0xA805             ADD      R0,SP,#+20
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD309             BCC.N    ??emPrintfInternal_4
    509                flushBuffer();
   \   0000003C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000040   0x1A2E             SUBS     R6,R5,R0
   \   00000042   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD131             BNE.N    ??emPrintfInternal_5
   \   0000004A   0x19F7             ADDS     R7,R6,R7
   \   0000004C   0xB2FF             UXTB     R7,R7
   \   0000004E   0xAD01             ADD      R5,SP,#+4
   \                     ??emPrintfInternal_4:
   \   00000050   0x1C64             ADDS     R4,R4,#+1
   \                     ??emPrintfInternal_0:
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x1A2E             SUBS     R6,R5,R0
   \   00000058   0x7820             LDRB     R0,[R4, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD007             BEQ.N    ??emPrintfInternal_6
   \   0000005E   0x2825             CMP      R0,#+37
   \   00000060   0xD002             BEQ.N    ??emPrintfInternal_7
   \                     ??emPrintfInternal_8:
   \   00000062   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   00000066   0xE7E6             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_7:
   \   00000068   0xF814 0x0F01      LDRB     R0,[R4, #+1]!
   \   0000006C   0x2800             CMP      R0,#+0
   \                     ??emPrintfInternal_6:
   \   0000006E   0xD076             BEQ.N    ??emPrintfInternal_9
   \   00000070   0x2825             CMP      R0,#+37
   \   00000072   0xD0F6             BEQ.N    ??emPrintfInternal_8
   \   00000074   0x2832             CMP      R0,#+50
   \   00000076   0xBF18             IT       NE 
   \   00000078   0x2834             CMPNE    R0,#+52
   \   0000007A   0xD05F             BEQ.N    ??emPrintfInternal_10
   \   0000007C   0x2858             CMP      R0,#+88
   \   0000007E   0xD057             BEQ.N    ??emPrintfInternal_11
   \   00000080   0x2863             CMP      R0,#+99
   \   00000082   0xD00C             BEQ.N    ??emPrintfInternal_12
   \   00000084   0x2864             CMP      R0,#+100
   \   00000086   0xBF18             IT       NE 
   \   00000088   0x286C             CMPNE    R0,#+108
   \   0000008A   0xD025             BEQ.N    ??emPrintfInternal_13
   \   0000008C   0x2870             CMP      R0,#+112
   \   0000008E   0xBF18             IT       NE 
   \   00000090   0x2873             CMPNE    R0,#+115
   \   00000092   0xD007             BEQ.N    ??emPrintfInternal_14
   \   00000094   0x2875             CMP      R0,#+117
   \   00000096   0xD01F             BEQ.N    ??emPrintfInternal_13
   \   00000098   0x2878             CMP      R0,#+120
   \   0000009A   0xD049             BEQ.N    ??emPrintfInternal_11
   \   0000009C   0xE7CB             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_12:
   \   0000009E   0xF85B 0x0B04      LDR      R0,[R11], #+4
   \   000000A2   0xE7DE             B.N      ??emPrintfInternal_8
   \                     ??emPrintfInternal_14:
   \   000000A4   0xF85B 0xAB04      LDR      R10,[R11], #+4
   \   000000A8   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   000000AC   0x2800             CMP      R0,#+0
   \                     ??emPrintfInternal_5:
   \   000000AE   0xD15C             BNE.N    ??emPrintfInternal_15
   \   000000B0   0x19F7             ADDS     R7,R6,R7
   \   000000B2   0xB2FF             UXTB     R7,R7
   \   000000B4   0xAD01             ADD      R5,SP,#+4
   \   000000B6   0x2600             MOVS     R6,#+0
   \   000000B8   0xE000             B.N      ??emPrintfInternal_16
   \                     ??emPrintfInternal_17:
   \   000000BA   0x1C76             ADDS     R6,R6,#+1
   \                     ??emPrintfInternal_16:
   \   000000BC   0xB2F6             UXTB     R6,R6
   \   000000BE   0xF816 0x000A      LDRB     R0,[R6, R10]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD1F9             BNE.N    ??emPrintfInternal_17
   \   000000C6   0x4632             MOV      R2,R6
   \   000000C8   0x4651             MOV      R1,R10
   \   000000CA   0x4648             MOV      R0,R9
   \   000000CC   0x47C0             BLX      R8
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD14B             BNE.N    ??emPrintfInternal_15
   \   000000D2   0x19F7             ADDS     R7,R6,R7
   \   000000D4   0xB2FF             UXTB     R7,R7
   \   000000D6   0xE7AE             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_13:
   \   000000D8   0xF85B 0x0B04      LDR      R0,[R11], #+4
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD503             BPL.N    ??emPrintfInternal_18
   \   000000E2   0x212D             MOVS     R1,#+45
   \   000000E4   0x7029             STRB     R1,[R5, #+0]
   \   000000E6   0x2101             MOVS     R1,#+1
   \   000000E8   0x4240             RSBS     R0,R0,#+0
   \                     ??emPrintfInternal_18:
   \   000000EA   0x2300             MOVS     R3,#+0
   \   000000EC   0x2200             MOVS     R2,#+0
   \                     ??emPrintfInternal_19:
   \   000000EE   0xF04F 0x0C00      MOV      R12,#+0
   \   000000F2   0xE002             B.N      ??emPrintfInternal_20
   \                     ??emPrintfInternal_21:
   \   000000F4   0x1B80             SUBS     R0,R0,R6
   \   000000F6   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??emPrintfInternal_20:
   \   000000FA   0x.... 0x....      ADR.W    R6,powers10
   \   000000FE   0xF856 0x6022      LDR      R6,[R6, R2, LSL #+2]
   \   00000102   0x42B0             CMP      R0,R6
   \   00000104   0xD2F6             BCS.N    ??emPrintfInternal_21
   \   00000106   0xEA43 0x060C      ORR      R6,R3,R12
   \   0000010A   0xB2F6             UXTB     R6,R6
   \   0000010C   0x2E00             CMP      R6,#+0
   \   0000010E   0xD005             BEQ.N    ??emPrintfInternal_22
   \   00000110   0xB2C9             UXTB     R1,R1
   \   00000112   0xF10C 0x0330      ADD      R3,R12,#+48
   \   00000116   0x554B             STRB     R3,[R1, R5]
   \   00000118   0x1C49             ADDS     R1,R1,#+1
   \   0000011A   0x2301             MOVS     R3,#+1
   \                     ??emPrintfInternal_22:
   \   0000011C   0x1C52             ADDS     R2,R2,#+1
   \   0000011E   0x2A09             CMP      R2,#+9
   \   00000120   0xDBE5             BLT.N    ??emPrintfInternal_19
   \   00000122   0xB2C9             UXTB     R1,R1
   \   00000124   0x3030             ADDS     R0,R0,#+48
   \   00000126   0x5548             STRB     R0,[R1, R5]
   \   00000128   0x1C48             ADDS     R0,R1,#+1
   \   0000012A   0xB2C0             UXTB     R0,R0
   \   0000012C   0x1945             ADDS     R5,R0,R5
   \                     ??emPrintfInternal_23:
   \   0000012E   0xE782             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_11:
   \   00000130   0xF85B 0x1B04      LDR      R1,[R11], #+4
   \   00000134   0x2202             MOVS     R2,#+2
   \   00000136   0xB2C9             UXTB     R1,R1
   \                     ??emPrintfInternal_24:
   \   00000138   0x4628             MOV      R0,R5
   \   0000013A   0xE779             B.N      ??emPrintfInternal_2
   \                     ??emPrintfInternal_10:
   \   0000013C   0xF814 0x0F01      LDRB     R0,[R4, #+1]!
   \   00000140   0x2878             CMP      R0,#+120
   \   00000142   0xBF1C             ITT      NE 
   \   00000144   0x2858             CMPNE    R0,#+88
   \   00000146   0x1E64             SUBNE    R4,R4,#+1
   \   00000148   0xD1F1             BNE.N    ??emPrintfInternal_23
   \   0000014A   0xF814 0x0C01      LDRB     R0,[R4, #-1]
   \   0000014E   0x2832             CMP      R0,#+50
   \   00000150   0xF47F 0xAF63      BNE.W    ??emPrintfInternal_1
   \   00000154   0xF85B 0x1B04      LDR      R1,[R11], #+4
   \   00000158   0x2204             MOVS     R2,#+4
   \   0000015A   0xB289             UXTH     R1,R1
   \   0000015C   0xE7EC             B.N      ??emPrintfInternal_24
    510            }
    511            
    512           done:
    513            flushBuffer();
   \                     ??emPrintfInternal_9:
   \   0000015E   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0:
   \   00000162   0xB910             CBNZ.N   R0,??emPrintfInternal_15
    514            return total;
   \   00000164   0x19F0             ADDS     R0,R6,R7
   \   00000166   0xB2C0             UXTB     R0,R0
   \   00000168   0xE000             B.N      ??emPrintfInternal_25
    515          
    516           fail:
    517            return 0;
   \                     ??emPrintfInternal_15:
   \   0000016A   0x2000             MOVS     R0,#+0
   \                     ??emPrintfInternal_25:
   \   0000016C   0xB007             ADD      SP,SP,#+28
   \   0000016E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    518          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xB2F2             UXTB     R2,R6
   \   00000002   0xA901             ADD      R1,SP,#+4
   \   00000004   0x4648             MOV      R0,R9
   \   00000006   0x4740             BX       R8
    519          
    520          //------------------------------------------------------
    521          // Buffered Serial utility APIs
    522          
    523          #ifdef EM_ENABLE_SERIAL_BUFFER
    524          // always executed in interrupt context
    525          void emSerialBufferNextMessageIsr(EmSerialBufferQueue *q) 
    526          {
    527            EmSerialBufferQueueEntry *e = &q->fifo[q->tail];
    528          
    529            q->currentBuffer = e->buffer;
    530            q->nextByte = emberLinkedBufferContents(q->currentBuffer) + e->startIndex;
    531            if((e->length + e->startIndex) > PACKET_BUFFER_SIZE) {
    532              q->lastByte = q->nextByte + ((PACKET_BUFFER_SIZE-1) - e->startIndex);
    533              e->length -= PACKET_BUFFER_SIZE - e->startIndex;
    534            } else {
    535              q->lastByte = q->nextByte + e->length - 1;
    536              e->length = 0;
    537            }
    538          }
    539          #endif
    540          
    541          #ifdef EM_ENABLE_SERIAL_BUFFER
    542          // always executed in interrupt context
    543          void emSerialBufferNextBlockIsr(EmSerialBufferQueue *q, int8u port)
    544          {
    545            EmSerialBufferQueueEntry *e = &q->fifo[q->tail];
    546            
    547            if(e->length != 0) {
    548              q->currentBuffer = emberStackBufferLink(q->currentBuffer);
    549              q->nextByte = emberLinkedBufferContents(q->currentBuffer);
    550              if(e->length > PACKET_BUFFER_SIZE) {
    551                q->lastByte = q->nextByte + 31;
    552                e->length -= PACKET_BUFFER_SIZE;
    553              } else {
    554                q->lastByte = q->nextByte + e->length - 1;
    555                e->length = 0;
    556              }
    557            } else {
    558              #ifdef AVR_ATMEGA
    559                //If we are using an AVR host, non power-of-2 queue sizes are NOT
    560                //supported and therefore we use a mask    
    561                q->tail = ((q->tail+1) & emSerialTxQueueMasks[port]);
    562              #else // AVR_ATMEGA
    563                //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
    564                //supported and therefore we use a mod with the queue size
    565                q->tail = ((q->tail+1) % emSerialTxQueueSizes[port]);
    566              #endif // !AVR_ATMEGA
    567              q->dead++;
    568              q->used--;
    569              if(q->used)
    570                emSerialBufferNextMessageIsr(q);
    571              else
    572                q->nextByte = NULL;
    573            }
    574          }
    575          #endif
    576          
    577          //------------------------------------------------------
    578          // Serial initialization
    579          

   \                                 In section .text, align 2, keep-with-next
    580          EmberStatus emberSerialInit(int8u port, 
    581                                      SerialBaudRate rate,
    582                                      SerialParity parity,
    583                                      int8u stopBits)
    584          {
   \                     emberSerialInit:
   \   00000000   0xE92D 0x4EFC      PUSH     {R2-R7,R9-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x469B             MOV      R11,R3
    585          #ifdef EMBER_SERIAL_USE_STDIO
    586            //When using stdio, bypass the serial library initialization
    587            //and just initialize the low level UART driver.
    588            return halInternalUartInit(port, rate, parity, stopBits);
    589          #else //EMBER_SERIAL_USE_STDIO
    590            EmSerialFifoQueue *rq;
    591          
    592          #if EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED
    593            if (port == 0) return EMBER_SERIAL_INVALID_PORT;
    594          #endif
    595          #if EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED
    596            if (port == 1) return EMBER_SERIAL_INVALID_PORT;
    597          #endif
    598          #if EMBER_SERIAL2_MODE == EMBER_SERIAL_UNUSED
    599            if (port == 2) return EMBER_SERIAL_INVALID_PORT;
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0x2C03             CMPNE    R4,#+3
    600          #endif
    601          #if EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED
    602            if (port == 3) return EMBER_SERIAL_INVALID_PORT;
   \   00000012   0x2C04             CMPNE    R4,#+4
    603          #endif
    604          #if EMBER_SERIAL4_MODE == EMBER_SERIAL_UNUSED
    605            if (port == 4) return EMBER_SERIAL_INVALID_PORT;
   \   00000014   0xD027             BEQ.N    ??emberSerialInit_0
    606          #endif
    607            if (port >= EM_NUM_SERIAL_PORTS) return EMBER_SERIAL_INVALID_PORT;
   \   00000016   0xD226             BCS.N    ??emberSerialInit_0
    608          
    609            switch(emSerialPortModes[port]) {
   \   00000018   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000001C   0x5C20             LDRB     R0,[R4, R0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD121             BNE.N    ??emberSerialInit_0
    610          #ifdef EM_ENABLE_SERIAL_FIFO
    611            case EMBER_SERIAL_FIFO: {
    612              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable20_1
   \   00000026   0xEB05 0x0684      ADD      R6,R5,R4, LSL #+2
   \   0000002A   0x68F7             LDR      R7,[R6, #+12]
    613              ATOMIC_LITE(
    614                q->used = 0;
    615                q->head = 0;
    616                q->tail = 0;
    617              )
   \   0000002C   0x.... 0x....      BL       _disableBasePri
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x80B9             STRH     R1,[R7, #+4]
   \   00000034   0x8039             STRH     R1,[R7, #+0]
   \   00000036   0x8079             STRH     R1,[R7, #+2]
   \   00000038   0x.... 0x....      BL       _writeBasePri
    618              break; }
    619          #endif
    620          #ifdef EM_ENABLE_SERIAL_BUFFER
    621            case EMBER_SERIAL_BUFFER: {
    622              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    623              ATOMIC_LITE(
    624                q->used = 0;
    625                q->head = 0;
    626                q->tail = 0;
    627                q->dead = 0;
    628                q->currentBuffer = EMBER_NULL_MESSAGE_BUFFER;
    629                q->nextByte = NULL;
    630                q->lastByte = NULL;
    631              )
    632              break; }
    633          #endif
    634            default:
    635              return EMBER_SERIAL_INVALID_PORT;
    636              //break;  //statement is unreachable
    637            }
    638          
    639            rq = emSerialRxQueues[port];
   \   0000003C   0x69F6             LDR      R6,[R6, #+28]
    640            ATOMIC_LITE(
    641              rq->used = 0;
    642              rq->head = 0;
    643              rq->tail = 0;
    644              emSerialRxError[port] = EMBER_SUCCESS;
    645            )
   \   0000003E   0x.... 0x....      BL       _disableBasePri
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x80B1             STRH     R1,[R6, #+4]
   \   00000046   0x8031             STRH     R1,[R6, #+0]
   \   00000048   0x8071             STRH     R1,[R6, #+2]
   \   0000004A   0x5561             STRB     R1,[R4, R5]
   \   0000004C   0x.... 0x....      BL       _writeBasePri
    646          
    647            halInternalRestartUart();
   \   00000050   0x.... 0x....      BL       halInternalRestartUart
    648          
    649            return halInternalUartInit(port, rate, parity, stopBits);
   \   00000054   0x465B             MOV      R3,R11
   \   00000056   0x4652             MOV      R2,R10
   \   00000058   0x4649             MOV      R1,R9
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0xB002             ADD      SP,SP,#+8
   \   0000005E   0xE8BD 0x4EF0      POP      {R4-R7,R9-R11,LR}
   \   00000062   0x.... 0x....      B.W      halInternalUartInit
   \                     ??emberSerialInit_0:
   \   00000066   0x2021             MOVS     R0,#+33
   \   00000068   0xE8BD 0x8EF6      POP      {R1,R2,R4-R7,R9-R11,PC}  ;; return
    650          #endif //EMBER_SERIAL_USE_STDIO
    651          }
    652          
    653          //------------------------------------------------------
    654          // Serial Input
    655          
    656          // returns # bytes available for reading

   \                                 In section .text, align 2, keep-with-next
    657          int16u emberSerialReadAvailable(int8u port)  
    658          {
   \                     emberSerialReadAvailable:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    659          #ifdef EMBER_SERIAL_USE_STDIO
    660            return halInternalPrintfReadAvailable();
    661          #else //EMBER_SERIAL_USE_STDIO
    662            halInternalUartRxPump(port);
   \   00000004   0x.... 0x....      BL       halInternalUartRxPump
    663            return emSerialRxQueues[port]->used;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000000C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000010   0x69C0             LDR      R0,[R0, #+28]
   \   00000012   0x8880             LDRH     R0,[R0, #+4]
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    664          #endif //EMBER_SERIAL_USE_STDIO
    665          }
    666          

   \                                 In section .text, align 2, keep-with-next
    667          EmberStatus emberSerialReadByte(int8u port, int8u *dataByte)
    668          {
   \                     emberSerialReadByte:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4688             MOV      R8,R1
    669          #ifdef EMBER_SERIAL_USE_STDIO
    670            int ch=-1;
    671            ch = getchar();
    672            if(ch<0) {
    673              return EMBER_SERIAL_RX_EMPTY;
    674            }
    675            *dataByte = (int8u)ch;
    676            return EMBER_SUCCESS;
    677          #else //EMBER_SERIAL_USE_STDIO
    678            int8u retval;
    679            EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable20_1
   \   0000000C   0xEB05 0x0184      ADD      R1,R5,R4, LSL #+2
   \   00000010   0x69CE             LDR      R6,[R1, #+28]
    680          
    681            if(emSerialPortModes[port] == EMBER_SERIAL_UNUSED) {
   \   00000012   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   00000016   0x5C61             LDRB     R1,[R4, R1]
   \   00000018   0xB909             CBNZ.N   R1,??emberSerialReadByte_0
    682              return EMBER_ERR_FATAL;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE035             B.N      ??emberSerialReadByte_1
    683            }
    684          
    685            if(emSerialRxError[port] != EMBER_SUCCESS) {
   \                     ??emberSerialReadByte_0:
   \   0000001E   0xEB05 0x0744      ADD      R7,R5,R4, LSL #+1
   \   00000022   0x5D61             LDRB     R1,[R4, R5]
   \   00000024   0xB161             CBZ.N    R1,??emberSerialReadByte_2
    686              if(emSerialRxErrorIndex[port] == q->tail) {
   \   00000026   0x88B9             LDRH     R1,[R7, #+4]
   \   00000028   0x8872             LDRH     R2,[R6, #+2]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0xD108             BNE.N    ??emberSerialReadByte_2
    687                ATOMIC_LITE(
    688                  retval = emSerialRxError[port];
    689                  emSerialRxError[port] = EMBER_SUCCESS;
    690                )
   \   0000002E   0x.... 0x....      BL       _disableBasePri
   \   00000032   0x5D66             LDRB     R6,[R4, R5]
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x5561             STRB     R1,[R4, R5]
   \   00000038   0x.... 0x....      BL       _writeBasePri
    691                return retval;
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0xE024             B.N      ??emberSerialReadByte_1
    692              }
    693            }
    694            
    695            halInternalUartRxPump(port);
   \                     ??emberSerialReadByte_2:
   \   00000040   0x.... 0x....      BL       halInternalUartRxPump
    696            halInternalUartFlowControl(port);
    697            
    698            if(q->used > 0) {
   \   00000044   0x88B0             LDRH     R0,[R6, #+4]
   \   00000046   0xB1F8             CBZ.N    R0,??emberSerialReadByte_3
    699              ATOMIC_LITE(
    700                *dataByte = FIFO_DEQUEUE(q,emSerialRxQueueWraps[port]);
    701              )
   \   00000048   0x.... 0x....      BL       _disableBasePri
   \   0000004C   0x8871             LDRH     R1,[R6, #+2]
   \   0000004E   0x1989             ADDS     R1,R1,R6
   \   00000050   0x7989             LDRB     R1,[R1, #+6]
   \   00000052   0xF888 0x1000      STRB     R1,[R8, #+0]
   \   00000056   0x8871             LDRH     R1,[R6, #+2]
   \   00000058   0x1C49             ADDS     R1,R1,#+1
   \   0000005A   0x.... 0x....      ADR.W    R2,emSerialRxQueueWraps
   \   0000005E   0xF832 0x2014      LDRH     R2,[R2, R4, LSL #+1]
   \   00000062   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_3:
   \   00000066   0x8071             STRH     R1,[R6, #+2]
   \   00000068   0x88B1             LDRH     R1,[R6, #+4]
   \   0000006A   0x1E49             SUBS     R1,R1,#+1
   \   0000006C   0x80B1             STRH     R1,[R6, #+4]
   \   0000006E   0x.... 0x....      BL       _writeBasePri
    702              if(emSerialRxError[port] != EMBER_SUCCESS) {
   \   00000072   0x5D60             LDRB     R0,[R4, R5]
   \   00000074   0xB130             CBZ.N    R0,??emberSerialReadByte_4
    703                //This index is used when there is an error when the FIFO is full.
    704                if(emSerialRxErrorIndex[port] == RX_FIFO_FULL) {
   \   00000076   0x88B8             LDRH     R0,[R7, #+4]
   \   00000078   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xBF04             ITT      EQ 
   \   00000080   0x8830             LDRHEQ   R0,[R6, #+0]
   \   00000082   0x80B8             STRHEQ   R0,[R7, #+4]
    705                  //q->tail has advanced by one, we can now mark the head as the error
    706                  emSerialRxErrorIndex[port] = q->head;
    707                }
    708              }
    709              return EMBER_SUCCESS;
   \                     ??emberSerialReadByte_4:
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE000             B.N      ??emberSerialReadByte_1
    710            } else {
    711              return EMBER_SERIAL_RX_EMPTY;
   \                     ??emberSerialReadByte_3:
   \   00000088   0x2026             MOVS     R0,#+38
   \                     ??emberSerialReadByte_1:
   \   0000008A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    712            }
    713          #endif //EMBER_SERIAL_USE_STDIO
    714          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   00000004   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   00000008   0x4770             BX       LR
    715          

   \                                 In section .text, align 2, keep-with-next
    716          EmberStatus emberSerialReadData(int8u port,
    717                                          int8u *data,
    718                                          int16u length,
    719                                          int16u *bytesRead)
    720          {
   \                     emberSerialReadData:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
    721            int16u bytesReadInternal = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xE001             B.N      ??emberSerialReadData_0
    722            EmberStatus status;
    723          
    724            while (bytesReadInternal < length) {
    725              status = emberSerialReadByte(port, data);
    726          
    727              switch (status) {
    728                case EMBER_SUCCESS:
    729                  ++data;
   \                     ??emberSerialReadData_1:
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
    730                  ++bytesReadInternal;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    731                  break;
   \                     ??emberSerialReadData_0:
   \   00000014   0xB2B6             UXTH     R6,R6
   \   00000016   0x4546             CMP      R6,R8
   \   00000018   0xD20A             BCS.N    ??emberSerialReadData_2
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       emberSerialReadByte
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0xD0F4             BEQ.N    ??emberSerialReadData_1
   \   00000026   0x2826             CMP      R0,#+38
   \   00000028   0xD0F4             BEQ.N    ??emberSerialReadData_0
    732          
    733                case EMBER_SERIAL_RX_EMPTY:
    734                  // empty queue is not an error for us, we just want to keep waiting
    735                  break;
    736          
    737                default:
    738                  // only store number of bytes read if the caller provided a non-NULL pointer
    739                  if (bytesRead) {
   \   0000002A   0xB127             CBZ.N    R7,??emberSerialReadData_3
    740                    *bytesRead = bytesReadInternal;
   \   0000002C   0x803E             STRH     R6,[R7, #+0]
    741                  }
    742                  return status;
   \   0000002E   0xE002             B.N      ??emberSerialReadData_3
    743              }
    744            }
    745          
    746            // only store number of bytes read if the caller provided a non-NULL pointer
    747            if (bytesRead) {
   \                     ??emberSerialReadData_2:
   \   00000030   0xB107             CBZ.N    R7,??emberSerialReadData_4
    748              *bytesRead = bytesReadInternal;
   \   00000032   0x803E             STRH     R6,[R7, #+0]
    749            }
    750          
    751            return EMBER_SUCCESS;
   \                     ??emberSerialReadData_4:
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??emberSerialReadData_3:
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    752          
    753          }
    754          
    755          #ifndef EMBER_TEST

   \                                 In section .text, align 2, keep-with-next
    756          EmberStatus emberSerialReadDataTimeout(int8u port,
    757                                                 int8u *data,
    758                                                 int16u length,
    759                                                 int16u *bytesRead,
    760                                                 int16u firstByteTimeout,
    761                                                 int16u subsequentByteTimeout)
    762          {
   \                     emberSerialReadDataTimeout:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x461E             MOV      R6,R3
   \   0000000C   0x9D0A             LDR      R5,[SP, #+40]
    763            int16u bytesReadInternal = 0;
   \   0000000E   0x2700             MOVS     R7,#+0
    764            EmberStatus status;
    765            int16u timeout = firstByteTimeout;
    766            int16u startTime = halCommonGetInt16uMillisecondTick();
   \   00000010   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000014   0x4683             MOV      R11,R0
   \   00000016   0x9C0B             LDR      R4,[SP, #+44]
   \   00000018   0xE006             B.N      ??emberSerialReadDataTimeout_0
    767            
    768            // loop until we read the max number of bytes or the timeout elapses
    769            while (bytesReadInternal < length
    770                   && elapsedTimeInt16u(startTime,halCommonGetInt16uMillisecondTick()) < timeout) {
    771              status = emberSerialReadByte(port, data);
    772          
    773              switch (status) {
    774                case EMBER_SUCCESS:
    775                  ++data;
   \                     ??emberSerialReadDataTimeout_1:
   \   0000001A   0xF109 0x0901      ADD      R9,R9,#+1
    776                  ++bytesReadInternal;
   \   0000001E   0x1C7F             ADDS     R7,R7,#+1
    777                  // reset timer and timeout for next character
    778                  startTime = halCommonGetInt16uMillisecondTick();
   \   00000020   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000024   0x4683             MOV      R11,R0
    779                  timeout = subsequentByteTimeout;
   \   00000026   0x4625             MOV      R5,R4
    780                  break;
   \                     ??emberSerialReadDataTimeout_0:
   \   00000028   0xB2BF             UXTH     R7,R7
   \   0000002A   0x4557             CMP      R7,R10
   \   0000002C   0xD212             BCS.N    ??emberSerialReadDataTimeout_2
   \   0000002E   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000032   0xEBA0 0x000B      SUB      R0,R0,R11
   \   00000036   0xB280             UXTH     R0,R0
   \   00000038   0xB2AD             UXTH     R5,R5
   \   0000003A   0x42A8             CMP      R0,R5
   \   0000003C   0xD20A             BCS.N    ??emberSerialReadDataTimeout_2
   \   0000003E   0x4649             MOV      R1,R9
   \   00000040   0x4640             MOV      R0,R8
   \   00000042   0x.... 0x....      BL       emberSerialReadByte
   \   00000046   0x0001             MOVS     R1,R0
   \   00000048   0xD0E7             BEQ.N    ??emberSerialReadDataTimeout_1
   \   0000004A   0x2826             CMP      R0,#+38
   \   0000004C   0xD0EC             BEQ.N    ??emberSerialReadDataTimeout_0
    781          
    782                case EMBER_SERIAL_RX_EMPTY:
    783                  // empty queue is not an error for us, we just want to keep waiting
    784                  break;
    785          
    786                default:
    787                  // only store number of bytes read if the caller provided a non-NULL pointer
    788                  if (bytesRead) {
   \   0000004E   0xB13E             CBZ.N    R6,??emberSerialReadDataTimeout_3
    789                    *bytesRead = bytesReadInternal;
   \   00000050   0x8037             STRH     R7,[R6, #+0]
    790                  }
    791                  return status;
   \   00000052   0xE005             B.N      ??emberSerialReadDataTimeout_3
    792              }
    793            }
    794          
    795            // only store number of bytes read if the caller provided a non-NULL pointer
    796            if (bytesRead) {
   \                     ??emberSerialReadDataTimeout_2:
   \   00000054   0xB106             CBZ.N    R6,??emberSerialReadDataTimeout_4
    797              *bytesRead = bytesReadInternal;
   \   00000056   0x8037             STRH     R7,[R6, #+0]
    798            }
    799          
    800            return bytesReadInternal == length ? EMBER_SUCCESS : EMBER_SERIAL_RX_EMPTY;
   \                     ??emberSerialReadDataTimeout_4:
   \   00000058   0x4557             CMP      R7,R10
   \   0000005A   0xBF0C             ITE      EQ 
   \   0000005C   0x2000             MOVEQ    R0,#+0
   \   0000005E   0x2026             MOVNE    R0,#+38
   \                     ??emberSerialReadDataTimeout_3:
   \   00000060   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    801          }
    802          #endif // EMBER_TEST
    803          

   \                                 In section .text, align 2, keep-with-next
    804          EmberStatus emberSerialReadPartialLine(int8u port, char *data, int8u max, int8u * index)
    805          {
   \                     emberSerialReadPartialLine:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461D             MOV      R5,R3
    806            EmberStatus err;
    807            int8u ch;
    808          
    809            if (((*index) == 0) || ((*index) >= max))
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0xB108             CBZ.N    R0,??emberSerialReadPartialLine_0
   \   0000000E   0x42B0             CMP      R0,R6
   \   00000010   0xD308             BCC.N    ??emberSerialReadPartialLine_1
    810              data[0] = '\0';
   \                     ??emberSerialReadPartialLine_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7038             STRB     R0,[R7, #+0]
   \   00000016   0xE005             B.N      ??emberSerialReadPartialLine_1
    811          
    812            for (;;) {   
    813              err = emberSerialReadByte(port, &ch);
    814          
    815              // no new serial port char?, keep looping
    816              if (err) return err;
    817          
    818              // handle bogus characters
    819              if ( ch > 0x7F ) continue;
    820          
    821              // handle leading newline - fogBUGZ # 584
    822              if (((*index) == 0) &&
    823                  ((ch == '\n') || (ch == 0))) continue;
    824          
    825              // Drop the CR, or NULL that is part of EOL sequence.
    826              if ((*index) >= max) {
    827                *index = 0;
    828                if ((ch == '\r') || (ch == 0)) continue;
    829              }
    830          
    831              // handle backspace
    832              if ( ch == 0x8 || ch == 0x7F ) {
    833                if ( (*index) > 0 ) {
    834                  // delete the last character from our string
    835                  (*index)--;
    836                  data[*index] = '\0';
    837                  // echo backspace
    838                  emberSerialWriteString(port, "\b \b");
    839                }
    840                // don't add or process this character
    841                continue;
    842              }
    843          
    844              //if the string is about to overflow, fake in a CR
    845              if ( (*index) + 2 > max ) {
    846                ch = '\r';
    847              }
    848          
    849              emberSerialWriteByte(port, ch); // term char echo
    850          
    851              //upcase that char
    852              if ( ch>='a' && ch<='z') ch = ch - ('a'-'A');
    853          
    854              // build a string until we press enter
    855              if ( ( ch == '\r' ) || ( ch == '\n' ) ) {
    856                data[*index] = '\0';
    857          
    858                if (ch == '\r') {
    859                  emberSerialWriteByte(port, '\n'); // "append" LF
    860                  *index = 0;                       // Reset for next line; \n next
    861                } else {
    862                  emberSerialWriteByte(port, '\r'); // "append" CR
    863                  *index = max;                     // Reset for next line; \r,\0 next
    864                }
    865          
    866                return EMBER_SUCCESS;
    867              } 
    868                
    869              data[(*index)++] = ch;
   \                     ??emberSerialReadPartialLine_2:
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0x1C41             ADDS     R1,R0,#+1
   \   0000001C   0x7029             STRB     R1,[R5, #+0]
   \   0000001E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000022   0x55C1             STRB     R1,[R0, R7]
   \                     ??emberSerialReadPartialLine_1:
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       emberSerialReadByte
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD155             BNE.N    ??emberSerialReadPartialLine_3
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x2880             CMP      R0,#+128
   \   00000036   0xD2F5             BCS.N    ??emberSerialReadPartialLine_1
   \   00000038   0x7828             LDRB     R0,[R5, #+0]
   \   0000003A   0xB928             CBNZ.N   R0,??emberSerialReadPartialLine_4
   \   0000003C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000040   0x290A             CMP      R1,#+10
   \   00000042   0xBF18             IT       NE 
   \   00000044   0x2900             CMPNE    R1,#+0
   \   00000046   0xD0ED             BEQ.N    ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_4:
   \   00000048   0x42B0             CMP      R0,R6
   \   0000004A   0xD307             BCC.N    ??emberSerialReadPartialLine_5
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7028             STRB     R0,[R5, #+0]
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x280D             CMP      R0,#+13
   \   00000056   0xBF18             IT       NE 
   \   00000058   0x2800             CMPNE    R0,#+0
   \   0000005A   0xD0E3             BEQ.N    ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_5:
   \   0000005C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000060   0x2808             CMP      R0,#+8
   \   00000062   0xBF18             IT       NE 
   \   00000064   0x287F             CMPNE    R0,#+127
   \   00000066   0xD10C             BNE.N    ??emberSerialReadPartialLine_6
   \   00000068   0x7828             LDRB     R0,[R5, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD0DA             BEQ.N    ??emberSerialReadPartialLine_1
   \   0000006E   0x1E40             SUBS     R0,R0,#+1
   \   00000070   0x7028             STRB     R0,[R5, #+0]
   \   00000072   0xB2C0             UXTB     R0,R0
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x55C1             STRB     R1,[R0, R7]
   \   00000078   0x....             ADR.N    R1,??DataTable19  ;; "\b \b"
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       emberSerialWriteString
   \   00000080   0xE7D0             B.N      ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_6:
   \   00000082   0x7828             LDRB     R0,[R5, #+0]
   \   00000084   0x1C80             ADDS     R0,R0,#+2
   \   00000086   0x4286             CMP      R6,R0
   \   00000088   0xBFBC             ITT      LT 
   \   0000008A   0x200D             MOVLT    R0,#+13
   \   0000008C   0xF88D 0x0000      STRBLT   R0,[SP, #+0]
   \   00000090   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000094   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_9:
   \   00000098   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009C   0x3861             SUBS     R0,R0,#+97
   \   0000009E   0xB2C0             UXTB     R0,R0
   \   000000A0   0x281A             CMP      R0,#+26
   \   000000A2   0xD204             BCS.N    ??emberSerialReadPartialLine_7
   \   000000A4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A8   0x3820             SUBS     R0,R0,#+32
   \   000000AA   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??emberSerialReadPartialLine_7:
   \   000000AE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B2   0x280D             CMP      R0,#+13
   \   000000B4   0xBF18             IT       NE 
   \   000000B6   0x280A             CMPNE    R0,#+10
   \   000000B8   0xD1AE             BNE.N    ??emberSerialReadPartialLine_2
   \   000000BA   0x7828             LDRB     R0,[R5, #+0]
   \   000000BC   0x2100             MOVS     R1,#+0
   \   000000BE   0x55C1             STRB     R1,[R0, R7]
   \   000000C0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C4   0x280D             CMP      R0,#+13
   \   000000C6   0xD104             BNE.N    ??emberSerialReadPartialLine_8
   \   000000C8   0x200A             MOVS     R0,#+10
   \   000000CA   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_8:
   \   000000CE   0x2600             MOVS     R6,#+0
   \   000000D0   0xE002             B.N      ??CrossCallReturnLabel_7
   \                     ??emberSerialReadPartialLine_8:
   \   000000D2   0x200D             MOVS     R0,#+13
   \   000000D4   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_7:
   \   000000D8   0x702E             STRB     R6,[R5, #+0]
   \   000000DA   0x2000             MOVS     R0,#+0
   \                     ??emberSerialReadPartialLine_3:
   \   000000DC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    870            }
    871          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000000A                      REQUIRE ??Subroutine4_0
   \   0000000A                      ;; // Fall through to label ??Subroutine4_0
    872          

   \                                 In section .text, align 2, keep-with-next
    873          EmberStatus emberSerialReadLine(int8u port, char *data, int8u max)
    874          {
   \                     emberSerialReadLine:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    875            int8u index=0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000010   0xE001             B.N      ??emberSerialReadLine_0
    876          
    877            while(emberSerialReadPartialLine(port, data, max, &index) != EMBER_SUCCESS) {
    878              halResetWatchdog();
   \                     ??emberSerialReadLine_1:
   \   00000012   0x.... 0x....      BL       halInternalResetWatchDog
    879            }
   \                     ??emberSerialReadLine_0:
   \   00000016   0xAB00             ADD      R3,SP,#+0
   \   00000018   0x4632             MOV      R2,R6
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       emberSerialReadPartialLine
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F5             BNE.N    ??emberSerialReadLine_1
    880            return EMBER_SUCCESS;
   \   00000026   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    881          }
    882          
    883          //------------------------------------------------------
    884          // Serial Output
    885          
    886          // returns # bytes (if fifo mode)/messages (if buffer mode) that can be written

   \                                 In section .text, align 2, keep-with-next
    887          int16u emberSerialWriteAvailable(int8u port)  
    888          {
    889          #ifdef EMBER_SERIAL_USE_STDIO
    890            return halInternalPrintfWriteAvailable();
    891          #else //EMBER_SERIAL_USE_STDIO
    892            switch(emSerialPortModes[port]) {
   \                     emberSerialWriteAvailable:
   \   00000000   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   00000004   0x5C41             LDRB     R1,[R0, R1]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD10B             BNE.N    ??emberSerialWriteAvailable_0
    893          #ifdef EM_ENABLE_SERIAL_FIFO
    894            case EMBER_SERIAL_FIFO:
    895              return emSerialTxQueueSizes[port] - 
    896                ((EmSerialFifoQueue*)emSerialTxQueues[port])->used;
   \   0000000A   0x.... 0x....      ADR.W    R1,emSerialTxQueueSizes
   \   0000000E   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   00000012   0x....             LDR.N    R2,??DataTable20_1
   \   00000014   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \   00000018   0x68C0             LDR      R0,[R0, #+12]
   \   0000001A   0x8880             LDRH     R0,[R0, #+4]
   \   0000001C   0x1A08             SUBS     R0,R1,R0
   \   0000001E   0xB280             UXTH     R0,R0
   \   00000020   0x4770             BX       LR
    897          #endif
    898          #ifdef EM_ENABLE_SERIAL_BUFFER
    899            case EMBER_SERIAL_BUFFER: {
    900              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    901              int8u elementsUsed;
    902              int8u elementsDead; 
    903              ATOMIC_LITE( // To clarify the volatile access.
    904                     elementsUsed = q->used;
    905                     elementsDead = q->dead;
    906                     )
    907              return emSerialTxQueueSizes[port] - (elementsUsed + elementsDead);
    908              }
    909          #endif
    910            default: {
    911            }
    912            }
    913            return 0;
   \                     ??emberSerialWriteAvailable_0:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
    914          #endif //EMBER_SERIAL_USE_STDIO
    915          }
    916          

   \                                 In section .text, align 2, keep-with-next
    917          EmberStatus emberSerialWriteByte(int8u port, int8u dataByte)
    918          {
   \                     emberSerialWriteByte:
   \   00000000   0xB502             PUSH     {R1,LR}
    919            return emberSerialWriteData(port, &dataByte, 1);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       emberSerialWriteData
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    920          }
    921          
    922          #ifndef EMBER_SERIAL_USE_STDIO
    923          #ifdef EM_ENABLE_SERIAL_FIFO
    924          static boolean getOutputFifoSpace(EmSerialFifoQueue *q,
    925                                            int8u port,
    926                                            int16u extraByteCount)
    927          {
    928            return (q->used < emSerialTxQueueSizes[port] - extraByteCount);
    929          }
    930          #endif
    931          #endif //EMBER_SERIAL_USE_STDIO
    932          

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine4_0:
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x....             B.N      emberSerialWriteData

   \                                 In section .text, align 2, keep-with-next
    933          EmberStatus emberSerialWriteHex(int8u port, int8u dataByte)
    934          {
   \                     emberSerialWriteHex:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    935            int8u hex[2];
    936            emWriteHexInternal(hex, dataByte, 2);
   \   00000006   0x2202             MOVS     R2,#+2
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      BL       emWriteHexInternal
    937            return emberSerialWriteData(port, hex, 2);
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_6:
   \   00000016   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    938          }
    939          

   \                                 In section .text, align 2, keep-with-next
    940          EmberStatus emberSerialWriteString(int8u port, PGM_P string)
    941          {
   \                     emberSerialWriteString:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   \   00000006   0x460D             MOV      R5,R1
    942          #ifdef EMBER_SERIAL_USE_STDIO
    943            while(*string != '\0') {
    944              putchar(*string);
    945              string++;
    946            }
    947            return EMBER_SUCCESS;
    948          #else //EMBER_SERIAL_USE_STDIO
    949            switch(emSerialPortModes[port]) {
   \   00000008   0x465E             MOV      R6,R11
   \   0000000A   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000000E   0x5C30             LDRB     R0,[R6, R0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD138             BNE.N    ??emberSerialWriteString_0
    950          #ifdef EM_ENABLE_SERIAL_FIFO
    951            case EMBER_SERIAL_FIFO:
    952              {
    953                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000014   0x....             LDR.N    R0,??DataTable20_1
   \   00000016   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   0000001A   0x68C7             LDR      R7,[R0, #+12]
    954                boolean kickStartTx = FALSE;
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0x.... 0x....      ADR.W    R8,emSerialBlocking
   \   00000022   0x.... 0x....      ADR.W    R9,emSerialTxQueueWraps
   \   00000026   0x.... 0x....      ADR.W    R10,emSerialTxQueueSizes
   \   0000002A   0xE015             B.N      ??emberSerialWriteString_1
    955          
    956                while(*string != '\0') {
    957                  while (! getOutputFifoSpace(q, port, 0)) {
    958                    if (kickStartTx) {
    959                      halInternalStartUartTx(port);
    960                      kickStartTx = FALSE;
    961                    }
    962                    #ifdef EM_ENABLE_SERIAL_BLOCKING
    963                      if (emSerialBlocking[port]) {
    964                        simulatedSerialTimePasses();
    965                        // Pet the watchdog here?
    966                        continue;
    967                      }
    968                    #endif
    969                    return EMBER_SERIAL_TX_OVERFLOW;
    970                  }
    971                  ATOMIC_LITE(
    972                    if (q->used == 0) {
    973                      kickStartTx = TRUE;
    974                    }
    975                    FIFO_ENQUEUE(q,*string,emSerialTxQueueWraps[port]);
    976                  )
   \                     ??emberSerialWriteString_2:
   \   0000002C   0x.... 0x....      BL       _disableBasePri
   \   00000030   0x88B9             LDRH     R1,[R7, #+4]
   \   00000032   0xB901             CBNZ.N   R1,??emberSerialWriteString_3
   \   00000034   0x2401             MOVS     R4,#+1
   \                     ??emberSerialWriteString_3:
   \   00000036   0x8839             LDRH     R1,[R7, #+0]
   \   00000038   0x19C9             ADDS     R1,R1,R7
   \   0000003A   0xF815 0x2B01      LDRB     R2,[R5], #+1
   \   0000003E   0x718A             STRB     R2,[R1, #+6]
   \   00000040   0x8839             LDRH     R1,[R7, #+0]
   \   00000042   0x1C49             ADDS     R1,R1,#+1
   \   00000044   0xF839 0x2016      LDRH     R2,[R9, R6, LSL #+1]
   \   00000048   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_4:
   \   0000004C   0x8039             STRH     R1,[R7, #+0]
   \   0000004E   0x88B9             LDRH     R1,[R7, #+4]
   \   00000050   0x1C49             ADDS     R1,R1,#+1
   \   00000052   0x80B9             STRH     R1,[R7, #+4]
   \   00000054   0x.... 0x....      BL       _writeBasePri
    977                  string++;
   \                     ??emberSerialWriteString_1:
   \   00000058   0x7828             LDRB     R0,[R5, #+0]
   \   0000005A   0xB178             CBZ.N    R0,??emberSerialWriteString_4
   \                     ??emberSerialWriteString_5:
   \   0000005C   0x88B8             LDRH     R0,[R7, #+4]
   \   0000005E   0xF83A 0x1016      LDRH     R1,[R10, R6, LSL #+1]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD3E2             BCC.N    ??emberSerialWriteString_2
   \   00000066   0xB11C             CBZ.N    R4,??emberSerialWriteString_6
   \   00000068   0x4658             MOV      R0,R11
   \   0000006A   0x.... 0x....      BL       halInternalStartUartTx
   \   0000006E   0x2400             MOVS     R4,#+0
   \                     ??emberSerialWriteString_6:
   \   00000070   0xF816 0x0008      LDRB     R0,[R6, R8]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD1F1             BNE.N    ??emberSerialWriteString_5
   \   00000078   0x2022             MOVS     R0,#+34
   \   0000007A   0xE005             B.N      ??emberSerialWriteString_7
    978                }
    979                // make sure the interrupt is enabled so it will be sent
    980                halInternalStartUartTx(port);
   \                     ??emberSerialWriteString_4:
   \   0000007C   0x4658             MOV      R0,R11
   \   0000007E   0x.... 0x....      BL       halInternalStartUartTx
    981                return EMBER_SUCCESS;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE000             B.N      ??emberSerialWriteString_7
    982              }
    983          #endif
    984          #ifdef EM_ENABLE_SERIAL_BUFFER
    985            case EMBER_SERIAL_BUFFER:
    986              {
    987                EmberMessageBuffer buff = emberAllocateStackBuffer();
    988                if(buff != EMBER_NULL_MESSAGE_BUFFER) {
    989                  EmberStatus stat;
    990                  if((stat=emberAppendPgmStringToLinkedBuffers(buff, string)) 
    991                     == EMBER_SUCCESS) {
    992                    stat = emberSerialWriteBuffer(port, buff, 0, emberMessageBufferLength(buff));
    993                  }
    994                  // Refcounts may be manipulated in ISR if DMA used
    995                  ATOMIC( emberReleaseMessageBuffer(buff); )
    996                  return stat;
    997                }
    998                return EMBER_NO_BUFFERS;
    999              }
   1000          #endif
   1001            default:
   1002              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteString_0:
   \   00000086   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteString_7:
   \   00000088   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1003            }
   1004          #endif //EMBER_SERIAL_USE_STDIO
   1005          }
   1006          

   \                                 In section .text, align 2, keep-with-next
   1007          EmberStatus emberSerialPrintCarriageReturn(int8u port)
   1008          {
   1009            return emberSerialPrintf(port, "\r\n");
   \                     emberSerialPrintCarriageReturn:
   \   00000000   0x....             ADR.N    R1,??DataTable20  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000002   0x....             B.N      emberSerialPrintf
   1010          }
   1011          

   \                                 In section .text, align 2, keep-with-next
   1012          EmberStatus emberSerialPrintfVarArg(int8u port, PGM_P formatString, va_list ap)
   1013          {
   \                     emberSerialPrintfVarArg:
   \   00000000   0xB510             PUSH     {R4,LR}
   1014             EmberStatus stat = EMBER_SUCCESS;
   \   00000002   0x2400             MOVS     R4,#+0
   1015             
   1016          #ifdef EMBER_SERIAL_USE_STDIO
   1017            if(!emPrintfInternal(emberSerialWriteData, port, formatString, ap)) {
   1018              stat = EMBER_ERR_FATAL;
   1019            }
   1020          #else //EMBER_SERIAL_USE_STDIO
   1021            
   1022            switch(emSerialPortModes[port]) {
   \   00000004   0x.... 0x....      ADR.W    R3,emSerialPortModes
   \   00000008   0x5CC3             LDRB     R3,[R0, R3]
   \   0000000A   0x2B01             CMP      R3,#+1
   \   0000000C   0xD108             BNE.N    ??emberSerialPrintfVarArg_0
   1023          #ifdef EM_ENABLE_SERIAL_FIFO
   1024            case EMBER_SERIAL_FIFO: {
   1025              if(!emPrintfInternal(emberSerialWriteData, port, formatString, ap))
   \   0000000E   0x4613             MOV      R3,R2
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x.... 0x....      ADR.W    R0,emberSerialWriteData
   \   00000018   0x.... 0x....      BL       emPrintfInternal
   \   0000001C   0xB900             CBNZ.N   R0,??emberSerialPrintfVarArg_0
   1026                stat = EMBER_ERR_FATAL;
   \   0000001E   0x2401             MOVS     R4,#+1
   1027              break;
   1028            }
   1029          #endif
   1030          #ifdef EM_ENABLE_SERIAL_BUFFER
   1031            case EMBER_SERIAL_BUFFER: {
   1032              EmberMessageBuffer buff = emberAllocateStackBuffer();
   1033              if(buff == EMBER_NULL_MESSAGE_BUFFER) {
   1034                stat = EMBER_NO_BUFFERS;
   1035                break;
   1036              }
   1037              if(emPrintfInternal(emberAppendToLinkedBuffers,
   1038                                  buff,
   1039                                  formatString,
   1040                                  ap)) {
   1041                stat = emberSerialWriteBuffer(port,buff,0,emberMessageBufferLength(buff));
   1042              } else {
   1043                stat = EMBER_NO_BUFFERS;
   1044              }
   1045              // Refcounts may be manipulated in ISR if DMA used
   1046              ATOMIC( emberReleaseMessageBuffer(buff); )
   1047          
   1048              break;
   1049            }
   1050          #endif
   1051            default: {
   1052            }
   1053            } //close switch.
   1054          #endif //EMBER_SERIAL_USE_STDIO
   1055            return stat;
   \                     ??emberSerialPrintfVarArg_0:
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   1056          }
   1057          

   \                                 In section .text, align 2, keep-with-next
   1058          EmberStatus emberSerialPrintf(int8u port, PGM_P formatString, ...)
   1059          {
   \                     emberSerialPrintf:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB580             PUSH     {R7,LR}
   1060            EmberStatus stat;
   1061            va_list ap;
   1062            va_start (ap, formatString);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   1063            stat = emberSerialPrintfVarArg(port, formatString, ap);
   1064            va_end (ap);
   1065            return stat;
   \   00000006   0x.... 0x....      BL       emberSerialPrintfVarArg
   \   0000000A   0xBC02             POP      {R1}
   \   0000000C   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   1066          }
   1067          

   \                                 In section .text, align 2, keep-with-next
   1068          EmberStatus emberSerialPrintfLine(int8u port, PGM_P formatString, ...)
   1069          {
   \                     emberSerialPrintfLine:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4604             MOV      R4,R0
   1070            EmberStatus stat;
   1071            va_list ap;
   1072            va_start (ap, formatString);
   \   00000006   0xAA04             ADD      R2,SP,#+16
   1073            stat = emberSerialPrintfVarArg(port, formatString, ap);
   \   00000008   0x.... 0x....      BL       emberSerialPrintfVarArg
   \   0000000C   0x4605             MOV      R5,R0
   1074            va_end (ap);
   1075            emberSerialPrintCarriageReturn(port);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       emberSerialPrintCarriageReturn
   1076            return stat;
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x....             B.N      ?Subroutine0
   1077          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xBC32             POP      {R1,R4,R5}
   \   00000002   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   1078          

   \                                 In section .text, align 4, keep-with-next
   1079          EmberStatus emberSerialWriteData(int8u port, int8u *data, int8u length)
   1080          {
   \                     emberSerialWriteData:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x4616             MOV      R6,R2
   1081          #ifdef EMBER_SERIAL_USE_STDIO
   1082            while(length--) {
   1083              putchar(*data);
   1084              data++;
   1085            }
   1086            return EMBER_SUCCESS;
   1087          #else //EMBER_SERIAL_USE_STDIO
   1088            switch(emSerialPortModes[port]) {
   \   0000000A   0x4647             MOV      R7,R8
   \   0000000C   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   00000010   0x5C38             LDRB     R0,[R7, R0]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD13A             BNE.N    ??emberSerialWriteData_0
   1089          #ifdef EM_ENABLE_SERIAL_FIFO
   1090            case EMBER_SERIAL_FIFO:
   1091              {
   1092                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000016   0x....             LDR.N    R0,??DataTable20_1
   \   00000018   0xEB00 0x0087      ADD      R0,R0,R7, LSL #+2
   \   0000001C   0x68C4             LDR      R4,[R0, #+12]
   1093                boolean kickStartTx = FALSE;
   \   0000001E   0x2500             MOVS     R5,#+0
   \   00000020   0x.... 0x....      ADR.W    R9,emSerialBlocking
   \   00000024   0x.... 0x....      ADR.W    R10,emSerialTxQueueSizes
   \   00000028   0xE017             B.N      ??emberSerialWriteData_1
   1094          
   1095                while(length--) {
   1096                  while (! getOutputFifoSpace(q, port, 0)) {
   1097                    if (kickStartTx) {
   1098                      halInternalStartUartTx(port);
   1099                      kickStartTx = FALSE;
   1100                    }
   1101                    #ifdef EM_ENABLE_SERIAL_BLOCKING
   1102                      if (emSerialBlocking[port]) {
   1103                        simulatedSerialTimePasses();
   1104                        // Pet the watchdog here?
   1105                        continue;
   1106                      }
   1107                    #endif
   1108                    return EMBER_SERIAL_TX_OVERFLOW;
   1109                  }
   1110                  ATOMIC_LITE(
   1111                    if (q->used == 0) {
   1112                      kickStartTx = TRUE;
   1113                    }
   1114                    FIFO_ENQUEUE(q,*data,emSerialTxQueueWraps[port]);
   1115                  )
   \                     ??emberSerialWriteData_2:
   \   0000002A   0x.... 0x....      BL       _disableBasePri
   \   0000002E   0x88A1             LDRH     R1,[R4, #+4]
   \   00000030   0xB901             CBNZ.N   R1,??emberSerialWriteData_3
   \   00000032   0x2501             MOVS     R5,#+1
   \                     ??emberSerialWriteData_3:
   \   00000034   0x8821             LDRH     R1,[R4, #+0]
   \   00000036   0x1909             ADDS     R1,R1,R4
   \   00000038   0xF81B 0x2B01      LDRB     R2,[R11], #+1
   \   0000003C   0x718A             STRB     R2,[R1, #+6]
   \   0000003E   0x8821             LDRH     R1,[R4, #+0]
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \   00000042   0x.... 0x....      ADR.W    R2,emSerialTxQueueWraps
   \   00000046   0xF832 0x2017      LDRH     R2,[R2, R7, LSL #+1]
   \   0000004A   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_5:
   \   0000004E   0x8021             STRH     R1,[R4, #+0]
   \   00000050   0x88A1             LDRH     R1,[R4, #+4]
   \   00000052   0x1C49             ADDS     R1,R1,#+1
   \   00000054   0x80A1             STRH     R1,[R4, #+4]
   \   00000056   0x.... 0x....      BL       _writeBasePri
   1116                  data++;
   \                     ??emberSerialWriteData_1:
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x1E46             SUBS     R6,R0,#+1
   \   0000005E   0xB2C0             UXTB     R0,R0
   \   00000060   0xB178             CBZ.N    R0,??emberSerialWriteData_4
   \                     ??emberSerialWriteData_5:
   \   00000062   0x88A0             LDRH     R0,[R4, #+4]
   \   00000064   0xF83A 0x1017      LDRH     R1,[R10, R7, LSL #+1]
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD3DE             BCC.N    ??emberSerialWriteData_2
   \   0000006C   0xB11D             CBZ.N    R5,??emberSerialWriteData_6
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x.... 0x....      BL       halInternalStartUartTx
   \   00000074   0x2500             MOVS     R5,#+0
   \                     ??emberSerialWriteData_6:
   \   00000076   0xF817 0x0009      LDRB     R0,[R7, R9]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD1F1             BNE.N    ??emberSerialWriteData_5
   \   0000007E   0x2022             MOVS     R0,#+34
   \   00000080   0xE005             B.N      ??emberSerialWriteData_7
   1117                }
   1118                // make sure the interrupt is enabled so it will be sent
   1119                halInternalStartUartTx(port);
   \                     ??emberSerialWriteData_4:
   \   00000082   0x4640             MOV      R0,R8
   \   00000084   0x.... 0x....      BL       halInternalStartUartTx
   1120                return EMBER_SUCCESS;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE000             B.N      ??emberSerialWriteData_7
   1121              }
   1122          #endif
   1123          #ifdef EM_ENABLE_SERIAL_BUFFER
   1124            case EMBER_SERIAL_BUFFER:
   1125              {
   1126                // Note: We must always copy this, even in buffer mode
   1127                //  since it is ram based data and there are no reference counts
   1128                //  or indication of when it is actually written out the serial
   1129                //  we cannot trust that the data won't be changed after this call
   1130                //  but before it was actually written out.
   1131                EmberMessageBuffer buff = emberFillLinkedBuffers(data,length);
   1132                if(buff != EMBER_NULL_MESSAGE_BUFFER) {
   1133                  EmberStatus stat = emberSerialWriteBuffer(port, buff, 0, emberMessageBufferLength(buff));
   1134                  // Refcounts may be manipulated in ISR if DMA used
   1135                  ATOMIC( emberReleaseMessageBuffer(buff); )
   1136                  return stat;
   1137                } else 
   1138                  return EMBER_NO_BUFFERS;
   1139              }
   1140          #endif
   1141            default:
   1142              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteData_0:
   \   0000008C   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteData_7:
   \   0000008E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1143            }
   1144          #endif //EMBER_SERIAL_USE_STDIO
   1145          }
   1146          
   1147          #ifndef  NO_PACKET_BUFFERS

   \                                 In section .text, align 2, keep-with-next
   1148          EmberStatus emberSerialWriteBuffer(int8u port, 
   1149                                             EmberMessageBuffer buffer, 
   1150                                             int8u start, 
   1151                                             int8u length)
   1152          {
   \                     emberSerialWriteBuffer:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   1153          //Host processors do not use Ember Message Buffers.
   1154          #if defined(EZSP_HOST) || defined(EMBER_SERIAL_USE_STDIO)
   1155            return EMBER_ERR_FATAL;  //This function is invalid.
   1156          #else// !EZSP_HOST && !EMBER_SERIAL_USE_STDIO
   1157          
   1158            if(buffer == EMBER_NULL_MESSAGE_BUFFER)
   \   0000000C   0x2DFF             CMP      R5,#+255
   \   0000000E   0xD00A             BEQ.N    ??emberSerialWriteBuffer_0
   1159              return EMBER_ERR_FATAL;
   1160            if(length == 0)
   \   00000010   0xB90F             CBNZ.N   R7,??emberSerialWriteBuffer_1
   1161              return EMBER_SUCCESS;
   \                     ??emberSerialWriteBuffer_2:
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE008             B.N      ??emberSerialWriteBuffer_3
   1162          
   1163            switch(emSerialPortModes[port]) {
   \                     ??emberSerialWriteBuffer_1:
   \   00000016   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000001A   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0x....             LDR.N    R4,??DataTable20_2
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0xD004             BEQ.N    ??emberSerialWriteBuffer_4
   1164          #ifdef   EM_ENABLE_SERIAL_FIFO
   1165            case EMBER_SERIAL_FIFO:
   1166              {
   1167                for(;PACKET_BUFFER_SIZE <= start; start-=PACKET_BUFFER_SIZE)
   1168                  buffer = emberStackBufferLink(buffer);
   1169                
   1170                while (0 < length) {
   1171                  int8u remainingInBuffer = PACKET_BUFFER_SIZE - start;
   1172                  int8u bytes = (length < remainingInBuffer
   1173                                 ? length
   1174                                 : remainingInBuffer);
   1175                  emberSerialWriteData(port,
   1176                                       emberMessageBufferContents(buffer) + start,
   1177                                       bytes);
   1178                  length -= bytes;
   1179                  start = 0;
   1180                  buffer = emberStackBufferLink(buffer);
   1181                }
   1182                // make sure the interrupt is enabled so it will be sent
   1183                halInternalStartUartTx(port);
   1184                break;
   1185              }
   1186          #endif// EM_ENABLE_SERIAL_FIFO
   1187          #ifdef   EM_ENABLE_SERIAL_BUFFER
   1188            case EMBER_SERIAL_BUFFER:
   1189              {
   1190                EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1191                EmSerialBufferQueueEntry *e;
   1192                int8u elementsUsed;
   1193                int8u elementsDead;
   1194          
   1195                ATOMIC_LITE( // To clarify volatile access.
   1196                       elementsUsed = q->used;
   1197                       elementsDead = q->dead;
   1198                       )
   1199                
   1200                #ifdef   EM_ENABLE_SERIAL_BLOCKING
   1201                if(emSerialBlocking[port]) {
   1202                  while((elementsUsed + elementsDead) >= emSerialTxQueueSizes[port]) {
   1203                    emberSerialBufferTick();
   1204                    //re-read the element counters after clocking the serial buffers
   1205                    ATOMIC_LITE( // To clarify volatile access.
   1206                          elementsUsed = q->used;
   1207                          elementsDead = q->dead;
   1208                          )
   1209                  }
   1210                } else
   1211                #endif// EM_ENABLE_SERIAL_BLOCKING
   1212                if((elementsUsed + elementsDead) >= emSerialTxQueueSizes[port]) {
   1213                  if(elementsDead)
   1214                    emberSerialBufferTick();
   1215                  else
   1216                    return EMBER_SERIAL_TX_OVERFLOW;
   1217                }
   1218          
   1219                for(;PACKET_BUFFER_SIZE <= start; start-=PACKET_BUFFER_SIZE) {
   1220                  buffer = emberStackBufferLink(buffer);
   1221                }
   1222                emberHoldMessageBuffer(buffer);
   1223                
   1224                e = &q->fifo[q->head];
   1225                e->length = length;
   1226                e->buffer = buffer;
   1227                e->startIndex = start;
   1228                #ifdef AVR_ATMEGA
   1229                  //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1230                  //supported and therefore we use a mask
   1231                  q->head = ((q->head+1) & emSerialTxQueueMasks[port]);
   1232                #else // AVR_ATMEGA
   1233                  //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1234                  //supported and therefore we use a mod with the queue size
   1235                  q->head = ((q->head+1) % emSerialTxQueueSizes[port]);
   1236                #endif // !AVR_ATMEGA
   1237                ATOMIC_LITE(
   1238                  q->used++;
   1239                )
   1240                halInternalStartUartTx(port);  
   1241                break; 
   1242              }
   1243          #endif// EM_ENABLE_SERIAL_BUFFER
   1244            default:
   1245              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteBuffer_0:
   \   00000026   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteBuffer_3:
   \   00000028   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??emberSerialWriteBuffer_5:
   \   0000002C   0x5C2D             LDRB     R5,[R5, R0]
   \   0000002E   0x3E20             SUBS     R6,R6,#+32
   \                     ??emberSerialWriteBuffer_4:
   \   00000030   0xB2F6             UXTB     R6,R6
   \   00000032   0x2E20             CMP      R6,#+32
   \   00000034   0xD2FA             BCS.N    ??emberSerialWriteBuffer_5
   \                     ??emberSerialWriteBuffer_6:
   \   00000036   0xF1C6 0x0020      RSB      R0,R6,#+32
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x46B9             MOV      R9,R7
   \   0000003E   0x4287             CMP      R7,R0
   \   00000040   0xBF88             IT       HI 
   \   00000042   0x4681             MOVHI    R9,R0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       emberMessageBufferContents
   \   0000004A   0xFA5F 0xF289      UXTB     R2,R9
   \   0000004E   0x1831             ADDS     R1,R6,R0
   \   00000050   0x4640             MOV      R0,R8
   \   00000052   0x.... 0x....      BL       emberSerialWriteData
   \   00000056   0xEBA7 0x0709      SUB      R7,R7,R9
   \   0000005A   0x2600             MOVS     R6,#+0
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x5C2D             LDRB     R5,[R5, R0]
   \   00000060   0xB2FF             UXTB     R7,R7
   \   00000062   0x2F00             CMP      R7,#+0
   \   00000064   0xD1E7             BNE.N    ??emberSerialWriteBuffer_6
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x.... 0x....      BL       halInternalStartUartTx
   1246            }
   1247            return EMBER_SUCCESS;
   \   0000006C   0xE7D1             B.N      ??emberSerialWriteBuffer_2
   1248          #endif// !EZSP_HOST && !EMBER_SERIAL_USE_STDIO
   1249          }
   1250          #endif// NO_PACKET_BUFFERS
   1251          
   1252          

   \                                 In section .text, align 2, keep-with-next
   1253          EmberStatus emberSerialWaitSend(int8u port)  // waits for all byte to be written out of a port
   1254          {
   \                     emberSerialWaitSend:
   \   00000000   0xB580             PUSH     {R7,LR}
   1255          #ifdef EMBER_SERIAL_USE_STDIO
   1256            fflush(stdout);
   1257          #else //EMBER_SERIAL_USE_STDIO
   1258            switch(emSerialPortModes[port]) {
   \   00000002   0x.... 0x....      ADR.W    R2,emSerialPortModes
   \   00000006   0x5C82             LDRB     R2,[R0, R2]
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xD106             BNE.N    ??emberSerialWaitSend_0
   1259          #ifdef EM_ENABLE_SERIAL_FIFO
   1260            case EMBER_SERIAL_FIFO: {
   1261              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   0000000C   0x....             LDR.N    R2,??DataTable20_1
   \   0000000E   0xEB02 0x0180      ADD      R1,R2,R0, LSL #+2
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   1262              while(q->used)
   \                     ??emberSerialWaitSend_1:
   \   00000014   0x888A             LDRH     R2,[R1, #+4]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1FC             BNE.N    ??emberSerialWaitSend_1
   1263                simulatedSerialTimePasses();
   1264              break; }
   1265          #endif
   1266          #ifdef EM_ENABLE_SERIAL_BUFFER
   1267            case EMBER_SERIAL_BUFFER: {
   1268              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1269              while(q->used) {
   1270                simulatedSerialTimePasses();
   1271              }
   1272              break; }
   1273          #endif
   1274            default: {
   1275            }
   1276            } // close switch.
   1277            halInternalWaitUartTxComplete(port);
   \                     ??emberSerialWaitSend_0:
   \   0000001A   0x.... 0x....      BL       halInternalWaitUartTxComplete
   1278          #endif //EMBER_SERIAL_USE_STDIO
   1279            return EMBER_SUCCESS;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
   1280          }
   1281          
   1282          //------------------------------------------------------
   1283          // Guaranteed output
   1284          
   1285          // The _only_ Guaranteed API:  The usage model for this api 
   1286          //   Does not require efficiency

   \                                 In section .text, align 2, keep-with-next
   1287          EmberStatus emberSerialGuaranteedPrintf(int8u port, PGM_P formatString, ...)
   1288          {
   \                     emberSerialGuaranteedPrintf:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1289          #ifdef EMBER_SERIAL_USE_STDIO
   1290            //TODO: This function might have to break stdio abstraction to operate
   1291            //      with interrupts off and guarantee a print.
   1292            //NOTE: The following code is the same code found in emberSerialPrintf
   1293            EmberStatus stat;
   1294            halInternalForcePrintf(TRUE);
   1295            va_list ap;
   1296            va_start (ap, formatString);
   1297            stat = emberSerialPrintfVarArg(port, formatString, ap);
   1298            va_end (ap);
   1299            halInternalForcePrintf(FALSE);
   1300            return stat;
   1301          #else //EMBER_SERIAL_USE_STDIO
   1302            va_list ap;
   1303            
   1304            // prevent interrupt driven transmission from intermixing
   1305            halInternalStopUartTx(port);
   \   00000008   0x.... 0x....      BL       halInternalStopUartTx
   1306            va_start(ap, formatString);
   \   0000000C   0xAB04             ADD      R3,SP,#+16
   1307            emPrintfInternal(halInternalForceWriteUartData, port, formatString, ap);
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x....             LDR.N    R0,??DataTable20_3
   \   00000014   0x.... 0x....      BL       emPrintfInternal
   1308            va_end(ap);
   1309          
   1310            // re-enable interrupt driven transmission if needed
   1311            switch(emSerialPortModes[port]) {
   \   00000018   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   0000001C   0x5C61             LDRB     R1,[R4, R1]
   \   0000001E   0x2901             CMP      R1,#+1
   \   00000020   0xD108             BNE.N    ??emberSerialGuaranteedPrintf_0
   1312          #ifdef EM_ENABLE_SERIAL_FIFO
   1313            case EMBER_SERIAL_FIFO: {
   1314              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   1315              if(q->used)
   \   00000022   0x....             LDR.N    R1,??DataTable20_1
   \   00000024   0xEB01 0x0084      ADD      R0,R1,R4, LSL #+2
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0x8880             LDRH     R0,[R0, #+4]
   \   0000002C   0xB110             CBZ.N    R0,??emberSerialGuaranteedPrintf_0
   1316                halInternalStartUartTx(port);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       halInternalStartUartTx
   1317              break; }
   1318          #endif
   1319          #ifdef EM_ENABLE_SERIAL_BUFFER
   1320            case EMBER_SERIAL_BUFFER: {
   1321              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1322              if(q->used)
   1323                halInternalStartUartTx(port);
   1324              break; }
   1325          #endif
   1326            default: {
   1327            }
   1328            } //close switch.
   1329          
   1330            return EMBER_SUCCESS;
   \                     ??emberSerialGuaranteedPrintf_0:
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036                      REQUIRE ?Subroutine0
   \   00000036                      ;; // Fall through to label ?Subroutine0
   1331          #endif //EMBER_SERIAL_USE_STDIO
   1332          }
   1333          
   1334          //------------------------------------------------------
   1335          // Serial buffer maintenance

   \                                 In section .text, align 2, keep-with-next
   1336          void emberSerialFlushRx(int8u port) 
   1337          {
   \                     emberSerialFlushRx:
   \   00000000   0xB510             PUSH     {R4,LR}
   1338          #ifdef EMBER_SERIAL_USE_STDIO
   1339            ATOMIC(
   1340              while(halInternalPrintfReadAvailable()) {
   1341                (int)getchar();
   1342              }
   1343            )
   1344          #else //EMBER_SERIAL_USE_STDIO
   1345            EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialRxQueues[port];
   \   00000002   0x....             LDR.N    R1,??DataTable20_1
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x69C4             LDR      R4,[R0, #+28]
   1346          
   1347            ATOMIC_LITE(
   1348               q->used = 0;
   1349               q->head = 0;
   1350               q->tail = 0;
   1351               )
   \   0000000A   0x.... 0x....      BL       _disableBasePri
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x80A1             STRH     R1,[R4, #+4]
   \   00000012   0x8021             STRH     R1,[R4, #+0]
   \   00000014   0x8061             STRH     R1,[R4, #+2]
   \   00000016   0x.... 0x....      BL       _writeBasePri
   1352          
   1353            halInternalRestartUart();
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      halInternalRestartUart
   1354          #endif //EMBER_SERIAL_USE_STDIO
   1355          }
   1356          
   1357          //------------------------------------------------------
   1358          // Serial Buffer Cleanup Tick
   1359          
   1360          #ifdef EM_ENABLE_SERIAL_BUFFER
   1361          //Helper function to calculate deadIndex since ifdefs cannot exist in the 
   1362          //ATOMIC_LITE block
   1363          int8u calculateDeadIndex(int8u port, int8u tail, int8u numDead) {
   1364            int8u deadIndex;
   1365            
   1366            #ifdef AVR_ATMEGA
   1367              //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1368              //supported and therefore we use a mask
   1369              deadIndex = (tail - numDead) & emSerialTxQueueMasks[port];
   1370            #else // AVR_ATMEGA
   1371              //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1372              //supported and therefore we need to use a conditional to figure
   1373              //out the deadIndex
   1374              if(numDead > tail) {
   1375                //Since subtracting numDead from tail would cause deadIndex to
   1376                //wrap, we add the tail to the queue size and then subtract
   1377                //numDead
   1378                deadIndex = (emSerialTxQueueSizes[port] + tail) - numDead;
   1379              } else {
   1380                deadIndex = tail - numDead;
   1381              }
   1382            #endif // !AVR_ATMEGA
   1383            
   1384            return deadIndex;
   1385          }
   1386          #endif //EM_ENABLE_SERIAL_BUFFER
   1387              

   \                                 In section .text, align 2, keep-with-next
   1388          void emberSerialBufferTick(void)
   1389          {
   1390          #ifdef EM_ENABLE_SERIAL_BUFFER
   1391            int8u port;
   1392            EmSerialBufferQueue *q;
   1393            int8u numDead, deadIndex;
   1394          
   1395            for(port=0; port<EM_NUM_SERIAL_PORTS; port++) {
   1396              if(emSerialPortModes[port] == EMBER_SERIAL_BUFFER) {
   1397                q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1398          
   1399                if(q->dead) {
   1400                  ATOMIC_LITE(
   1401                    numDead = q->dead;
   1402                    q->dead = 0;
   1403                    deadIndex = calculateDeadIndex(port,q->tail,numDead);
   1404                  )
   1405                  for(;numDead;numDead--) {
   1406                    // Refcounts may be manipulated in ISR if DMA used
   1407                    ATOMIC( emberReleaseMessageBuffer(q->fifo[deadIndex].buffer); )
   1408                    #ifdef AVR_ATMEGA
   1409                      //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1410                      //supported and therefore we use a mask
   1411                      deadIndex = (deadIndex + 1) & emSerialTxQueueMasks[port];
   1412                    #else // AVR_ATMEGA
   1413                      //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1414                      //supported and therefore we use a mod with the queue size
   1415                      deadIndex = (deadIndex + 1) % emSerialTxQueueSizes[port];
   1416                    #endif // !AVR_ATMEGA
   1417                  }
   1418                }
   1419              }
   1420            }
   1421          
   1422            simulatedSerialTimePasses();
   1423          #endif
   1424          }
   \                     emberSerialBufferTick:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x08 0x20          DC8      "\b \b"
   \              0x08 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     emSerialRxError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     emPacketBufferLinks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     halInternalForceWriteUartData

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\b \\b">`:
   \   00000000   0x08 0x20          DC8 "\010 \010"
   \              0x08 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\r\\n">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       64  emPrintfInternal
             64 -- Indirect call
             64 -> emWriteHexInternal
       16  emWriteHexInternal
        0  emberSerialBufferTick
        8  emberSerialFlushRx
              8 -> _disableBasePri
              8 -> _writeBasePri
              0 -> halInternalRestartUart
       24  emberSerialGuaranteedPrintf
             24 -> emPrintfInternal
             24 -> halInternalStartUartTx
             24 -> halInternalStopUartTx
       40  emberSerialInit
             40 -> _disableBasePri
             40 -> _writeBasePri
             40 -> halInternalRestartUart
              0 -> halInternalUartInit
        0  emberSerialPrintCarriageReturn
              0 -> emberSerialPrintf
       16  emberSerialPrintf
             16 -> emberSerialPrintfVarArg
       24  emberSerialPrintfLine
             24 -> emberSerialPrintCarriageReturn
             24 -> emberSerialPrintfVarArg
        8  emberSerialPrintfVarArg
              8 -> emPrintfInternal
        8  emberSerialReadAvailable
              8 -> halInternalUartRxPump
       24  emberSerialReadByte
             24 -> _disableBasePri
             24 -> _writeBasePri
             24 -> halInternalUartRxPump
       24  emberSerialReadData
             24 -> emberSerialReadByte
       40  emberSerialReadDataTimeout
             40 -> emberSerialReadByte
             40 -> halCommonGetInt16uMillisecondTick
       24  emberSerialReadLine
             24 -> emberSerialReadPartialLine
             24 -> halInternalResetWatchDog
       24  emberSerialReadPartialLine
             24 -> emberSerialReadByte
             24 -> emberSerialWriteData
             24 -> emberSerialWriteString
        8  emberSerialWaitSend
              8 -> halInternalWaitUartTxComplete
        0  emberSerialWriteAvailable
       32  emberSerialWriteBuffer
             32 -> emberMessageBufferContents
             32 -> emberSerialWriteData
             32 -> halInternalStartUartTx
        8  emberSerialWriteByte
              8 -> emberSerialWriteData
       40  emberSerialWriteData
             40 -> _disableBasePri
             40 -> _writeBasePri
             40 -> halInternalStartUartTx
       16  emberSerialWriteHex
             16 -> emWriteHexInternal
             16 -> emberSerialWriteData
       40  emberSerialWriteString
             40 -> _disableBasePri
             40 -> _writeBasePri
             40 -> halInternalStartUartTx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "\b \b">
       4  ?<Constant "\r\n">
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??Subroutine4_0
       6  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine2
      10  ?Subroutine3
     370  emPrintfInternal
     136  emSerial0RxQueue
     136  emSerial0TxQueue
     136  emSerial1RxQueue
     136  emSerial1TxQueue
       4  emSerialBlocking
       4  emSerialPortModes
      44  emSerialRxError
          emSerialRxErrorIndex
          emSerialTxQueues
          emSerialRxQueues
       8  emSerialRxQueueSizes
       8  emSerialRxQueueWraps
       8  emSerialTxQueueMasks
       8  emSerialTxQueueSizes
       8  emSerialTxQueueWraps
      42  emWriteHexInternal
       2  emberSerialBufferTick
      34  emberSerialFlushRx
      54  emberSerialGuaranteedPrintf
     108  emberSerialInit
       4  emberSerialPrintCarriageReturn
      16  emberSerialPrintf
      24  emberSerialPrintfLine
      36  emberSerialPrintfVarArg
      22  emberSerialReadAvailable
     142  emberSerialReadByte
      58  emberSerialReadData
     100  emberSerialReadDataTimeout
      40  emberSerialReadLine
     222  emberSerialReadPartialLine
      34  emberSerialWaitSend
      38  emberSerialWriteAvailable
     110  emberSerialWriteBuffer
      12  emberSerialWriteByte
     146  emberSerialWriteData
      24  emberSerialWriteHex
     140  emberSerialWriteString
      36  powers10

 
   544 bytes in section .bss
    44 bytes in section .data
    24 bytes in section .rodata
 1 904 bytes in section .text
 
 1 904 bytes of CODE  memory
    24 bytes of CONST memory
   588 bytes of DATA  memory

Errors: none
Warnings: none
