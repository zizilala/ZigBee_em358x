###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     06/Feb/2015  13:53:12 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\attr #
#                    ibute-storage.c                                          #
#    Command line =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\attr #
#                    ibute-storage.c -D "GENERATED_TOKEN_HEADER=\"app/builder #
#                    /DoorSensor_SM6011/DoorSensor_SM6011_tokens.h\"" -D      #
#                    "ZA_GENERATED_HEADER=\"app/builder/DoorSensor_SM6011/Doo #
#                    rSensor_SM6011.h\"" -D LOCAL_STORAGE_BTL -D              #
#                    "BOARD_HEADER=\"app\builder\DoorSensor_SM6011\DoorSensor #
#                    _SM6011_board.h\"" -D "PLATFORM_HEADER=\"hal/micro/corte #
#                    xm3/compiler/iar.h\"" -D CORTEXM3 -D                     #
#                    CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3585 -D PHY_EM3XX -D  #
#                    "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\ #
#                    "" -D "CONFIGURATION_HEADER=\"app/framework/util/config. #
#                    h\"" -D "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/D #
#                    oorSensor_SM6011/DoorSensor_SM6011_endpoint_config.h\""  #
#                    -D "__SOURCEFILE__=\"attribute-storage.c\"" -lC          #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \ --diag_suppress Pa050 -o C:\Ember\EmberZNet5.3.0-GA\em #
#                    35x\build\DoorSensor_SM6011\ --debug --endian=little     #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\ -I  #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\ #
#                    DoorSensor_SM6011\..\..\..\ -I                           #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\app\framework\include\ -I                #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app #
#                    \builder\DoorSensor_SM6011\..\..\..\stack\ -I            #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\hal\ -I C:\Ember\EmberZNet5.3.0-GA\em35x #
#                    \app\builder\DoorSensor_SM6011\..\..\..\hal\..\ -Ohz     #
#                    --use_c++_inline                                         #
#    List file    =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \attribute-storage.lst                                   #
#    Object file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \attribute-storage.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\attribute-storage.c
      1          // *******************************************************************
      2          // * attribute-storage.c
      3          // *
      4          // * Contains the per-endpoint configuration of attribute tables.
      5          // *
      6          // * Copyright 2013 Silicon Laboratories, Inc.                              *80*
      7          // *******************************************************************
      8          
      9          #include "app/framework/include/af.h"
     10          #include "attribute-storage.h"
     11          #include "common.h"
     12          
     13          //------------------------------------------------------------------------------
     14          // Globals
     15          // This is not declared CONST in order to handle dynamic endpoint information
     16          // retrieved from tokens.

   \                                 In section .bss, align 4
     17          EmberAfDefinedEndpoint emAfEndpoints[MAX_ENDPOINT_COUNT];
   \                     emAfEndpoints:
   \   00000000                      DS8 16
     18          
     19          #if ( ATTRIBUTE_MAX_SIZE == 0 )
     20          #define ACTUAL_ATTRIBUTE_SIZE 1
     21          #else
     22          #define ACTUAL_ATTRIBUTE_SIZE ATTRIBUTE_MAX_SIZE
     23          #endif
     24          
     25          int8u attributeData[ACTUAL_ATTRIBUTE_SIZE];
     26          
     27          #if (!defined(ATTRIBUTE_SINGLETONS_SIZE)) \
     28            || (ATTRIBUTE_SINGLETONS_SIZE == 0)
     29          #define ACTUAL_SINGLETONS_SIZE 1
     30          #else
     31          #define ACTUAL_SINGLETONS_SIZE ATTRIBUTE_SINGLETONS_SIZE
     32          #endif
     33          int8u singletonAttributeData[ACTUAL_SINGLETONS_SIZE];
     34          
     35          int8u emberEndpointCount = 0;
   \                     emberEndpointCount:
   \   00000010                      DS8 1
   \   00000011                      DS8 1
   \                     singletonAttributeData:
   \   00000012                      DS8 2
   \                     attributeData:
   \   00000014                      DS8 32
     36          
     37          // If we have attributes that are more than 2 bytes, then
     38          // we need this data block for the defaults
     39          #ifdef GENERATED_DEFAULTS

   \                                 In section .rodata, align 4, keep-with-next
     40          const int8u generatedDefaults[]               = GENERATED_DEFAULTS;
   \                     generatedDefaults:
   \   00000000   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
     41          #endif // GENERATED_DEFAULTS
     42          
     43          #ifdef GENERATED_MIN_MAX_DEFAULTS
     44          const EmberAfAttributeMinMaxValue minMaxDefaults[]          = GENERATED_MIN_MAX_DEFAULTS;
     45          #endif //GENERATED_MIN_MAX_DEFAULTS
     46          
     47          #ifdef GENERATED_FUNCTION_ARRAYS

   \                                 In section .rodata, align 4, keep-with-next
     48          GENERATED_FUNCTION_ARRAYS
   \                     emberAfFuncArrayIdentifyClusterServer:
   \   00000000   0x........         DC32 emberAfIdentifyClusterServerInitCallback
   \   00000004   0x........         DC32 emberAfIdentifyClusterServerAttributeChangedCallback

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute void (*const emberAfFuncArrayIasZoneClusterServer[2])(void)
   \                     emberAfFuncArrayIasZoneClusterServer:
   \   00000000   0x........         DC32 emberAfIasZoneClusterServerInitCallback
   \   00000004   0x........         DC32 emberAfIasZoneClusterServerAttributeChangedCallback
     49          #endif
     50          
     51          #ifdef EMBER_AF_SUPPORT_COMMAND_DISCOVERY

   \                                 In section .text, align 4, keep-with-next
     52          const EmberAfCommandMetadata generatedCommands[] = GENERATED_COMMANDS;
   \                     generatedCommands:
   \   00000000   0x0003             DC16 3
   \   00000002   0x00 0x09          DC8 0, 9
   \   00000004   0x0003             DC16 3
   \   00000006   0x00 0x02          DC8 0, 2
   \   00000008   0x0003             DC16 3
   \   0000000A   0x01 0x09          DC8 1, 9
   \   0000000C   0x0019             DC16 25
   \   0000000E   0x01 0x01          DC8 1, 1
   \   00000010   0x0019             DC16 25
   \   00000012   0x03 0x01          DC8 3, 1
   \   00000014   0x0019             DC16 25
   \   00000016   0x04 0x01          DC8 4, 1
   \   00000018   0x0019             DC16 25
   \   0000001A   0x06 0x01          DC8 6, 1
   \   0000001C   0x0019             DC16 25
   \   0000001E   0x08 0x01          DC8 8, 1
   \   00000020   0x0500             DC16 1280
   \   00000022   0x00 0x02          DC8 0, 2
   \   00000024   0x0500             DC16 1280
   \   00000026   0x00 0x08          DC8 0, 8
   \   00000028   0x0500             DC16 1280
   \   0000002A   0x01 0x02          DC8 1, 2
     53          #endif
     54          

   \                                 In section .text, align 4, keep-with-next
     55          const EmberAfAttributeMetadata generatedAttributes[] = GENERATED_ATTRIBUTES;
   \                     generatedAttributes:
   \   00000000   0x0000             DC16 0
   \   00000002   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   00000008   0x00000001         DC32 1H
   \   0000000C   0x0007             DC16 7
   \   0000000E   0x30 0x01          DC8 48, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   00000014   0x00000000         DC32 0H
   \   00000018   0x0000             DC16 0
   \   0000001A   0x21 0x02          DC8 33, 2, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   00000020   0x00000000         DC32 0H
   \   00000024   0x0000             DC16 0
   \   00000026   0xF0 0x08          DC8 240, 8, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \   0000002C   0x........         DC32 generatedDefaults
   \   00000030   0x0001             DC16 1
   \   00000032   0x23 0x04          DC8 35, 4, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \   00000038   0x........         DC32 generatedDefaults + 8H
   \   0000003C   0x0006             DC16 6
   \   0000003E   0x30 0x01          DC8 48, 1, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \   00000044   0x00000000         DC32 0H
   \   00000048   0x0000             DC16 0
   \   0000004A   0x30 0x01          DC8 48, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000050   0x00000000         DC32 0H
   \   00000054   0x0001             DC16 1
   \   00000056   0x31 0x02          DC8 49, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000005C   0x00000000         DC32 0H
   \   00000060   0x0002             DC16 2
   \   00000062   0x19 0x02          DC8 25, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000068   0x00000000         DC32 0H
   \   0000006C   0x0010             DC16 16
   \   0000006E   0xF0 0x08          DC8 240, 8, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   00000074   0x00000000         DC32 0H
   \   00000078   0x0011             DC16 17
   \   0000007A   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000080   0x000000FF         DC32 0FFH

   \                                 In section .text, align 4, keep-with-next
     56          const EmberAfCluster generatedClusters[]          = GENERATED_CLUSTERS;
   \                     generatedClusters:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 generatedAttributes
   \   00000008   0x0002 0x0000      DC16 2, 0
   \   0000000C   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x00000000         DC32 0H
   \   00000014   0x0003             DC16 3
   \   00000016   0x00 0x00          DC8 0, 0
   \   00000018   0x........         DC32 generatedAttributes + 18H
   \   0000001C   0x0000 0x0000      DC16 0, 0
   \   00000020   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \   00000024   0x00000000         DC32 0H
   \   00000028   0x0003             DC16 3
   \   0000002A   0x00 0x00          DC8 0, 0
   \   0000002C   0x........         DC32 generatedAttributes + 18H
   \   00000030   0x0001 0x0002      DC16 1, 2
   \   00000034   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \   00000038   0x........         DC32 emberAfFuncArrayIdentifyClusterServer
   \   0000003C   0x0019             DC16 25
   \   0000003E   0x00 0x00          DC8 0, 0
   \   00000040   0x........         DC32 generatedAttributes + 24H
   \   00000044   0x0003 0x000D      DC16 3, 13
   \   00000048   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \   0000004C   0x00000000         DC32 0H
   \   00000050   0x0500             DC16 1280
   \   00000052   0x00 0x00          DC8 0, 0
   \   00000054   0x........         DC32 generatedAttributes + 48H
   \   00000058   0x0005 0x000E      DC16 5, 14
   \   0000005C   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \   00000060   0x........         DC32 emberAfFuncArrayIasZoneClusterServer

   \                                 In section .text, align 4, keep-with-next
     57          const EmberAfEndpointType generatedEmberAfEndpointTypes[]   = GENERATED_ENDPOINT_TYPES;
   \                     generatedEmberAfEndpointTypes:
   \   00000000   0x........         DC32 generatedClusters
   \   00000004   0x05 0x00          DC8 5, 0
   \   00000006   0x001D             DC16 29

   \                                 In section .rodata, align 4, keep-with-next
     58          const EmAfNetwork emAfNetworks[] = EMBER_AF_GENERATED_NETWORKS;
   \                     emAfNetworks:
   \   00000000   0x00 0x04          DC8 0, 4, 1, 0
   \              0x01 0x00    
     59          

   \                                 In section .text, align 4, keep-with-next
     60          const EmberAfManufacturerCodeEntry clusterManufacturerCodes[] = GENERATED_CLUSTER_MANUFACTURER_CODES;
   \                     clusterManufacturerCodes:
   \   00000000   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 2, keep-with-next
     61          const int16u clusterManufacturerCodeCount = GENERATED_CLUSTER_MANUFACTURER_CODE_COUNT;
   \                     clusterManufacturerCodeCount:
   \   00000000   0x0000             DC16 0

   \                                 In section .text, align 4, keep-with-next
     62          const EmberAfManufacturerCodeEntry attributeManufacturerCodes[] = GENERATED_ATTRIBUTE_MANUFACTURER_CODES;
   \                     attributeManufacturerCodes:
   \   00000000   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 2, keep-with-next
     63          const int16u attributeManufacturerCodeCount = GENERATED_ATTRIBUTE_MANUFACTURER_CODE_COUNT;
   \                     attributeManufacturerCodeCount:
   \   00000000   0x0000             DC16 0
     64          
     65          //------------------------------------------------------------------------------
     66          // Forward declarations
     67          
     68          // Returns endpoint index within a given cluster
     69          static int8u findClusterEndpointIndex(int8u endpoint, EmberAfClusterId clusterId, int8u mask);
     70          
     71          //------------------------------------------------------------------------------
     72          
     73          // Initial configuration

   \                                 In section .text, align 2, keep-with-next
     74          void emberAfEndpointConfigure(void) {
   \                     emberAfEndpointConfigure:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
     75            int8u ep;
     76          #ifdef FIXED_ENDPOINT_COUNT
     77            int8u fixedEndpoints[] = FIXED_ENDPOINT_ARRAY;
   \   00000002   0x.... 0x....      ADR.W    R0,`?<Constant {1}>`
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF88D 0x0003      STRB     R0,[SP, #+3]
     78            int16u fixedProfileIds[] = FIXED_PROFILE_IDS;
   \   0000000C   0x.... 0x....      ADR.W    R0,`?<Constant {260}>`
   \   00000010   0x8800             LDRH     R0,[R0, #+0]
   \   00000012   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     79            int16u fixedDeviceIds[] = FIXED_DEVICE_IDS;
   \   00000016   0x.... 0x....      ADR.W    R0,`?<Constant {1026}>`
   \   0000001A   0x8800             LDRH     R0,[R0, #+0]
   \   0000001C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     80            int8u fixedDeviceVersions[] = FIXED_DEVICE_VERSIONS;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF88D 0x0002      STRB     R0,[SP, #+2]
     81            int8u fixedEmberAfEndpointTypes[] = FIXED_ENDPOINT_TYPES;
     82            int8u fixedNetworks[] = FIXED_NETWORKS;
   \   00000026   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     83            emberEndpointCount = FIXED_ENDPOINT_COUNT;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable30
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x7401             STRB     R1,[R0, #+16]
     84            for ( ep = 0; ep < FIXED_ENDPOINT_COUNT; ep++ ) {
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x.... 0x....      ADR.W    R2,generatedEmberAfEndpointTypes
     85              emAfEndpoints[ep].endpoint      = fixedEndpoints[ep];
   \                     ??emberAfEndpointConfigure_0:
   \   00000038   0x010B             LSLS     R3,R1,#+4
   \   0000003A   0xF10D 0x0403      ADD      R4,SP,#+3
   \   0000003E   0x5D0C             LDRB     R4,[R1, R4]
   \   00000040   0x541C             STRB     R4,[R3, R0]
     86              emAfEndpoints[ep].profileId     = fixedProfileIds[ep];
   \   00000042   0x181B             ADDS     R3,R3,R0
   \   00000044   0xF10D 0x0406      ADD      R4,SP,#+6
   \   00000048   0xF834 0x4011      LDRH     R4,[R4, R1, LSL #+1]
   \   0000004C   0x805C             STRH     R4,[R3, #+2]
     87              emAfEndpoints[ep].deviceId      = fixedDeviceIds[ep];
   \   0000004E   0xAC01             ADD      R4,SP,#+4
   \   00000050   0xF834 0x4011      LDRH     R4,[R4, R1, LSL #+1]
   \   00000054   0x809C             STRH     R4,[R3, #+4]
     88              emAfEndpoints[ep].deviceVersion = fixedDeviceVersions[ep];
   \   00000056   0xF10D 0x0402      ADD      R4,SP,#+2
   \   0000005A   0x5D0C             LDRB     R4,[R1, R4]
   \   0000005C   0x719C             STRB     R4,[R3, #+6]
     89              emAfEndpoints[ep].endpointType
     90                = (EmberAfEndpointType*)&(generatedEmberAfEndpointTypes[fixedEmberAfEndpointTypes[ep]]);
   \   0000005E   0xF10D 0x0401      ADD      R4,SP,#+1
   \   00000062   0x5D0C             LDRB     R4,[R1, R4]
   \   00000064   0xEB02 0x04C4      ADD      R4,R2,R4, LSL #+3
   \   00000068   0x609C             STR      R4,[R3, #+8]
     91              emAfEndpoints[ep].networkIndex  = fixedNetworks[ep];
   \   0000006A   0xAC00             ADD      R4,SP,#+0
   \   0000006C   0x5D0C             LDRB     R4,[R1, R4]
   \   0000006E   0x731C             STRB     R4,[R3, #+12]
     92              emAfEndpoints[ep].bitmask = EMBER_AF_ENDPOINT_ENABLED;
   \   00000070   0x2401             MOVS     R4,#+1
   \   00000072   0x735C             STRB     R4,[R3, #+13]
     93            }
   \   00000074   0x1C49             ADDS     R1,R1,#+1
   \   00000076   0x2901             CMP      R1,#+1
   \   00000078   0xDBDE             BLT.N    ??emberAfEndpointConfigure_0
     94          #else
     95            for ( ep = 0; ep < MAX_ENDPOINT_COUNT; ep++ ) {
     96              emAfEndpoints[ep].endpoint      = endpointNumber(ep);
     97              emAfEndpoints[ep].profileId     = endpointProfileId(ep);
     98              emAfEndpoints[ep].deviceId      = endpointDeviceId(ep);
     99              emAfEndpoints[ep].deviceVersion = endpointDeviceVersion(ep);
    100              emAfEndpoints[ep].endpointType  = endpointType(ep);
    101              emAfEndpoints[ep].networkIndex  = endpointNetworkIndex(ep);
    102              emAfEndpoints[ep].bitmask       = EMBER_AF_ENDPOINT_ENABLED;
    103              if ( emAfEndpoints[ep].endpoint != 0xFF ) {
    104                emberEndpointCount++;
    105              } else {
    106                break;
    107              }
    108            }
    109          #endif // FIXED_ENDPOINT_COUNT
    110          }
   \   0000007A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    111          

   \                                 In section .text, align 2, keep-with-next
    112          int8u emberAfEndpointCount()
    113          {
    114            return emberEndpointCount;
   \                     emberAfEndpointCount:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable30
   \   00000004   0x7C00             LDRB     R0,[R0, #+16]
   \   00000006   0x4770             BX       LR               ;; return
    115          }
    116          

   \                                 In section .text, align 2, keep-with-next
    117          boolean emberAfEndpointIndexIsEnabled(int8u index)
    118          {
    119            return (emAfEndpoints[index].bitmask & EMBER_AF_ENDPOINT_ENABLED);
   \                     emberAfEndpointIndexIsEnabled:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable30
   \   00000004   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000008   0x7B40             LDRB     R0,[R0, #+13]
   \   0000000A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000000E   0x4770             BX       LR               ;; return
    120          }
    121          
    122          // some data types (like strings) are sent OTA in human readable order
    123          // (how they are read) instead of little endian as the data types are.

   \                                 In section .text, align 2, keep-with-next
    124          boolean emberAfIsThisDataTypeAStringType(EmberAfAttributeType dataType)
    125          {
    126            return (dataType == ZCL_OCTET_STRING_ATTRIBUTE_TYPE
    127                    || dataType == ZCL_CHAR_STRING_ATTRIBUTE_TYPE
    128                    || dataType == ZCL_LONG_OCTET_STRING_ATTRIBUTE_TYPE
    129                    || dataType == ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsThisDataTypeAStringType:
   \   00000000   0x2841             CMP      R0,#+65
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2842             CMPNE    R0,#+66
   \   00000006   0xD003             BEQ.N    ??emberAfIsThisDataTypeAStringType_0
   \   00000008   0x2843             CMP      R0,#+67
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2844             CMPNE    R0,#+68
   \   0000000E   0xD101             BNE.N    ??emberAfIsThisDataTypeAStringType_1
   \                     ??emberAfIsThisDataTypeAStringType_0:
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   \                     ??emberAfIsThisDataTypeAStringType_1:
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    130          }
    131          

   \                                 In section .text, align 2, keep-with-next
    132          boolean emberAfIsStringAttributeType(EmberAfAttributeType attributeType)
    133          {
    134            return (attributeType == ZCL_OCTET_STRING_ATTRIBUTE_TYPE
    135                    || attributeType == ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsStringAttributeType:
   \   00000000   0x2841             CMP      R0,#+65
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2842             CMPNE    R0,#+66
   \   00000006   0xD101             BNE.N    ??emberAfIsStringAttributeType_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??emberAfIsStringAttributeType_0:
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    136          }
    137          

   \                                 In section .text, align 2, keep-with-next
    138          boolean emberAfIsLongStringAttributeType(EmberAfAttributeType attributeType)
    139          {
    140            return (attributeType == ZCL_LONG_OCTET_STRING_ATTRIBUTE_TYPE
    141                    || attributeType == ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsLongStringAttributeType:
   \   00000000   0x2843             CMP      R0,#+67
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2844             CMPNE    R0,#+68
   \   00000006   0xD101             BNE.N    ??emberAfIsLongStringAttributeType_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??emberAfIsLongStringAttributeType_0:
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    142          }
    143          
    144          // This function is used to call the per-cluster default response callback

   \                                 In section .text, align 2, keep-with-next
    145          void emberAfClusterDefaultResponseCallback(int8u endpoint,
    146                                                     EmberAfClusterId clusterId,
    147                                                     int8u commandId,
    148                                                     EmberAfStatus status,
    149                                                     int8u clientServerMask)
    150          {
   \                     emberAfClusterDefaultResponseCallback:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x461E             MOV      R6,R3
   \   00000008   0x9A06             LDR      R2,[SP, #+24]
    151            EmberAfCluster *cluster = emberAfFindCluster(endpoint,
    152                                                         clusterId,
    153                                                         clientServerMask);
   \   0000000A   0x.... 0x....      BL       emberAfFindCluster
    154            if (cluster != NULL) {
   \   0000000E   0xB160             CBZ.N    R0,??emberAfClusterDefaultResponseCallback_0
    155              EmberAfGenericClusterFunction f =
    156                emberAfFindClusterFunction(cluster,
    157                                           CLUSTER_MASK_DEFAULT_RESPONSE_FUNCTION);
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000016   0x0007             MOVS     R7,R0
    158              if (f != NULL) {
   \   00000018   0xD007             BEQ.N    ??emberAfClusterDefaultResponseCallback_0
    159                emberAfPushEndpointNetworkIndex(endpoint);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    160                ((EmberAfDefaultResponseFunction)f)(endpoint, commandId, status);
   \   00000020   0x4632             MOV      R2,R6
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x47B8             BLX      R7
    161                emberAfPopNetworkIndex();
   \   00000028   0x....             B.N      ?Subroutine0
    162              }
    163            }
    164          }
   \                     ??emberAfClusterDefaultResponseCallback_0:
   \   0000002A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000004   0x.... 0x....      B.W      emberAfPopNetworkIndex
    165          
    166          // This function is used to call the per-cluster message sent callback

   \                                 In section .text, align 2, keep-with-next
    167          void emberAfClusterMessageSentCallback(EmberOutgoingMessageType type,
    168                                                 int16u indexOrDestination,
    169                                                 EmberApsFrame *apsFrame,
    170                                                 int16u msgLen,
    171                                                 int8u *message,
    172                                                 EmberStatus status)
    173          {
   \                     emberAfClusterMessageSentCallback:
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x461D             MOV      R5,R3
   \   0000000C   0x9C0B             LDR      R4,[SP, #+44]
    174            if (apsFrame != NULL && message != NULL && msgLen != 0) {
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0x9E0A             LDRNE    R6,[SP, #+40]
   \   00000012   0x2E00             CMPNE    R6,#+0
   \   00000014   0xD01D             BEQ.N    ??emberAfClusterMessageSentCallback_0
   \   00000016   0xB1E5             CBZ.N    R5,??emberAfClusterMessageSentCallback_0
    175              EmberAfCluster *cluster = emberAfFindCluster(apsFrame->sourceEndpoint,
    176                                                           apsFrame->clusterId,
    177                                                           (((message[0]
    178                                                              & ZCL_FRAME_CONTROL_DIRECTION_MASK)
    179                                                             == ZCL_FRAME_CONTROL_SERVER_TO_CLIENT)
    180                                                            ? CLUSTER_MASK_SERVER
    181                                                            : CLUSTER_MASK_CLIENT));
   \   00000018   0x7830             LDRB     R0,[R6, #+0]
   \   0000001A   0x0700             LSLS     R0,R0,#+28
   \   0000001C   0xBF4C             ITE      MI 
   \   0000001E   0x2240             MOVMI    R2,#+64
   \   00000020   0x2280             MOVPL    R2,#+128
   \   00000022   0x8879             LDRH     R1,[R7, #+2]
   \   00000024   0x7938             LDRB     R0,[R7, #+4]
   \   00000026   0x.... 0x....      BL       emberAfFindCluster
    182              if (cluster != NULL) {
   \   0000002A   0xB190             CBZ.N    R0,??emberAfClusterMessageSentCallback_0
    183                EmberAfGenericClusterFunction f =
    184                  emberAfFindClusterFunction(cluster,
    185                                             CLUSTER_MASK_MESSAGE_SENT_FUNCTION);
   \   0000002C   0x2108             MOVS     R1,#+8
   \   0000002E   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000032   0x4682             MOV      R10,R0
    186                if (f != NULL) {
   \   00000034   0xB168             CBZ.N    R0,??emberAfClusterMessageSentCallback_0
    187                  emberAfPushEndpointNetworkIndex(apsFrame->sourceEndpoint);
   \   00000036   0x7938             LDRB     R0,[R7, #+4]
   \   00000038   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    188                  ((EmberAfMessageSentFunction)f)(type,
    189                                                  indexOrDestination,
    190                                                  apsFrame,
    191                                                  msgLen,
    192                                                  message,
    193                                                  status);
   \   0000003C   0x9401             STR      R4,[SP, #+4]
   \   0000003E   0x9600             STR      R6,[SP, #+0]
   \   00000040   0x462B             MOV      R3,R5
   \   00000042   0x463A             MOV      R2,R7
   \   00000044   0x4649             MOV      R1,R9
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0x47D0             BLX      R10
    194                  emberAfPopNetworkIndex();
   \   0000004A   0xE8BD 0x47F3      POP      {R0,R1,R4-R10,LR}
   \   0000004E   0x.... 0x....      B.W      emberAfPopNetworkIndex
    195                }
    196              }
    197            }
    198          }
   \                     ??emberAfClusterMessageSentCallback_0:
   \   00000052   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    199          
    200          // This function is used to call the per-cluster attribute changed callback

   \                                 In section .text, align 2, keep-with-next
    201          void emAfClusterAttributeChangedCallback(int8u endpoint,
    202                                                   EmberAfClusterId clusterId,
    203                                                   EmberAfAttributeId attributeId,
    204                                                   int8u clientServerMask,
    205                                                   int16u manufacturerCode)
    206          {
   \                     emAfClusterAttributeChangedCallback:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x461A             MOV      R2,R3
    207            EmberAfCluster *cluster = emberAfFindCluster(endpoint,
    208                                                         clusterId,
    209                                                         clientServerMask);
   \   00000008   0x.... 0x....      BL       emberAfFindCluster
    210            if (cluster != NULL) {
   \   0000000C   0xB1D8             CBZ.N    R0,??emAfClusterAttributeChangedCallback_0
   \   0000000E   0x9C06             LDR      R4,[SP, #+24]
    211              if (manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE) {
   \   00000010   0xB2A4             UXTH     R4,R4
   \   00000012   0xB95C             CBNZ.N   R4,??emAfClusterAttributeChangedCallback_1
    212                EmberAfGenericClusterFunction f =
    213                  emberAfFindClusterFunction(cluster,
    214                                             CLUSTER_MASK_ATTRIBUTE_CHANGED_FUNCTION);
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x.... 0x....      BL       emberAfFindClusterFunction
   \   0000001A   0x0004             MOVS     R4,R0
    215                if (f != NULL) {
   \   0000001C   0xD013             BEQ.N    ??emAfClusterAttributeChangedCallback_0
    216                  emberAfPushEndpointNetworkIndex(endpoint);
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    217                  ((EmberAfClusterAttributeChangedCallback)f)(endpoint, attributeId);
   \   00000024   0x4631             MOV      R1,R6
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x47A0             BLX      R4
    218                  emberAfPopNetworkIndex();
   \   0000002A   0xE00B             B.N      ??emAfClusterAttributeChangedCallback_2
    219                }
    220              } else {
    221                EmberAfGenericClusterFunction f =
    222                  emberAfFindClusterFunction(cluster,
    223                                             CLUSTER_MASK_MANUFACTURER_SPECIFIC_ATTRIBUTE_CHANGED_FUNCTION);
   \                     ??emAfClusterAttributeChangedCallback_1:
   \   0000002C   0x2110             MOVS     R1,#+16
   \   0000002E   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000032   0x0007             MOVS     R7,R0
    224                if (f != NULL) {
   \   00000034   0xD007             BEQ.N    ??emAfClusterAttributeChangedCallback_0
    225                  emberAfPushEndpointNetworkIndex(endpoint);
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    226                  ((EmberAfManufacturerSpecificClusterAttributeChangedCallback)f)(endpoint,
    227                                                                                  attributeId,
    228                                                                                  manufacturerCode);
   \   0000003C   0x4622             MOV      R2,R4
   \   0000003E   0x4631             MOV      R1,R6
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0x47B8             BLX      R7
    229                  emberAfPopNetworkIndex();
    230                }
    231              }
    232            }
   \                     ??emAfClusterAttributeChangedCallback_2:
   \   00000044   0x....             B.N      ?Subroutine0
    233          }
   \                     ??emAfClusterAttributeChangedCallback_0:
   \   00000046   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    234          
    235          // This function is used to call the per-cluster pre-attribute changed callback

   \                                 In section .text, align 2, keep-with-next
    236          EmberAfStatus emAfClusterPreAttributeChangedCallback(int8u endpoint,
    237                                                               EmberAfClusterId clusterId,
    238                                                               EmberAfAttributeId attributeId,
    239                                                               int8u clientServerMask,
    240                                                               int16u manufacturerCode,
    241                                                               EmberAfAttributeType attributeType,
    242                                                               int8u size,
    243                                                               int8u* value)
    244          {
   \                     emAfClusterPreAttributeChangedCallback:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461A             MOV      R2,R3
   \   0000000C   0x9E0A             LDR      R6,[SP, #+40]
   \   0000000E   0x9C0B             LDR      R4,[SP, #+44]
   \   00000010   0x9D0C             LDR      R5,[SP, #+48]
   \   00000012   0x9F0D             LDR      R7,[SP, #+52]
    245            EmberAfCluster *cluster = emberAfFindCluster(endpoint,
    246                                                         clusterId,
    247                                                         clientServerMask);
   \   00000014   0x.... 0x....      BL       emberAfFindCluster
    248            if (cluster == NULL) {
   \   00000018   0xB908             CBNZ.N   R0,??emAfClusterPreAttributeChangedCallback_0
    249              return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   0000001A   0x2086             MOVS     R0,#+134
   \   0000001C   0xE015             B.N      ??emAfClusterPreAttributeChangedCallback_1
    250            } else {
    251              EmberAfStatus status = EMBER_ZCL_STATUS_SUCCESS;
   \                     ??emAfClusterPreAttributeChangedCallback_0:
   \   0000001E   0xF04F 0x0A00      MOV      R10,#+0
    252              if (manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE) {
   \   00000022   0xB2B6             UXTH     R6,R6
   \   00000024   0xB986             CBNZ.N   R6,??emAfClusterPreAttributeChangedCallback_2
    253                EmberAfGenericClusterFunction f =
    254                  emberAfFindClusterFunction(cluster,
    255                                             CLUSTER_MASK_PRE_ATTRIBUTE_CHANGED_FUNCTION);
   \   00000026   0x2120             MOVS     R1,#+32
   \   00000028   0x.... 0x....      BL       emberAfFindClusterFunction
   \   0000002C   0x0006             MOVS     R6,R0
    256                if (f != NULL) {
   \   0000002E   0xD00B             BEQ.N    ??emAfClusterPreAttributeChangedCallback_2
    257                  emberAfPushEndpointNetworkIndex(endpoint);
   \   00000030   0x4648             MOV      R0,R9
   \   00000032   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    258                  status = ((EmberAfClusterPreAttributeChangedCallback)f)(endpoint,
    259                                                                          attributeId,
    260                                                                          attributeType,
    261                                                                          size,
    262                                                                          value);
   \   00000036   0x9700             STR      R7,[SP, #+0]
   \   00000038   0x462B             MOV      R3,R5
   \   0000003A   0x4622             MOV      R2,R4
   \   0000003C   0x4641             MOV      R1,R8
   \   0000003E   0x4648             MOV      R0,R9
   \   00000040   0x47B0             BLX      R6
   \   00000042   0x4682             MOV      R10,R0
    263                  emberAfPopNetworkIndex();
   \   00000044   0x.... 0x....      BL       emberAfPopNetworkIndex
    264                }
    265              }
    266              return status;
   \                     ??emAfClusterPreAttributeChangedCallback_2:
   \   00000048   0x4650             MOV      R0,R10
   \                     ??emAfClusterPreAttributeChangedCallback_1:
   \   0000004A   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    267            }
    268          }
    269          

   \                                 In section .text, align 2, keep-with-next
    270          static void initializeEndpoint(EmberAfDefinedEndpoint* definedEndpoint)
    271          {
   \                     initializeEndpoint:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    272            int8u clusterIndex;
    273            EmberAfEndpointType* epType = definedEndpoint->endpointType;
   \   00000004   0x68A5             LDR      R5,[R4, #+8]
    274            emberAfPushEndpointNetworkIndex(definedEndpoint->endpoint);
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    275            for ( clusterIndex = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xE010             B.N      ??initializeEndpoint_0
    276                  clusterIndex < epType->clusterCount;
    277                  clusterIndex ++ ) {
    278              EmberAfCluster *cluster = &(epType->cluster[clusterIndex]);
   \                     ??initializeEndpoint_1:
   \   00000010   0x2014             MOVS     R0,#+20
   \   00000012   0x6829             LDR      R1,[R5, #+0]
   \   00000014   0xFB00 0x1706      MLA      R7,R0,R6,R1
    279              EmberAfGenericClusterFunction f;
    280              emberAfClusterInitCallback(definedEndpoint->endpoint, cluster->clusterId);
   \   00000018   0x8839             LDRH     R1,[R7, #+0]
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       emberAfClusterInitCallback
    281              f = emberAfFindClusterFunction(cluster, CLUSTER_MASK_INIT_FUNCTION);
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000028   0x0001             MOVS     R1,R0
    282              if ( f != NULL ) {
   \   0000002A   0xBF1C             ITT      NE 
   \   0000002C   0x7820             LDRBNE   R0,[R4, #+0]
   \   0000002E   0x4788             BLXNE    R1
    283                ((EmberAfInitFunction)f)(definedEndpoint->endpoint);
    284              }
    285            }
   \   00000030   0x1C76             ADDS     R6,R6,#+1
   \                     ??initializeEndpoint_0:
   \   00000032   0x7928             LDRB     R0,[R5, #+4]
   \   00000034   0xB2F6             UXTB     R6,R6
   \   00000036   0x4286             CMP      R6,R0
   \   00000038   0xD3EA             BCC.N    ??initializeEndpoint_1
    286            emberAfPopNetworkIndex();
   \   0000003A                      REQUIRE ?Subroutine0
   \   0000003A                      ;; // Fall through to label ?Subroutine0
    287          }
    288          
    289          // Calls the init functions.

   \                                 In section .text, align 2, keep-with-next
    290          void emAfCallInits(void)
    291          {
   \                     emAfCallInits:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    292            int8u index;
    293            for ( index = 0; index < emberAfEndpointCount(); index++ ) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable30
   \   00000008   0xE008             B.N      ??emAfCallInits_0
    294              if (emberAfEndpointIndexIsEnabled(index)) {
   \                     ??emAfCallInits_1:
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       emberAfEndpointIndexIsEnabled
   \   00000010   0xB118             CBZ.N    R0,??emAfCallInits_2
    295                initializeEndpoint(&(emAfEndpoints[index]));
   \   00000012   0xEB05 0x1004      ADD      R0,R5,R4, LSL #+4
   \   00000016   0x.... 0x....      BL       initializeEndpoint
    296              }
    297            }
   \                     ??emAfCallInits_2:
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \                     ??emAfCallInits_0:
   \   0000001C   0x7C28             LDRB     R0,[R5, #+16]
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD3F2             BCC.N    ??emAfCallInits_1
    298          }
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    299          
    300          // Returns the pointer to metadata, or null if it is not found

   \                                 In section .text, align 2, keep-with-next
    301          EmberAfAttributeMetadata* emberAfLocateAttributeMetadata(int8u endpoint,
    302                                                                   EmberAfClusterId clusterId,
    303                                                                   EmberAfAttributeId attributeId,
    304                                                                   int8u mask,
    305                                                                   int16u manufacturerCode)
    306          {
   \                     emberAfLocateAttributeMetadata:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x9C08             LDR      R4,[SP, #+32]
    307            EmberAfAttributeMetadata *metadata = NULL;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x9501             STR      R5,[SP, #+4]
    308            EmberAfAttributeSearchRecord record;
    309            record.endpoint = endpoint;
   \   0000000A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    310            record.clusterId = clusterId;
   \   0000000E   0xF8AD 0x100A      STRH     R1,[SP, #+10]
    311            record.clusterMask = mask;
   \   00000012   0xF88D 0x300C      STRB     R3,[SP, #+12]
    312            record.attributeId = attributeId;
   \   00000016   0xF8AD 0x200E      STRH     R2,[SP, #+14]
    313            record.manufacturerCode = manufacturerCode;
   \   0000001A   0xF8AD 0x4010      STRH     R4,[SP, #+16]
    314            emAfReadOrWriteAttribute(&record,
    315                                     &metadata,
    316                                     NULL,   // buffer
    317                                     0,      // buffer size
    318                                     FALSE); // write?
   \   0000001E   0x9500             STR      R5,[SP, #+0]
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x462A             MOV      R2,R5
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0xA802             ADD      R0,SP,#+8
   \   00000028   0x.... 0x....      BL       emAfReadOrWriteAttribute
    319            return metadata;
   \   0000002C   0x9801             LDR      R0,[SP, #+4]
   \   0000002E   0xB005             ADD      SP,SP,#+20
   \   00000030   0xBD30             POP      {R4,R5,PC}       ;; return
    320          }
    321          
    322          static int8u* singletonAttributeLocation(EmberAfAttributeMetadata *am)
    323          {
    324            EmberAfAttributeMetadata *m = (EmberAfAttributeMetadata *)&(generatedAttributes[0]);
    325            int16u index = 0;
    326            while ( m < am ) {
    327              if ( m->mask & ATTRIBUTE_MASK_SINGLETON ) {
    328                index += m->size;
    329              }
    330              m++;
    331            }
    332            return (int8u *)(singletonAttributeData + index);
    333          }
    334          
    335          
    336          // This function does mem copy, but smartly, which means that if the type is a
    337          // string, it will copy as much as it can.
    338          // If src == NULL, then this method will set memory to zeroes
    339          static EmberAfStatus typeSensitiveMemCopy(int8u* dest,
    340                                                    int8u* src,
    341                                                    EmberAfAttributeMetadata * am,
    342                                                    boolean write,
    343                                                    int16u readLength)
    344          {
    345            EmberAfAttributeType attributeType = am->attributeType;
    346            int16u size = (readLength == 0) ? am->size : readLength;
    347          
    348            if (emberAfIsStringAttributeType(attributeType)) {
    349              emberAfCopyString(dest, src, size - 1);
    350            } else if (emberAfIsLongStringAttributeType(attributeType)) {
    351              emberAfCopyLongString(dest, src, size - 2);
    352            } else {
    353              if (!write && readLength != 0 && readLength < am->size) {
    354                  return EMBER_ZCL_STATUS_INSUFFICIENT_SPACE;
    355              }
    356              if ( src == NULL ) {
    357                MEMSET(dest, 0, size);
    358              } else {
    359                MEMCOPY(dest, src, size);
    360              }
    361            }
    362            return EMBER_ZCL_STATUS_SUCCESS;
    363          }
    364          
    365          // Returns the manufacturer code or ::EMBER_AF_NULL_MANUFACTURER_CODE if none
    366          // could be found.

   \                                 In section .text, align 2, keep-with-next
    367          static int16u getManufacturerCode(EmberAfManufacturerCodeEntry *codes,
    368                                            int16u codeTableSize,
    369                                            int16u tableIndex)
    370          {
   \                     getManufacturerCode:
   \   00000000   0xB510             PUSH     {R4,LR}
    371            int16u i;
    372            for (i = 0; i < codeTableSize; i++, codes++) {
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE001             B.N      ??getManufacturerCode_0
   \                     ??getManufacturerCode_1:
   \   00000006   0x1C5B             ADDS     R3,R3,#+1
   \   00000008   0x1D00             ADDS     R0,R0,#+4
   \                     ??getManufacturerCode_0:
   \   0000000A   0xB29B             UXTH     R3,R3
   \   0000000C   0x428B             CMP      R3,R1
   \   0000000E   0xD204             BCS.N    ??getManufacturerCode_2
    373              if (codes->index == tableIndex) {
   \   00000010   0x8804             LDRH     R4,[R0, #+0]
   \   00000012   0x4294             CMP      R4,R2
   \   00000014   0xD1F7             BNE.N    ??getManufacturerCode_1
    374                return codes->manufacturerCode;
   \   00000016   0x8840             LDRH     R0,[R0, #+2]
   \   00000018   0xBD10             POP      {R4,PC}
    375              }
    376            }
    377            return EMBER_AF_NULL_MANUFACTURER_CODE;
   \                     ??getManufacturerCode_2:
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    378          }
    379          

   \                                 In section .text, align 2, keep-with-next
    380          int16u emAfGetManufacturerCodeForAttribute(EmberAfCluster *cluster,
    381                                                     EmberAfAttributeMetadata *attMetaData)
    382          {
    383            return (emberAfClusterIsManufacturerSpecific(cluster)
    384                    ? emAfGetManufacturerCodeForCluster(cluster)
    385                    : getManufacturerCode((EmberAfManufacturerCodeEntry *)attributeManufacturerCodes,
    386                                          attributeManufacturerCodeCount,
    387                                          (attMetaData - generatedAttributes)));
   \                     emAfGetManufacturerCodeForAttribute:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF5B2 0x4F7C      CMP      R2,#+64512
   \   00000006   0xBF28             IT       CS 
   \   00000008   0x.... 0x....      BCS.W    emAfGetManufacturerCodeForCluster
   \   0000000C   0x.... 0x....      ADR.W    R0,generatedAttributes
   \   00000010   0x1A08             SUBS     R0,R1,R0
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000018   0xB292             UXTH     R2,R2
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x.... 0x....      ADR.W    R0,attributeManufacturerCodes
   \   00000020   0x....             B.N      getManufacturerCode
    388          }
    389          

   \                                 In section .text, align 2, keep-with-next
    390          int16u emAfGetManufacturerCodeForCluster(EmberAfCluster *cluster)
    391          {
    392            return getManufacturerCode((EmberAfManufacturerCodeEntry *)clusterManufacturerCodes,
    393                                       clusterManufacturerCodeCount,
    394                                       (cluster - generatedClusters));
   \                     emAfGetManufacturerCodeForCluster:
   \   00000000   0x.... 0x....      ADR.W    R1,generatedClusters
   \   00000004   0x1A40             SUBS     R0,R0,R1
   \   00000006   0x2114             MOVS     R1,#+20
   \   00000008   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   0000000C   0xB292             UXTH     R2,R2
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      ADR.W    R0,clusterManufacturerCodes
   \   00000014   0x....             B.N      getManufacturerCode
    395          }
    396          
    397          /**
    398           * @brief Matches a cluster based on cluster id, direction and manufacturer code.
    399           *   This function assumes that the passed cluster's endpoint already
    400           *   matches the endpoint of the EmberAfAttributeSearchRecord.
    401           *
    402           * Cluster's match if:
    403           *   1. Cluster ids match AND
    404           *   2. Cluster directions match as defined by cluster->mask
    405           *        and attRecord->clusterMask AND
    406           *   3. If the clusters are mf specific, their mf codes match.
    407           */

   \                                 In section .text, align 2, keep-with-next
    408          boolean emAfMatchCluster(EmberAfCluster *cluster,
    409                                   EmberAfAttributeSearchRecord *attRecord)
    410          {
   \                     emAfMatchCluster:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    411            return (cluster->clusterId == attRecord->clusterId
    412                    && cluster->mask & attRecord->clusterMask
    413                    && (!emberAfClusterIsManufacturerSpecific(cluster)
    414                        || (emAfGetManufacturerCodeForCluster(cluster)
    415                            == attRecord->manufacturerCode)));
   \   00000004   0x8801             LDRH     R1,[R0, #+0]
   \   00000006   0x8862             LDRH     R2,[R4, #+2]
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD10D             BNE.N    ??emAfMatchCluster_0
   \   0000000C   0x7B02             LDRB     R2,[R0, #+12]
   \   0000000E   0x7923             LDRB     R3,[R4, #+4]
   \   00000010   0x421A             TST      R2,R3
   \   00000012   0xD009             BEQ.N    ??emAfMatchCluster_0
   \   00000014   0xF5B1 0x4F7C      CMP      R1,#+64512
   \   00000018   0xD304             BCC.N    ??emAfMatchCluster_1
   \   0000001A   0x.... 0x....      BL       emAfGetManufacturerCodeForCluster
   \   0000001E   0x8921             LDRH     R1,[R4, #+8]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD101             BNE.N    ??emAfMatchCluster_0
   \                     ??emAfMatchCluster_1:
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD10             POP      {R4,PC}
   \                     ??emAfMatchCluster_0:
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    416          }
    417          
    418          /**
    419           * @brief Matches an attribute based on attribute id and manufacturer code.
    420           *   This function assumes that the passed cluster already matches the
    421           *   clusterId, direction and mf specificity of the passed
    422           *   EmberAfAttributeSearchRecord.
    423           *
    424           * Note: If both the attribute and cluster are manufacturer specific,
    425           *   the cluster's mf code gets precedence.
    426           *
    427           * Attributes match if:
    428           *   1. Att ids match AND
    429           *      a. cluster IS mf specific OR
    430           *      b. both stored and saught attributes are NOT mf specific OR
    431           *      c. stored att IS mf specific AND mfg codes match.
    432           */

   \                                 In section .text, align 2, keep-with-next
    433          boolean emAfMatchAttribute(EmberAfCluster *cluster,
    434                                     EmberAfAttributeMetadata *am,
    435                                     EmberAfAttributeSearchRecord *attRecord)
    436          {
   \                     emAfMatchAttribute:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4614             MOV      R4,R2
    437            return (am->attributeId == attRecord->attributeId
    438                    && (emberAfClusterIsManufacturerSpecific(cluster)
    439                        || (emAfGetManufacturerCodeForAttribute(cluster, am)
    440                            == attRecord->manufacturerCode)));
   \   00000004   0x880A             LDRH     R2,[R1, #+0]
   \   00000006   0x88E3             LDRH     R3,[R4, #+6]
   \   00000008   0x429A             CMP      R2,R3
   \   0000000A   0xD10A             BNE.N    ??emAfMatchAttribute_0
   \   0000000C   0x8802             LDRH     R2,[R0, #+0]
   \   0000000E   0xF5B2 0x4F7C      CMP      R2,#+64512
   \   00000012   0xD204             BCS.N    ??emAfMatchAttribute_1
   \   00000014   0x.... 0x....      BL       emAfGetManufacturerCodeForAttribute
   \   00000018   0x8921             LDRH     R1,[R4, #+8]
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??emAfMatchAttribute_0
   \                     ??emAfMatchAttribute_1:
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD10             POP      {R4,PC}
   \                     ??emAfMatchAttribute_0:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    441          }
    442          
    443          // The callbacks to read and write externals have the same signature, so it is
    444          // easy to use function pointers to call the right one.  This typedef covers
    445          // both and makes the code a bit easier to read.
    446          typedef EmberAfStatus (*ExternalReadWriteCallback)(int8u, EmberAfClusterId, EmberAfAttributeMetadata *, int16u, int8u *);
    447          
    448          // When reading non-string attributes, this function returns an error when destination
    449          // buffer isn't large enough to accommodate the attribute type.  For strings, the
    450          // function will copy at most readLength bytes.  This means the resulting string
    451          // may be truncated.  The length byte(s) in the resulting string will reflect
    452          // any truncation.  If readLength is zero, we are working with backwards-
    453          // compatibility wrapper functions and we just cross our fingers and hope for
    454          // the best.
    455          //
    456          // When writing attributes, readLength is ignored.  For non-string attributes,
    457          // this function assumes the source buffer is the same size as the attribute
    458          // type.  For strings, the function will copy as many bytes as will fit in the
    459          // attribute.  This means the resulting string may be truncated.  The length
    460          // byte(s) in the resulting string will reflect any truncated.

   \                                 In section .text, align 2, keep-with-next
    461          EmberAfStatus emAfReadOrWriteAttribute(EmberAfAttributeSearchRecord *attRecord,
    462                                                 EmberAfAttributeMetadata **metadata,
    463                                                 int8u *buffer,
    464                                                 int16u readLength,
    465                                                 boolean write)
    466          {
   \                     emAfReadOrWriteAttribute:
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
    467            int8u i;
    468            int16u attributeOffsetIndex = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    469          
    470            for (i = 0; i < emberAfEndpointCount(); i++) {
   \   0000000A   0x46AA             MOV      R10,R5
   \   0000000C   0x.... 0x....      LDR.W    R11,??DataTable30
   \   00000010   0xE004             B.N      ??emAfReadOrWriteAttribute_0
    471              if (emAfEndpoints[i].endpoint == attRecord->endpoint) {
    472                EmberAfEndpointType *endpointType = emAfEndpoints[i].endpointType;
    473                int8u clusterIndex;
    474                if (!emberAfEndpointIndexIsEnabled(i)) {
    475                  continue;
    476                }
    477                for (clusterIndex = 0;
    478                     clusterIndex < endpointType->clusterCount;
    479                     clusterIndex++) {
    480                  EmberAfCluster *cluster = &(endpointType->cluster[clusterIndex]);
    481                  if (emAfMatchCluster(cluster, attRecord)) { // Got the cluster
    482                    int16u attrIndex;
    483                    for (attrIndex = 0;
    484                         attrIndex < cluster->attributeCount;
    485                         attrIndex++) {
    486                      EmberAfAttributeMetadata *am = &(cluster->attributes[attrIndex]);
    487                      if (emAfMatchAttribute(cluster,
    488                                             am,
    489                                             attRecord)) { // Got the attribute
    490          
    491                        // If passed metadata location is not null, populate
    492                        if (metadata != NULL) {
    493                          *metadata = am;
    494                        }
    495          
    496                        {
    497                          int8u *attributeLocation = (am->mask & ATTRIBUTE_MASK_SINGLETON
    498                                                      ? singletonAttributeLocation(am)
    499                                                      : attributeData + attributeOffsetIndex);
    500                          int8u *src, *dst;
    501                          ExternalReadWriteCallback callback;
    502                          if (write) {
    503                            src = buffer;
    504                            dst = attributeLocation;
    505                            callback = &emberAfExternalAttributeWriteCallback;
    506                          } else {
    507                            if (buffer == NULL) {
    508                              return EMBER_ZCL_STATUS_SUCCESS;
    509                            }
    510          
    511                            src = attributeLocation;
    512                            dst = buffer;
    513                            callback = &emberAfExternalAttributeReadCallback;
    514                          }
    515          
    516                          return (am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE
    517                                  ? (*callback)(attRecord->endpoint,
    518                                                attRecord->clusterId,
    519                                                am,
    520                                                emAfGetManufacturerCodeForAttribute(cluster, am),
    521                                                buffer)
    522                                  : typeSensitiveMemCopy(dst,
    523                                                         src,
    524                                                         am,
    525                                                         write,
    526                                                         readLength));
    527                        }
    528                      } else { // Not the attribute we are looking for
    529                        // Increase the index if attribute is not externally stored
    530                        if (!(am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE)
    531                             && !(am->mask & ATTRIBUTE_MASK_SINGLETON) ) {
    532                          attributeOffsetIndex += emberAfAttributeSize(am);
    533                        }
    534                      }
    535                    }
    536                  } else { // Not the cluster we are looking for
    537                    attributeOffsetIndex += cluster->clusterSize;
    538                  }
    539                }
    540              } else { // Not the endpoint we are looking for
    541                attributeOffsetIndex += emAfEndpoints[i].endpointType->endpointSize;
   \                     ??emAfReadOrWriteAttribute_1:
   \   00000012   0x88C0             LDRH     R0,[R0, #+6]
   \   00000014   0x1945             ADDS     R5,R0,R5
   \   00000016   0xB2AD             UXTH     R5,R5
    542              }
   \                     ??emAfReadOrWriteAttribute_2:
   \   00000018   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??emAfReadOrWriteAttribute_0:
   \   0000001C   0xF89B 0x0010      LDRB     R0,[R11, #+16]
   \   00000020   0xFA5F 0xFA8A      UXTB     R10,R10
   \   00000024   0x4582             CMP      R10,R0
   \   00000026   0xF080 0x80B1      BCS.W    ??emAfReadOrWriteAttribute_3
   \   0000002A   0xEA4F 0x110A      LSL      R1,R10,#+4
   \   0000002E   0xEB01 0x000B      ADD      R0,R1,R11
   \   00000032   0xF811 0x100B      LDRB     R1,[R1, R11]
   \   00000036   0x7822             LDRB     R2,[R4, #+0]
   \   00000038   0x4291             CMP      R1,R2
   \   0000003A   0x6880             LDR      R0,[R0, #+8]
   \   0000003C   0xD1E9             BNE.N    ??emAfReadOrWriteAttribute_1
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x4650             MOV      R0,R10
   \   00000042   0x.... 0x....      BL       emberAfEndpointIndexIsEnabled
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD0E6             BEQ.N    ??emAfReadOrWriteAttribute_2
   \   0000004A   0x2700             MOVS     R7,#+0
   \   0000004C   0xE004             B.N      ??emAfReadOrWriteAttribute_4
   \                     ??emAfReadOrWriteAttribute_5:
   \   0000004E   0xF8B8 0x000A      LDRH     R0,[R8, #+10]
   \   00000052   0x1945             ADDS     R5,R0,R5
   \   00000054   0xB2AD             UXTH     R5,R5
   \                     ??emAfReadOrWriteAttribute_6:
   \   00000056   0x1C7F             ADDS     R7,R7,#+1
   \                     ??emAfReadOrWriteAttribute_4:
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x7900             LDRB     R0,[R0, #+4]
   \   0000005C   0xB2FF             UXTB     R7,R7
   \   0000005E   0x4287             CMP      R7,R0
   \   00000060   0xD2DA             BCS.N    ??emAfReadOrWriteAttribute_2
   \   00000062   0x2014             MOVS     R0,#+20
   \   00000064   0x9900             LDR      R1,[SP, #+0]
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0xFB00 0x1807      MLA      R8,R0,R7,R1
   \   0000006C   0x4621             MOV      R1,R4
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x.... 0x....      BL       emAfMatchCluster
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD0EA             BEQ.N    ??emAfReadOrWriteAttribute_5
   \   00000078   0xF04F 0x0900      MOV      R9,#+0
   \   0000007C   0xE008             B.N      ??emAfReadOrWriteAttribute_7
   \                     ??emAfReadOrWriteAttribute_8:
   \   0000007E   0x7930             LDRB     R0,[R6, #+4]
   \   00000080   0x2130             MOVS     R1,#+48
   \   00000082   0x4208             TST      R0,R1
   \   00000084   0xD102             BNE.N    ??emAfReadOrWriteAttribute_9
   \   00000086   0x78F0             LDRB     R0,[R6, #+3]
   \   00000088   0x1945             ADDS     R5,R0,R5
   \   0000008A   0xB2AD             UXTH     R5,R5
   \                     ??emAfReadOrWriteAttribute_9:
   \   0000008C   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??emAfReadOrWriteAttribute_7:
   \   00000090   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \   00000094   0xFA1F 0xF989      UXTH     R9,R9
   \   00000098   0x4581             CMP      R9,R0
   \   0000009A   0xD2DC             BCS.N    ??emAfReadOrWriteAttribute_6
   \   0000009C   0x200C             MOVS     R0,#+12
   \   0000009E   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \   000000A2   0xFB00 0x1609      MLA      R6,R0,R9,R1
   \   000000A6   0x4622             MOV      R2,R4
   \   000000A8   0x4631             MOV      R1,R6
   \   000000AA   0x4640             MOV      R0,R8
   \   000000AC   0x.... 0x....      BL       emAfMatchAttribute
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD0E4             BEQ.N    ??emAfReadOrWriteAttribute_8
   \   000000B4   0x9802             LDR      R0,[SP, #+8]
   \   000000B6   0xB100             CBZ.N    R0,??emAfReadOrWriteAttribute_10
   \   000000B8   0x6006             STR      R6,[R0, #+0]
   \                     ??emAfReadOrWriteAttribute_10:
   \   000000BA   0x7930             LDRB     R0,[R6, #+4]
   \   000000BC   0x0681             LSLS     R1,R0,#+26
   \   000000BE   0xD511             BPL.N    ??emAfReadOrWriteAttribute_11
   \   000000C0   0x.... 0x....      ADR.W    R1,generatedAttributes
   \   000000C4   0x2200             MOVS     R2,#+0
   \   000000C6   0xE006             B.N      ??emAfReadOrWriteAttribute_12
   \                     ??emAfReadOrWriteAttribute_13:
   \   000000C8   0x790B             LDRB     R3,[R1, #+4]
   \   000000CA   0x069B             LSLS     R3,R3,#+26
   \   000000CC   0xD502             BPL.N    ??emAfReadOrWriteAttribute_14
   \   000000CE   0x78CB             LDRB     R3,[R1, #+3]
   \   000000D0   0x189A             ADDS     R2,R3,R2
   \   000000D2   0xB292             UXTH     R2,R2
   \                     ??emAfReadOrWriteAttribute_14:
   \   000000D4   0x310C             ADDS     R1,R1,#+12
   \                     ??emAfReadOrWriteAttribute_12:
   \   000000D6   0x42B1             CMP      R1,R6
   \   000000D8   0xD3F6             BCC.N    ??emAfReadOrWriteAttribute_13
   \   000000DA   0xEB02 0x010B      ADD      R1,R2,R11
   \   000000DE   0xF201 0x0A12      ADDW     R10,R1,#+18
   \   000000E2   0xE003             B.N      ??emAfReadOrWriteAttribute_15
   \                     ??emAfReadOrWriteAttribute_11:
   \   000000E4   0xEB05 0x010B      ADD      R1,R5,R11
   \   000000E8   0xF101 0x0A14      ADD      R10,R1,#+20
   \                     ??emAfReadOrWriteAttribute_15:
   \   000000EC   0x9D0E             LDR      R5,[SP, #+56]
   \   000000EE   0xB11D             CBZ.N    R5,??emAfReadOrWriteAttribute_16
   \   000000F0   0x9F03             LDR      R7,[SP, #+12]
   \   000000F2   0x.... 0x....      LDR.W    R9,??DataTable30_1
   \   000000F6   0xE006             B.N      ??emAfReadOrWriteAttribute_17
   \                     ??emAfReadOrWriteAttribute_16:
   \   000000F8   0x9903             LDR      R1,[SP, #+12]
   \   000000FA   0x2900             CMP      R1,#+0
   \   000000FC   0xD044             BEQ.N    ??emAfReadOrWriteAttribute_18
   \   000000FE   0x4657             MOV      R7,R10
   \   00000100   0x468A             MOV      R10,R1
   \   00000102   0x.... 0x....      LDR.W    R9,??DataTable30_2
   \                     ??emAfReadOrWriteAttribute_17:
   \   00000106   0x06C0             LSLS     R0,R0,#+27
   \   00000108   0xD50B             BPL.N    ??emAfReadOrWriteAttribute_19
   \   0000010A   0x4631             MOV      R1,R6
   \   0000010C   0x4640             MOV      R0,R8
   \   0000010E   0x.... 0x....      BL       emAfGetManufacturerCodeForAttribute
   \   00000112   0x4603             MOV      R3,R0
   \   00000114   0x9803             LDR      R0,[SP, #+12]
   \   00000116   0x9000             STR      R0,[SP, #+0]
   \   00000118   0x4632             MOV      R2,R6
   \   0000011A   0x8861             LDRH     R1,[R4, #+2]
   \   0000011C   0x7820             LDRB     R0,[R4, #+0]
   \   0000011E   0x47C8             BLX      R9
   \   00000120   0xE035             B.N      ??emAfReadOrWriteAttribute_20
   \                     ??emAfReadOrWriteAttribute_19:
   \   00000122   0xF896 0x8002      LDRB     R8,[R6, #+2]
   \   00000126   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xBF0C             ITE      EQ 
   \   0000012E   0x78F4             LDRBEQ   R4,[R6, #+3]
   \   00000130   0x4604             MOVNE    R4,R0
   \   00000132   0x4640             MOV      R0,R8
   \   00000134   0x.... 0x....      BL       emberAfIsStringAttributeType
   \   00000138   0xB130             CBZ.N    R0,??emAfReadOrWriteAttribute_21
   \   0000013A   0x1E62             SUBS     R2,R4,#+1
   \   0000013C   0xB2D2             UXTB     R2,R2
   \   0000013E   0x4639             MOV      R1,R7
   \   00000140   0x4650             MOV      R0,R10
   \   00000142   0x.... 0x....      BL       emberAfCopyString
   \   00000146   0xE01F             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_21:
   \   00000148   0x4640             MOV      R0,R8
   \   0000014A   0x.... 0x....      BL       emberAfIsLongStringAttributeType
   \   0000014E   0xB130             CBZ.N    R0,??emAfReadOrWriteAttribute_22
   \   00000150   0x1EA2             SUBS     R2,R4,#+2
   \   00000152   0xB292             UXTH     R2,R2
   \   00000154   0x4639             MOV      R1,R7
   \   00000156   0x4650             MOV      R0,R10
   \   00000158   0x.... 0x....      BL       emberAfCopyLongString
   \   0000015C   0xE014             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_22:
   \   0000015E   0xB93D             CBNZ.N   R5,??emAfReadOrWriteAttribute_23
   \   00000160   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   00000164   0xB120             CBZ.N    R0,??emAfReadOrWriteAttribute_23
   \   00000166   0x78F1             LDRB     R1,[R6, #+3]
   \   00000168   0x4288             CMP      R0,R1
   \   0000016A   0xBF38             IT       CC 
   \   0000016C   0x2089             MOVCC    R0,#+137
   \   0000016E   0xD30E             BCC.N    ??emAfReadOrWriteAttribute_20
   \                     ??emAfReadOrWriteAttribute_23:
   \   00000170   0x2F00             CMP      R7,#+0
   \   00000172   0x4622             MOV      R2,R4
   \   00000174   0xD104             BNE.N    ??emAfReadOrWriteAttribute_24
   \   00000176   0x2100             MOVS     R1,#+0
   \   00000178   0x4650             MOV      R0,R10
   \   0000017A   0x.... 0x....      BL       halCommonMemSet
   \   0000017E   0xE003             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_24:
   \   00000180   0x4639             MOV      R1,R7
   \   00000182   0x4650             MOV      R0,R10
   \   00000184   0x.... 0x....      BL       halCommonMemCopy
   \                     ??emAfReadOrWriteAttribute_18:
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0xE000             B.N      ??emAfReadOrWriteAttribute_20
    543            }
    544            return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE; // Sorry, attribute was not found.
   \                     ??emAfReadOrWriteAttribute_3:
   \   0000018C   0x2086             MOVS     R0,#+134
   \                     ??emAfReadOrWriteAttribute_20:
   \   0000018E   0x....             B.N      ?Subroutine1
    545          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xB005             ADD      SP,SP,#+20
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    546          
    547          // mask = 0 -> find either client or server
    548          // mask = CLUSTER_MASK_CLIENT -> find client
    549          // mask = CLUSTER_MASK_SERVER -> find server

   \                                 In section .text, align 2, keep-with-next
    550          static EmberAfCluster *emberAfFindClusterInType(EmberAfEndpointType *endpointType,
    551                                                          EmberAfClusterId clusterId,
    552                                                          int8u mask)
    553          {
   \                     emberAfFindClusterInType:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    554            int8u i;
    555            for (i = 0; i < endpointType->clusterCount; i++) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE003             B.N      ??emberAfFindClusterInType_0
    556              EmberAfCluster *cluster = &(endpointType->cluster[i]);
    557              if (cluster->clusterId == clusterId
    558                  && (mask == 0
    559                      || (mask == CLUSTER_MASK_CLIENT && emberAfClusterIsClient(cluster))
    560                      || (mask == CLUSTER_MASK_SERVER && emberAfClusterIsServer(cluster)))) {
   \                     ??emberAfFindClusterInType_1:
   \   00000006   0x7B1D             LDRB     R5,[R3, #+12]
   \   00000008   0x062D             LSLS     R5,R5,#+24
   \   0000000A   0xD413             BMI.N    ??emberAfFindClusterInType_2
   \                     ??emberAfFindClusterInType_3:
   \   0000000C   0x1C64             ADDS     R4,R4,#+1
   \                     ??emberAfFindClusterInType_0:
   \   0000000E   0x7903             LDRB     R3,[R0, #+4]
   \   00000010   0xB2E4             UXTB     R4,R4
   \   00000012   0x429C             CMP      R4,R3
   \   00000014   0xD210             BCS.N    ??emberAfFindClusterInType_4
   \   00000016   0x2314             MOVS     R3,#+20
   \   00000018   0x6805             LDR      R5,[R0, #+0]
   \   0000001A   0xFB03 0x5304      MLA      R3,R3,R4,R5
   \   0000001E   0x881D             LDRH     R5,[R3, #+0]
   \   00000020   0x428D             CMP      R5,R1
   \   00000022   0xD1F3             BNE.N    ??emberAfFindClusterInType_3
   \   00000024   0xB132             CBZ.N    R2,??emberAfFindClusterInType_2
   \   00000026   0x2A80             CMP      R2,#+128
   \   00000028   0xD0ED             BEQ.N    ??emberAfFindClusterInType_1
   \   0000002A   0x2A40             CMP      R2,#+64
   \   0000002C   0xD1EE             BNE.N    ??emberAfFindClusterInType_3
   \   0000002E   0x7B1D             LDRB     R5,[R3, #+12]
   \   00000030   0x066D             LSLS     R5,R5,#+25
   \   00000032   0xD5EB             BPL.N    ??emberAfFindClusterInType_3
    561                return cluster;
   \                     ??emberAfFindClusterInType_2:
   \   00000034   0x4618             MOV      R0,R3
   \   00000036   0xBD30             POP      {R4,R5,PC}
    562              }
    563            }
    564            return NULL;
   \                     ??emberAfFindClusterInType_4:
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return
    565          }
    566          

   \                                 In section .text, align 2, keep-with-next
    567          int8u emberAfClusterIndex(int8u endpoint,
    568                                    EmberAfClusterId clusterId,
    569                                    int8u mask)
    570          {
   \                     emberAfClusterIndex:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4692             MOV      R10,R2
    571            int8u ep;
    572            int8u index = 0xFF;
   \   0000000A   0x27FF             MOVS     R7,#+255
    573            for ( ep=0; ep < emberAfEndpointCount(); ep++ ) {
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x....             LDR.N    R4,??DataTable30
   \   00000010   0xE000             B.N      ??emberAfClusterIndex_0
   \                     ??emberAfClusterIndex_1:
   \   00000012   0x1C6D             ADDS     R5,R5,#+1
   \                     ??emberAfClusterIndex_0:
   \   00000014   0x7C20             LDRB     R0,[R4, #+16]
   \   00000016   0xB2ED             UXTB     R5,R5
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD20E             BCS.N    ??emberAfClusterIndex_2
    574              EmberAfEndpointType *endpointType = emAfEndpoints[ep].endpointType;
    575              if ( emberAfFindClusterInType(endpointType, clusterId, mask) != NULL ) {
   \   0000001C   0x012E             LSLS     R6,R5,#+4
   \   0000001E   0x4652             MOV      R2,R10
   \   00000020   0x4649             MOV      R1,R9
   \   00000022   0x1930             ADDS     R0,R6,R4
   \   00000024   0x6880             LDR      R0,[R0, #+8]
   \   00000026   0x.... 0x....      BL       emberAfFindClusterInType
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD0F1             BEQ.N    ??emberAfClusterIndex_1
    576                index++;
   \   0000002E   0x1C7F             ADDS     R7,R7,#+1
    577                if ( emAfEndpoints[ep].endpoint == endpoint )
   \   00000030   0x5D30             LDRB     R0,[R6, R4]
   \   00000032   0x4540             CMP      R0,R8
   \   00000034   0xD1ED             BNE.N    ??emberAfClusterIndex_1
    578                  return index;
   \   00000036   0xB2F8             UXTB     R0,R7
   \   00000038   0xE000             B.N      ??emberAfClusterIndex_3
    579              }
    580            }
    581            return 0xFF;
   \                     ??emberAfClusterIndex_2:
   \   0000003A   0x20FF             MOVS     R0,#+255
   \                     ??emberAfClusterIndex_3:
   \   0000003C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    582          }
    583          
    584          // Returns TRUE If endpoint contains passed cluster

   \                                 In section .text, align 2, keep-with-next
    585          boolean emberAfContainsCluster(int8u endpoint, EmberAfClusterId clusterId) {
   \                     emberAfContainsCluster:
   \   00000000   0xB580             PUSH     {R7,LR}
    586            return ( emberAfFindCluster(endpoint, clusterId, 0) != NULL );
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x....             B.N      ?Subroutine2
    587          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x.... 0x....      BL       emberAfFindCluster
   \   00000004   0xB100             CBZ.N    R0,??Subroutine2_0
   \   00000006   0x2001             MOVS     R0,#+1
   \                     ??Subroutine2_0:
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    588          

   \                                 In section .text, align 2, keep-with-next
    589          boolean emberAfContainsServer(int8u endpoint, EmberAfClusterId clusterId) {
   \                     emberAfContainsServer:
   \   00000000   0xB580             PUSH     {R7,LR}
    590            return ( emberAfFindCluster(endpoint, clusterId, CLUSTER_MASK_SERVER) != NULL );
   \   00000002   0x2240             MOVS     R2,#+64
   \   00000004                      REQUIRE ?Subroutine2
   \   00000004                      ;; // Fall through to label ?Subroutine2
    591          }
    592          

   \                                 In section .text, align 2, keep-with-next
    593          boolean emberAfContainsClient(int8u endpoint, EmberAfClusterId clusterId) {
   \                     emberAfContainsClient:
   \   00000000   0xB580             PUSH     {R7,LR}
    594            return ( emberAfFindCluster(endpoint, clusterId, CLUSTER_MASK_CLIENT) != NULL );
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x....             B.N      ?Subroutine2
    595          }
    596          

   \                                 In section .text, align 2, keep-with-next
    597          EmberAfCluster *emberAfFindCluster(int8u endpoint,
    598                                             EmberAfClusterId clusterId,
    599                                             int8u mask) {
   \                     emberAfFindCluster:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    600            int8u ep = emberAfIndexFromEndpoint(endpoint);
   \   00000006   0x.... 0x....      BL       emberAfIndexFromEndpoint
    601            if ( ep == 0xFF )
   \   0000000A   0x28FF             CMP      R0,#+255
   \   0000000C   0xD101             BNE.N    ??emberAfFindCluster_0
    602              return NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
    603            else
    604              return emberAfFindClusterInType(emAfEndpoints[ep].endpointType, clusterId, mask);
   \                     ??emberAfFindCluster_0:
   \   00000012   0x462A             MOV      R2,R5
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x....             LDR.N    R3,??DataTable30
   \   00000018   0xEB03 0x1000      ADD      R0,R3,R0, LSL #+4
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000022   0x....             B.N      emberAfFindClusterInType
    605          }
    606          
    607          // Server wrapper for findClusterEndpointIndex

   \                                 In section .text, align 2, keep-with-next
    608          int8u emberAfFindClusterServerEndpointIndex(int8u endpoint, EmberAfClusterId clusterId)
    609          {
    610            return findClusterEndpointIndex(endpoint, clusterId, CLUSTER_MASK_SERVER);
   \                     emberAfFindClusterServerEndpointIndex:
   \   00000000   0x2240             MOVS     R2,#+64
   \   00000002   0x....             B.N      findClusterEndpointIndex
    611          }
    612          
    613          // Client wrapper for findClusterEndpointIndex

   \                                 In section .text, align 2, keep-with-next
    614          int8u emberAfFindClusterClientEndpointIndex(int8u endpoint, EmberAfClusterId clusterId)
    615          {
    616            return findClusterEndpointIndex(endpoint, clusterId, CLUSTER_MASK_CLIENT);
   \                     emberAfFindClusterClientEndpointIndex:
   \   00000000   0x2280             MOVS     R2,#+128
   \   00000002                      REQUIRE findClusterEndpointIndex
   \   00000002                      ;; // Fall through to label findClusterEndpointIndex
    617          }
    618          
    619          // Returns the endpoint index within a given cluster

   \                                 In section .text, align 2, keep-with-next
    620          static int8u findClusterEndpointIndex(int8u endpoint, EmberAfClusterId clusterId, int8u mask)
    621          {
   \                     findClusterEndpointIndex:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4691             MOV      R9,R2
    622            int8u i, epi = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
    623          
    624            if (emberAfFindCluster(endpoint, clusterId, mask) == NULL) {
   \   0000000C   0x.... 0x....      BL       emberAfFindCluster
   \   00000010   0xB908             CBNZ.N   R0,??findClusterEndpointIndex_0
    625              return 0xFF;
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0xE016             B.N      ??findClusterEndpointIndex_1
    626            }
    627          
    628            for (i = 0; i < emberAfEndpointCount(); i++) {
   \                     ??findClusterEndpointIndex_0:
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0x....             LDR.N    R7,??DataTable30
   \   0000001A   0xE002             B.N      ??findClusterEndpointIndex_2
    629              if (emAfEndpoints[i].endpoint == endpoint) {
    630                break;
    631              }
    632              epi += (emberAfFindCluster(emAfEndpoints[i].endpoint, clusterId, mask) != NULL) ? 1 : 0;
   \                     ??findClusterEndpointIndex_3:
   \   0000001C   0x1940             ADDS     R0,R0,R5
   \   0000001E   0xB2C5             UXTB     R5,R0
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \                     ??findClusterEndpointIndex_2:
   \   00000022   0x7C38             LDRB     R0,[R7, #+16]
   \   00000024   0xB2F6             UXTB     R6,R6
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xD20B             BCS.N    ??findClusterEndpointIndex_4
   \   0000002A   0x0130             LSLS     R0,R6,#+4
   \   0000002C   0x5DC0             LDRB     R0,[R0, R7]
   \   0000002E   0x42A0             CMP      R0,R4
   \   00000030   0xD007             BEQ.N    ??findClusterEndpointIndex_4
   \   00000032   0x464A             MOV      R2,R9
   \   00000034   0x4641             MOV      R1,R8
   \   00000036   0x.... 0x....      BL       emberAfFindCluster
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0EE             BEQ.N    ??findClusterEndpointIndex_3
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE7EC             B.N      ??findClusterEndpointIndex_3
    633            }
    634          
    635            return epi;
   \                     ??findClusterEndpointIndex_4:
   \   00000042   0x4628             MOV      R0,R5
   \                     ??findClusterEndpointIndex_1:
   \   00000044   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    636          }
    637          

   \                                 In section .text, align 2, keep-with-next
    638          static int8u findIndexFromEndpoint(int8u endpoint, boolean ignoreDisabledEndpoints)
    639          {
   \                     findIndexFromEndpoint:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    640            int8u epi;
    641            for (epi = 0; epi < emberAfEndpointCount(); epi++) {
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x....             LDR.N    R3,??DataTable30
   \   00000006   0xE000             B.N      ??findIndexFromEndpoint_0
   \                     ??findIndexFromEndpoint_1:
   \   00000008   0x1C52             ADDS     R2,R2,#+1
   \                     ??findIndexFromEndpoint_0:
   \   0000000A   0x7C1C             LDRB     R4,[R3, #+16]
   \   0000000C   0xB2D2             UXTB     R2,R2
   \   0000000E   0x42A2             CMP      R2,R4
   \   00000010   0xD20A             BCS.N    ??findIndexFromEndpoint_2
    642              if (emAfEndpoints[epi].endpoint == endpoint
    643                  && (!ignoreDisabledEndpoints
    644                      || emAfEndpoints[epi].bitmask & EMBER_AF_ENDPOINT_ENABLED)) {
   \   00000012   0x0114             LSLS     R4,R2,#+4
   \   00000014   0x5CE5             LDRB     R5,[R4, R3]
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xD1F6             BNE.N    ??findIndexFromEndpoint_1
   \   0000001A   0xB119             CBZ.N    R1,??findIndexFromEndpoint_3
   \   0000001C   0x18E4             ADDS     R4,R4,R3
   \   0000001E   0x7B64             LDRB     R4,[R4, #+13]
   \   00000020   0x07E4             LSLS     R4,R4,#+31
   \   00000022   0xD5F1             BPL.N    ??findIndexFromEndpoint_1
    645                return epi;
   \                     ??findIndexFromEndpoint_3:
   \   00000024   0x4610             MOV      R0,R2
   \   00000026   0xBD30             POP      {R4,R5,PC}
    646              }
    647            }
    648            return 0xFF;
   \                     ??findIndexFromEndpoint_2:
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
    649          }
    650          

   \                                 In section .text, align 2, keep-with-next
    651          boolean emberAfEndpointIsEnabled(int8u endpoint)
    652          {
   \                     emberAfEndpointIsEnabled:
   \   00000000   0xB580             PUSH     {R7,LR}
    653            int8u index = findIndexFromEndpoint(endpoint,
    654                                                FALSE);    // ignore disabled endpoints?
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       findIndexFromEndpoint
    655          
    656            EMBER_TEST_ASSERT(0xFF != index);
    657          
    658            if (0xFF == index) {
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0xE8BD 0x4002      POPNE    {R1,LR}
   \   00000010   0x.... 0x....      BNE.W    emberAfEndpointIndexIsEnabled
    659              return FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}
    660            }
    661          
    662            return emberAfEndpointIndexIsEnabled(index);
    663          }
    664          

   \                                 In section .text, align 2, keep-with-next
    665          boolean emberAfEndpointEnableDisable(int8u endpoint, boolean enable)
    666          {
   \                     emberAfEndpointEnableDisable:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    667            int8u index = findIndexFromEndpoint(endpoint,
    668                                                FALSE);    // ignore disabled endpoints?
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       findIndexFromEndpoint
    669            boolean currentlyEnabled;
    670          
    671            if (0xFF == index) {
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD101             BNE.N    ??emberAfEndpointEnableDisable_0
    672              return FALSE;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBD70             POP      {R4-R6,PC}
    673            }
    674          
    675            currentlyEnabled = emAfEndpoints[index].bitmask & EMBER_AF_ENDPOINT_ENABLED;
   \                     ??emberAfEndpointEnableDisable_0:
   \   00000014   0x....             LDR.N    R1,??DataTable30
   \   00000016   0xEB01 0x1500      ADD      R5,R1,R0, LSL #+4
   \   0000001A   0x7B68             LDRB     R0,[R5, #+13]
   \   0000001C   0xF000 0x0101      AND      R1,R0,#0x1
    676          
    677            if (enable) {
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xBF14             ITE      NE 
   \   00000024   0xF040 0x0001      ORRNE    R0,R0,#0x1
   \   00000028   0x2000             MOVEQ    R0,#+0
    678              emAfEndpoints[index].bitmask |= EMBER_AF_ENDPOINT_ENABLED;
    679            } else {
    680              emAfEndpoints[index].bitmask &= EMBER_AF_ENDPOINT_DISABLED;
   \   0000002A   0x7368             STRB     R0,[R5, #+13]
    681            }
    682          
    683          #if defined(EZSP_HOST)
    684            ezspSetEndpointFlags(endpoint,
    685                                 (enable
    686                                  ? EZSP_ENDPOINT_ENABLED
    687                                  : EZSP_ENDPOINT_DISABLED));
    688          #endif
    689          
    690            if (currentlyEnabled ^ enable) {
   \   0000002C   0xEA96 0x0F01      TEQ      R6,R1
   \   00000030   0xD014             BEQ.N    ??emberAfEndpointEnableDisable_1
    691              if (enable) {
   \   00000032   0xB176             CBZ.N    R6,??emberAfEndpointEnableDisable_2
    692                initializeEndpoint(&(emAfEndpoints[index]));
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       initializeEndpoint
   \   0000003A   0xE00F             B.N      ??emberAfEndpointEnableDisable_1
    693              } else {
    694                int8u i;
    695                for (i = 0; i < emAfEndpoints[index].endpointType->clusterCount; i++) {
    696                  EmberAfCluster* cluster = &((emAfEndpoints[index].endpointType->cluster)[i]);
   \                     ??emberAfEndpointEnableDisable_3:
   \   0000003C   0x2114             MOVS     R1,#+20
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xFB01 0x0006      MLA      R0,R1,R6,R0
    697          //        emberAfCorePrintln("Disabling cluster tick for ep:%d, cluster:0x%2X, %p",
    698          //                           endpoint,
    699          //                           cluster->clusterId,
    700          //                           ((cluster->mask & CLUSTER_MASK_CLIENT)
    701          //                            ? "client"
    702          //                            : "server"));
    703          //        emberAfCoreFlush();
    704                  emberAfDeactivateClusterTick(endpoint,
    705                                               cluster->clusterId,
    706                                               (cluster->mask & CLUSTER_MASK_CLIENT
    707                                                ? EMBER_AF_CLIENT_CLUSTER_TICK
    708                                                : EMBER_AF_SERVER_CLUSTER_TICK));
   \   00000044   0x7B01             LDRB     R1,[R0, #+12]
   \   00000046   0x09CA             LSRS     R2,R1,#+7
   \   00000048   0x8801             LDRH     R1,[R0, #+0]
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       emberAfDeactivateClusterTick
    709                }
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \                     ??emberAfEndpointEnableDisable_2:
   \   00000052   0x68A8             LDR      R0,[R5, #+8]
   \   00000054   0x7901             LDRB     R1,[R0, #+4]
   \   00000056   0xB2F6             UXTB     R6,R6
   \   00000058   0x428E             CMP      R6,R1
   \   0000005A   0xD3EF             BCC.N    ??emberAfEndpointEnableDisable_3
    710              }
    711            }
    712          
    713            return TRUE;
   \                     ??emberAfEndpointEnableDisable_1:
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
    714          }
    715          
    716          // Returns the index of a given endpoint.  Does not consider disabled endpoints.

   \                                 In section .text, align 2, keep-with-next
    717          int8u emberAfIndexFromEndpoint(int8u endpoint)
    718          {
    719            return findIndexFromEndpoint(endpoint,
    720                                         TRUE);    // ignore disabled endpoints?
   \                     emberAfIndexFromEndpoint:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             B.N      findIndexFromEndpoint
    721          }
    722          

   \                                 In section .text, align 2, keep-with-next
    723          int8u emberAfEndpointFromIndex(int8u index)
    724          {
    725            return emAfEndpoints[index].endpoint;
   \                     emberAfEndpointFromIndex:
   \   00000000   0x0100             LSLS     R0,R0,#+4
   \   00000002   0x....             LDR.N    R1,??DataTable30
   \   00000004   0x5C40             LDRB     R0,[R0, R1]
   \   00000006   0x4770             BX       LR               ;; return
    726          }
    727          
    728          // If server == true, returns the number of server clusters,
    729          // otherwise number of client clusters on this endpoint

   \                                 In section .text, align 2, keep-with-next
    730          int8u emberAfClusterCount(int8u endpoint, boolean server)
    731          {
   \                     emberAfClusterCount:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    732            int8u index = emberAfIndexFromEndpoint(endpoint);
   \   00000004   0x.... 0x....      BL       emberAfIndexFromEndpoint
   \   00000008   0x4601             MOV      R1,R0
    733            int8u i, c=0;
   \   0000000A   0x2000             MOVS     R0,#+0
    734            EmberAfDefinedEndpoint *de;
    735            EmberAfCluster *cluster;
    736          
    737            if ( index == 0xFF ) {
   \   0000000C   0x29FF             CMP      R1,#+255
   \   0000000E   0xBF1F             ITTTT    NE 
   \   00000010   0x....             LDRNE.N  R2,??DataTable30
   \   00000012   0xEB02 0x1101      ADDNE    R1,R2,R1, LSL #+4
   \   00000016   0x6889             LDRNE    R1,[R1, #+8]
   \   00000018   0x2900             CMPNE    R1,#+0
    738              return 0;
    739            }
    740            de = &(emAfEndpoints[index]);
    741            if ( de->endpointType == NULL) {
   \   0000001A   0xD014             BEQ.N    ??emberAfClusterCount_0
    742              return 0;
    743            }
    744            for ( i=0; i<de->endpointType->clusterCount; i++ ) {
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xE003             B.N      ??emberAfClusterCount_1
    745              cluster = &(de->endpointType->cluster[i]);
    746              if ( server && emberAfClusterIsServer(cluster) )
   \                     ??emberAfClusterCount_2:
   \   00000020   0x061B             LSLS     R3,R3,#+24
   \                     ??emberAfClusterCount_3:
   \   00000022   0xBF48             IT       MI 
   \   00000024   0x4628             MOVMI    R0,R5
    747                c++;
    748              if ( (!server) && emberAfClusterIsClient(cluster) )
    749                c++;
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \                     ??emberAfClusterCount_1:
   \   00000028   0x790B             LDRB     R3,[R1, #+4]
   \   0000002A   0xB2D2             UXTB     R2,R2
   \   0000002C   0x429A             CMP      R2,R3
   \   0000002E   0xD209             BCS.N    ??emberAfClusterCount_4
   \   00000030   0x2314             MOVS     R3,#+20
   \   00000032   0x680D             LDR      R5,[R1, #+0]
   \   00000034   0xFB03 0x5302      MLA      R3,R3,R2,R5
   \   00000038   0x7B1B             LDRB     R3,[R3, #+12]
   \   0000003A   0x1C45             ADDS     R5,R0,#+1
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD0EF             BEQ.N    ??emberAfClusterCount_2
   \   00000040   0x065B             LSLS     R3,R3,#+25
   \   00000042   0xE7EE             B.N      ??emberAfClusterCount_3
    750            }
    751            return c;
   \                     ??emberAfClusterCount_4:
   \   00000044   0xB2C0             UXTB     R0,R0
   \                     ??emberAfClusterCount_0:
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    752          }
    753          
    754          // Returns the clusterId of Nth server or client cluster,
    755          // depending on server toggle.

   \                                 In section .text, align 2, keep-with-next
    756          EmberAfCluster *emberAfGetNthCluster(int8u endpoint, int8u n, boolean server)
    757          {
   \                     emberAfGetNthCluster:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    758            int8u index = emberAfIndexFromEndpoint(endpoint);
   \   00000006   0x.... 0x....      BL       emberAfIndexFromEndpoint
    759            EmberAfDefinedEndpoint *de;
    760            int8u i,c=0;
   \   0000000A   0x2100             MOVS     R1,#+0
    761            EmberAfCluster *cluster;
    762          
    763            if ( index == 0xFF ) return NULL;
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD01A             BEQ.N    ??emberAfGetNthCluster_0
    764            de = &(emAfEndpoints[index]);
   \   00000010   0x....             LDR.N    R2,??DataTable30
   \   00000012   0xEB02 0x1200      ADD      R2,R2,R0, LSL #+4
    765          
    766            for ( i = 0; i < de->endpointType->clusterCount; i++ ) {
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0xE001             B.N      ??emberAfGetNthCluster_1
    767              cluster = &(de->endpointType->cluster[i]);
    768          
    769              if ( ( server && emberAfClusterIsServer(cluster) )
    770                   || ( (!server) &&  emberAfClusterIsClient(cluster) ) ) {
    771                if ( c == n ) return cluster;
    772                c++;
   \                     ??emberAfGetNthCluster_2:
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \                     ??emberAfGetNthCluster_3:
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??emberAfGetNthCluster_1:
   \   0000001E   0x6890             LDR      R0,[R2, #+8]
   \   00000020   0x7906             LDRB     R6,[R0, #+4]
   \   00000022   0xB2DB             UXTB     R3,R3
   \   00000024   0x42B3             CMP      R3,R6
   \   00000026   0xD20E             BCS.N    ??emberAfGetNthCluster_0
   \   00000028   0x2614             MOVS     R6,#+20
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xFB06 0x0003      MLA      R0,R6,R3,R0
   \   00000030   0x7B06             LDRB     R6,[R0, #+12]
   \   00000032   0xB115             CBZ.N    R5,??emberAfGetNthCluster_4
   \   00000034   0x0676             LSLS     R6,R6,#+25
   \   00000036   0xD402             BMI.N    ??emberAfGetNthCluster_5
   \   00000038   0xE7F0             B.N      ??emberAfGetNthCluster_3
   \                     ??emberAfGetNthCluster_4:
   \   0000003A   0x0636             LSLS     R6,R6,#+24
   \   0000003C   0xD5EE             BPL.N    ??emberAfGetNthCluster_3
   \                     ??emberAfGetNthCluster_5:
   \   0000003E   0xB2C9             UXTB     R1,R1
   \   00000040   0x42A1             CMP      R1,R4
   \   00000042   0xD1EA             BNE.N    ??emberAfGetNthCluster_2
   \   00000044   0xBD70             POP      {R4-R6,PC}
    773              }
    774          
    775            }
    776            return NULL;
   \                     ??emberAfGetNthCluster_0:
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    777          }
    778          
    779          // Returns number of clusters put into the passed cluster list
    780          // for the given endpoint and client/server polarity

   \                                 In section .text, align 2, keep-with-next
    781          int8u emberAfGetClustersFromEndpoint(int8u endpoint, int16u *clusterList, int8u listLen, boolean server) {
   \                     emberAfGetClustersFromEndpoint:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    782            int8u clusterCount = emberAfClusterCount(endpoint, server);
   \   0000000C   0x4639             MOV      R1,R7
   \   0000000E   0x.... 0x....      BL       emberAfClusterCount
   \   00000012   0x4680             MOV      R8,R0
    783            int8u i;
    784            EmberAfCluster *cluster;
    785            if (clusterCount > listLen) {
   \   00000014   0x4546             CMP      R6,R8
   \   00000016   0xBFB8             IT       LT 
   \   00000018   0x46B0             MOVLT    R8,R6
    786              clusterCount = listLen;
    787            }
    788            for (i = 0; i < clusterCount; i++) {
   \   0000001A   0x2600             MOVS     R6,#+0
   \   0000001C   0xE002             B.N      ??emberAfGetClustersFromEndpoint_0
    789              cluster = emberAfGetNthCluster(endpoint, i, server);
    790              clusterList[i] = (cluster == NULL ? 0xFFFF : cluster->clusterId);
   \                     ??emberAfGetClustersFromEndpoint_1:
   \   0000001E   0xF825 0x0019      STRH     R0,[R5, R9, LSL #+1]
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??emberAfGetClustersFromEndpoint_0:
   \   00000024   0xB2F6             UXTB     R6,R6
   \   00000026   0x46B1             MOV      R9,R6
   \   00000028   0x45C1             CMP      R9,R8
   \   0000002A   0xDA0A             BGE.N    ??emberAfGetClustersFromEndpoint_2
   \   0000002C   0x463A             MOV      R2,R7
   \   0000002E   0x4631             MOV      R1,R6
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       emberAfGetNthCluster
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xBF0C             ITE      EQ 
   \   0000003A   0xF64F 0x70FF      MOVWEQ   R0,#+65535
   \   0000003E   0x8800             LDRHNE   R0,[R0, #+0]
   \   00000040   0xE7ED             B.N      ??emberAfGetClustersFromEndpoint_1
    791            }
    792            return clusterCount;
   \                     ??emberAfGetClustersFromEndpoint_2:
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    793          }
    794          

   \                                 In section .text, align 2, keep-with-next
    795          void emberAfInitializeAttributes(int8u endpoint)
    796          {
    797            emAfLoadAttributeDefaults(endpoint, FALSE);
   \                     emberAfInitializeAttributes:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      emAfLoadAttributeDefaults
    798          }
    799          

   \                                 In section .text, align 4, keep-with-next
    800          void emberAfResetAttributes(int8u endpoint)
    801          {
    802            emAfLoadAttributeDefaults(endpoint, TRUE);
   \                     emberAfResetAttributes:
   \   00000000   0xF05F 0x0101      MOVS.W   R1,#+1
   \   00000004                      REQUIRE emAfLoadAttributeDefaults
   \   00000004                      ;; // Fall through to label emAfLoadAttributeDefaults
    803          }
    804          

   \                                 In section .text, align 4, keep-with-next
    805          void emAfLoadAttributeDefaults(int8u endpoint, boolean writeTokens)
    806          {
   \                     emAfLoadAttributeDefaults:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4604             MOV      R4,R0
    807            int8u ep, clusterI, curNetwork = emberGetCurrentNetwork();
   \   00000008   0x.... 0x....      BL       emberGetCurrentNetwork
   \   0000000C   0x4683             MOV      R11,R0
    808            int16u attr;
    809            int8u *ptr;
    810            for ( ep = 0; ep < emberAfEndpointCount(); ep++ ) {
   \   0000000E   0x2600             MOVS     R6,#+0
   \   00000010   0xE000             B.N      ??emAfLoadAttributeDefaults_0
   \                     ??emAfLoadAttributeDefaults_1:
   \   00000012   0x1C76             ADDS     R6,R6,#+1
   \                     ??emAfLoadAttributeDefaults_0:
   \   00000014   0x480B             LDR.N    R0,??emAfLoadAttributeDefaults_2
   \   00000016   0x7C00             LDRB     R0,[R0, #+16]
   \   00000018   0xB2F6             UXTB     R6,R6
   \   0000001A   0x4286             CMP      R6,R0
   \   0000001C   0xD262             BCS.N    ??emAfLoadAttributeDefaults_3
    811              EmberAfDefinedEndpoint *de;
    812              if (endpoint != EMBER_BROADCAST_ENDPOINT) {
   \   0000001E   0x2CFF             CMP      R4,#+255
   \   00000020   0xD005             BEQ.N    ??emAfLoadAttributeDefaults_4
    813                ep = emberAfIndexFromEndpoint(endpoint);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       emberAfIndexFromEndpoint
   \   00000028   0x4606             MOV      R6,R0
    814                if (ep == 0xFF) {
   \   0000002A   0x2EFF             CMP      R6,#+255
   \   0000002C   0xD05A             BEQ.N    ??emAfLoadAttributeDefaults_3
    815                  return;
    816                }
    817              }
    818              de = &(emAfEndpoints[ep]);
   \                     ??emAfLoadAttributeDefaults_4:
   \   0000002E   0x4805             LDR.N    R0,??emAfLoadAttributeDefaults_2
   \   00000030   0xEB00 0x1706      ADD      R7,R0,R6, LSL #+4
    819          
    820              // Ensure that the endpoint is on the current network
    821              if (endpoint == EMBER_BROADCAST_ENDPOINT
    822                  && de->networkIndex != curNetwork) {
   \   00000034   0x2CFF             CMP      R4,#+255
   \   00000036   0xD102             BNE.N    ??emAfLoadAttributeDefaults_5
   \   00000038   0x7B38             LDRB     R0,[R7, #+12]
   \   0000003A   0x4558             CMP      R0,R11
   \   0000003C   0xD1E9             BNE.N    ??emAfLoadAttributeDefaults_1
    823                continue;
    824              }
    825              for ( clusterI = 0; clusterI < de->endpointType->clusterCount; clusterI++) {
   \                     ??emAfLoadAttributeDefaults_5:
   \   0000003E   0xF04F 0x0800      MOV      R8,#+0
   \   00000042   0xE003             B.N      ??emAfLoadAttributeDefaults_6
   \                     ??emAfLoadAttributeDefaults_2:
   \   00000044   0x........         DC32     emAfEndpoints
   \                     ??emAfLoadAttributeDefaults_7:
   \   00000048   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??emAfLoadAttributeDefaults_6:
   \   0000004C   0x68B8             LDR      R0,[R7, #+8]
   \   0000004E   0x7901             LDRB     R1,[R0, #+4]
   \   00000050   0xFA5F 0xF888      UXTB     R8,R8
   \   00000054   0x4588             CMP      R8,R1
   \   00000056   0xD243             BCS.N    ??emAfLoadAttributeDefaults_8
    826                EmberAfCluster *cluster = &(de->endpointType->cluster[clusterI]);
   \   00000058   0x2114             MOVS     R1,#+20
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xFB01 0x0908      MLA      R9,R1,R8,R0
    827                for ( attr = 0; attr < cluster->attributeCount; attr++) {
   \   00000060   0xF04F 0x0A00      MOV      R10,#+0
   \   00000064   0xE008             B.N      ??emAfLoadAttributeDefaults_9
    828                  EmberAfAttributeMetadata *am = &(cluster->attributes[attr]);
    829                  if (!(am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE)) {
    830                    EmberAfAttributeSearchRecord record;
    831                    record.endpoint = de->endpoint;
    832                    record.clusterId = cluster->clusterId;
    833                    record.clusterMask = (emberAfAttributeIsClient(am)
    834                                          ? CLUSTER_MASK_CLIENT
    835                                          : CLUSTER_MASK_SERVER);
    836                    record.attributeId = am->attributeId;
    837                    record.manufacturerCode = emAfGetManufacturerCodeForAttribute(cluster,
    838                                                                                  am);
    839                    if (am->mask & ATTRIBUTE_MASK_MIN_MAX) {
    840                      if ( emberAfAttributeSize(am) <= 2 ) {
    841                        ptr = (int8u*)&(am->defaultValue.ptrToMinMaxValue->defaultValue.defaultValue);
    842                      } else {
    843                        ptr = (int8u*)am->defaultValue.ptrToMinMaxValue->defaultValue.ptrToDefaultValue;
    844                      }
    845                    } else {
    846                      if ( emberAfAttributeSize(am) <= 2 ) {
    847                        ptr = (int8u*)&(am->defaultValue.defaultValue);
    848                      } else {
    849                        ptr = (int8u*)am->defaultValue.ptrToDefaultValue;
    850                      }
    851                    }
    852                    // At this point, ptr either points to a default value, or is NULL, in which case
    853                    // it should be treated as if it is pointing to an array of all zeroes.
    854          
    855          #if (BIGENDIAN_CPU)
    856                    // The default value for one- and two-byte attributes is stored in an
    857                    // int16u.  On big-endian platforms, a pointer to the default value of
    858                    // a one-byte attribute will point to the wrong byte.  So, for those
    859                    // cases, nudge the pointer forward so it points to the correct byte.
    860                    if (emberAfAttributeSize(am) == 1 && ptr != NULL) {
    861                      *ptr++;
    862                    }
    863          #endif //BIGENDIAN
    864                    emAfReadOrWriteAttribute(&record,
    865                                             NULL,  // metadata - unused
    866                                             ptr,
    867                                             0,     // buffer size - unused
    868                                             TRUE); // write?
   \                     ??emAfLoadAttributeDefaults_10:
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0xA801             ADD      R0,SP,#+4
   \   00000070   0x.... 0x....      BL       emAfReadOrWriteAttribute
    869                    if (writeTokens) {
    870                      emAfSaveAttributeToToken(ptr, de->endpoint, record.clusterId, am);
   \                     ??emAfLoadAttributeDefaults_11:
   \   00000074   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??emAfLoadAttributeDefaults_9:
   \   00000078   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   0000007C   0xFA1F 0xFA8A      UXTH     R10,R10
   \   00000080   0x4582             CMP      R10,R0
   \   00000082   0xD2E1             BCS.N    ??emAfLoadAttributeDefaults_7
   \   00000084   0x200C             MOVS     R0,#+12
   \   00000086   0xF8D9 0x1004      LDR      R1,[R9, #+4]
   \   0000008A   0xFB00 0x150A      MLA      R5,R0,R10,R1
   \   0000008E   0x7928             LDRB     R0,[R5, #+4]
   \   00000090   0x06C0             LSLS     R0,R0,#+27
   \   00000092   0xD4EF             BMI.N    ??emAfLoadAttributeDefaults_11
   \   00000094   0x7838             LDRB     R0,[R7, #+0]
   \   00000096   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000009A   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   0000009E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   \   000000A2   0x7928             LDRB     R0,[R5, #+4]
   \   000000A4   0x0640             LSLS     R0,R0,#+25
   \   000000A6   0xBF4C             ITE      MI 
   \   000000A8   0x2080             MOVMI    R0,#+128
   \   000000AA   0x2040             MOVPL    R0,#+64
   \   000000AC   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   000000B0   0x8828             LDRH     R0,[R5, #+0]
   \   000000B2   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   \   000000B6   0x4629             MOV      R1,R5
   \   000000B8   0x4648             MOV      R0,R9
   \   000000BA   0x.... 0x....      BL       emAfGetManufacturerCodeForAttribute
   \   000000BE   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   \   000000C2   0x78E8             LDRB     R0,[R5, #+3]
   \   000000C4   0x7929             LDRB     R1,[R5, #+4]
   \   000000C6   0x0749             LSLS     R1,R1,#+29
   \   000000C8   0xD504             BPL.N    ??emAfLoadAttributeDefaults_12
   \   000000CA   0x68AA             LDR      R2,[R5, #+8]
   \   000000CC   0x2803             CMP      R0,#+3
   \   000000CE   0xD3CA             BCC.N    ??emAfLoadAttributeDefaults_10
   \   000000D0   0x6812             LDR      R2,[R2, #+0]
   \   000000D2   0xE7C8             B.N      ??emAfLoadAttributeDefaults_10
   \                     ??emAfLoadAttributeDefaults_12:
   \   000000D4   0x2803             CMP      R0,#+3
   \   000000D6   0xBF34             ITE      CC 
   \   000000D8   0xF105 0x0208      ADDCC    R2,R5,#+8
   \   000000DC   0x68AA             LDRCS    R2,[R5, #+8]
   \   000000DE   0xE7C2             B.N      ??emAfLoadAttributeDefaults_10
    871                    }
    872                  }
    873                }
    874              }
    875              if (endpoint != EMBER_BROADCAST_ENDPOINT) {
   \                     ??emAfLoadAttributeDefaults_8:
   \   000000E0   0x2CFF             CMP      R4,#+255
   \   000000E2   0xD096             BEQ.N    ??emAfLoadAttributeDefaults_1
    876                break;
    877              }
    878            }
   \                     ??emAfLoadAttributeDefaults_3:
   \   000000E4                      REQUIRE ?Subroutine1
   \   000000E4                      ;; // Fall through to label ?Subroutine1
    879          
    880            if (!writeTokens) {
    881              emAfLoadAttributesFromTokens(endpoint);
    882            }
    883          }
    884          

   \                                 In section .text, align 2, keep-with-next
    885          void emAfLoadAttributesFromTokens(int8u endpoint)
    886          {
    887            // On EZSP host we currently do not support this. We need to come up with some
    888            // callbacks.
    889          #ifndef EZSP_HOST
    890            GENERATED_TOKEN_LOADER(endpoint);
    891          #endif // EZSP_HOST
    892          }
   \                     emAfLoadAttributesFromTokens:
   \   00000000   0x4770             BX       LR               ;; return
    893          
    894          // 'data' argument may be null, since we changed the ptrToDefaultValue
    895          // to be null instead of pointing to all zeroes.
    896          // This function has to be able to deal with that.

   \                                 In section .text, align 2, keep-with-next
    897          void emAfSaveAttributeToToken(int8u *data,
    898                                        int8u endpoint,
    899                                        EmberAfClusterId clusterId,
    900                                        EmberAfAttributeMetadata *metadata)
    901          {
    902            // Get out of here if this attribute doesn't have a token.
    903            if ( !emberAfAttributeIsTokenized(metadata)) return;
   \                     emAfSaveAttributeToToken:
   \   00000000   0x4770             BX       LR               ;; return
    904          
    905          // On EZSP host we currently do not support this. We need to come up with some
    906          // callbacks.
    907          #ifndef EZSP_HOST
    908            GENERATED_TOKEN_SAVER;
    909          #endif // EZSP_HOST
    910          }
    911          
    912          // This function returns the actual function point from the array,
    913          // iterating over the function bits.

   \                                 In section .text, align 2, keep-with-next
    914          EmberAfGenericClusterFunction
    915          emberAfFindClusterFunction(EmberAfCluster *cluster,
    916                                     EmberAfClusterMask functionMask) {
   \                     emberAfFindClusterFunction:
   \   00000000   0xB518             PUSH     {R3,R4,LR}
    917            EmberAfClusterMask mask = 0x01;
   \   00000002   0x2201             MOVS     R2,#+1
    918            int8u functionIndex = 0;
   \   00000004   0x2300             MOVS     R3,#+0
    919          
    920            if ( (cluster->mask & functionMask) == 0 )
   \   00000006   0x7B04             LDRB     R4,[R0, #+12]
   \   00000008   0x420C             TST      R4,R1
   \   0000000A   0xD105             BNE.N    ??emberAfFindClusterFunction_0
    921              return NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD12             POP      {R1,R4,PC}
    922          
    923            while ( mask < functionMask ) {
    924              if ( (cluster->mask & mask) != 0 )
   \                     ??emberAfFindClusterFunction_1:
   \   00000010   0x4214             TST      R4,R2
   \   00000012   0xBF18             IT       NE 
   \   00000014   0x1C5B             ADDNE    R3,R3,#+1
    925                functionIndex++;
    926              mask <<= 1;
   \   00000016   0x0052             LSLS     R2,R2,#+1
    927            }
   \                     ??emberAfFindClusterFunction_0:
   \   00000018   0xB2D2             UXTB     R2,R2
   \   0000001A   0x428A             CMP      R2,R1
   \   0000001C   0xD3F8             BCC.N    ??emberAfFindClusterFunction_1
    928            return cluster->functions[functionIndex];
   \   0000001E   0xB2DB             UXTB     R3,R3
   \   00000020   0x6900             LDR      R0,[R0, #+16]
   \   00000022   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \   00000026   0xBD12             POP      {R1,R4,PC}       ;; return
    929          }
    930          
    931          #ifdef EMBER_AF_SUPPORT_COMMAND_DISCOVERY
    932          /**
    933           * This function populates command IDs into a given buffer.
    934           *
    935           * It returns TRUE if commands are complete, meaning there are NO MORE
    936           * commands that would be returned after the last command.
    937           * It returns FALSE, if there were more commands, but were not populated
    938           * because of maxIdCount limitation.
    939           */

   \                                 In section .text, align 2, keep-with-next
    940          boolean emberAfExtractCommandIds(boolean outgoing,
    941                                           EmberAfClusterCommand *cmd,
    942                                           int16u clusterId,
    943                                           int8u *buffer,
    944                                           int16u bufferLength,
    945                                           int16u *bufferIndex,
    946                                           int8u startId,
    947                                           int8u maxIdCount) {
   \                     emberAfExtractCommandIds:
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x460A             MOV      R2,R1
    948            int16u i, count=0;
   \   00000006   0x2700             MOVS     R7,#+0
    949            boolean returnValue = TRUE;
   \   00000008   0x2101             MOVS     R1,#+1
    950            int8u cmdDirMask = 0;
    951          
    952            // determine the appropriate mask to match the request
    953            // discover commands generated, client is asking server what commands do you generate?
    954            if (outgoing && (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER)) {
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0x7D50             LDRB     R0,[R2, #+21]
   \   0000000E   0xD007             BEQ.N    ??emberAfExtractCommandIds_0
   \   00000010   0xB910             CBNZ.N   R0,??emberAfExtractCommandIds_1
    955              cmdDirMask = COMMAND_MASK_OUTGOING_SERVER;
   \   00000012   0xF04F 0x0C02      MOV      R12,#+2
   \   00000016   0xE009             B.N      ??emberAfExtractCommandIds_2
    956            // discover commands generated server is asking client what commands do you generate?
    957            } else if (outgoing && (cmd->direction == ZCL_DIRECTION_SERVER_TO_CLIENT)) {
   \                     ??emberAfExtractCommandIds_1:
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD105             BNE.N    ??emberAfExtractCommandIds_3
    958              cmdDirMask = COMMAND_MASK_OUTGOING_CLIENT;
   \   0000001C   0x468C             MOV      R12,R1
   \   0000001E   0xE005             B.N      ??emberAfExtractCommandIds_2
    959            // discover commands received client is asking server what commands do you receive?
    960            } else if (!outgoing && (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER)) {
   \                     ??emberAfExtractCommandIds_0:
   \   00000020   0xB910             CBNZ.N   R0,??emberAfExtractCommandIds_3
    961              cmdDirMask = COMMAND_MASK_INCOMING_SERVER;
   \   00000022   0xF04F 0x0C08      MOV      R12,#+8
   \   00000026   0xE001             B.N      ??emberAfExtractCommandIds_2
    962            // discover commands received server is asking client what commands do you receive?
    963            } else {
    964              cmdDirMask = COMMAND_MASK_INCOMING_CLIENT;
   \                     ??emberAfExtractCommandIds_3:
   \   00000028   0xF04F 0x0C04      MOV      R12,#+4
    965            }
    966          
    967            for ( i = 0; i < EMBER_AF_GENERATED_COMMAND_COUNT; i++ ) {
   \                     ??emberAfExtractCommandIds_2:
   \   0000002C   0x46BE             MOV      LR,R7
   \   0000002E   0x.... 0x....      ADR.W    R8,generatedCommands
   \   00000032   0x980A             LDR      R0,[SP, #+40]
   \   00000034   0xB280             UXTH     R0,R0
   \   00000036   0x9C0B             LDR      R4,[SP, #+44]
   \   00000038   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \   0000003C   0xF8DD 0xA034      LDR      R10,[SP, #+52]
    968              if ( generatedCommands[i].clusterId != clusterId )
   \                     ??emberAfExtractCommandIds_4:
   \   00000040   0xF838 0x602E      LDRH     R6,[R8, LR, LSL #+2]
   \   00000044   0xF8BD 0x5000      LDRH     R5,[SP, #+0]
   \   00000048   0x42AE             CMP      R6,R5
   \   0000004A   0xD11C             BNE.N    ??emberAfExtractCommandIds_5
    969                continue;
    970          
    971              if ((generatedCommands[i].mask & cmdDirMask) == 0 )
   \   0000004C   0xEB08 0x058E      ADD      R5,R8,LR, LSL #+2
   \   00000050   0x78EE             LDRB     R6,[R5, #+3]
   \   00000052   0xEA16 0x0F0C      TST      R6,R12
   \   00000056   0xD016             BEQ.N    ??emberAfExtractCommandIds_5
    972                continue;
    973          
    974              //Only start from the passed command id
    975              if (generatedCommands[i].commandId < startId)
   \   00000058   0x78AE             LDRB     R6,[R5, #+2]
   \   0000005A   0x454E             CMP      R6,R9
   \   0000005C   0xD313             BCC.N    ??emberAfExtractCommandIds_5
    976                continue;
    977          
    978              // According to spec: if cmd->mfgSpecific is set, then we ONLY return the
    979              // mfg specific commands. If it's not, then we ONLY return non-mfg specific.
    980              if ( generatedCommands[i].mask & COMMAND_MASK_MANUFACTURER_SPECIFIC ) {
   \   0000005E   0x78EE             LDRB     R6,[R5, #+3]
   \   00000060   0x06F6             LSLS     R6,R6,#+27
   \   00000062   0x7BD6             LDRB     R6,[R2, #+15]
   \   00000064   0xD501             BPL.N    ??emberAfExtractCommandIds_6
    981                 // Command is Mfg specific
    982                if ( !cmd->mfgSpecific ) continue; // ignore if asking for not mfg specific
   \   00000066   0xB90E             CBNZ.N   R6,??emberAfExtractCommandIds_7
   \   00000068   0xE00D             B.N      ??emberAfExtractCommandIds_5
    983             } else {
    984                // Command is not mfg specific.
    985                if ( cmd->mfgSpecific ) continue; // Ignore if asking for mfg specific
   \                     ??emberAfExtractCommandIds_6:
   \   0000006A   0xB966             CBNZ.N   R6,??emberAfExtractCommandIds_5
    986              }
    987          
    988              // The one we are about to put in, is beyond the maxIdCount,
    989              // so instead of populating it in, we set the return flag to
    990              // false and get out of here.
    991              if ( maxIdCount == count || count >= bufferLength ) {
   \                     ??emberAfExtractCommandIds_7:
   \   0000006C   0x45BA             CMP      R10,R7
   \   0000006E   0xD001             BEQ.N    ??emberAfExtractCommandIds_8
   \   00000070   0x4287             CMP      R7,R0
   \   00000072   0xDB01             BLT.N    ??emberAfExtractCommandIds_9
    992                returnValue = FALSE;
   \                     ??emberAfExtractCommandIds_8:
   \   00000074   0x2100             MOVS     R1,#+0
    993                break;
   \   00000076   0xE00B             B.N      ??emberAfExtractCommandIds_10
    994              }
    995              buffer[count] = generatedCommands[i].commandId;
   \                     ??emberAfExtractCommandIds_9:
   \   00000078   0x78AE             LDRB     R6,[R5, #+2]
   \   0000007A   0x54FE             STRB     R6,[R7, R3]
    996              (*bufferIndex)++;
   \   0000007C   0x8826             LDRH     R6,[R4, #+0]
   \   0000007E   0x1C76             ADDS     R6,R6,#+1
   \   00000080   0x8026             STRH     R6,[R4, #+0]
    997              count++;
   \   00000082   0x1C7F             ADDS     R7,R7,#+1
   \   00000084   0xB2BF             UXTH     R7,R7
    998            }
   \                     ??emberAfExtractCommandIds_5:
   \   00000086   0xF10E 0x0E01      ADD      LR,LR,#+1
   \   0000008A   0xF1BE 0x0F0B      CMP      LR,#+11
   \   0000008E   0xDBD7             BLT.N    ??emberAfExtractCommandIds_4
    999            return returnValue;
   \                     ??emberAfExtractCommandIds_10:
   \   00000090   0x4608             MOV      R0,R1
   \   00000092   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1000          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x........         DC32     emAfEndpoints

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x........         DC32     emberAfExternalAttributeWriteCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x........         DC32     emberAfExternalAttributeReadCallback

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x00               DC8 0

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000   0x00               DC8 0

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {1}>`:
   \   00000000   0x01               DC8 1

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {260}>`:
   \   00000000   0x0104             DC16 260

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {1026}>`:
   \   00000000   0x0402             DC16 1026
   1001          #else
   1002          // We just need an empty stub if we don't support it
   1003          boolean emberAfExtractCommandIds(boolean outgoing,
   1004                                           EmberAfClusterCommand *cmd,
   1005                                           int16u clusterId,
   1006                                           int8u *buffer,
   1007                                           int16u bufferLength,
   1008                                           int16u *bufferIndex,
   1009                                           int8u startId,
   1010                                           int8u maxIdCount) {
   1011            return TRUE;
   1012          }
   1013          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  emAfCallInits
             16 -> emberAfEndpointIndexIsEnabled
             16 -> initializeEndpoint
       24  emAfClusterAttributeChangedCallback
             24 -- Indirect call
             24 -> emberAfFindCluster
             24 -> emberAfFindClusterFunction
              0 -> emberAfPopNetworkIndex
             24 -> emberAfPushEndpointNetworkIndex
       40  emAfClusterPreAttributeChangedCallback
             40 -- Indirect call
             40 -> emberAfFindCluster
             40 -> emberAfFindClusterFunction
             40 -> emberAfPopNetworkIndex
             40 -> emberAfPushEndpointNetworkIndex
        0  emAfGetManufacturerCodeForAttribute
              0 -> emAfGetManufacturerCodeForCluster
              0 -> getManufacturerCode
        0  emAfGetManufacturerCodeForCluster
              0 -> getManufacturerCode
       56  emAfLoadAttributeDefaults
             56 -> emAfGetManufacturerCodeForAttribute
             56 -> emAfReadOrWriteAttribute
             56 -> emberAfIndexFromEndpoint
             56 -> emberGetCurrentNetwork
        0  emAfLoadAttributesFromTokens
        8  emAfMatchAttribute
              8 -> emAfGetManufacturerCodeForAttribute
        8  emAfMatchCluster
              8 -> emAfGetManufacturerCodeForCluster
       56  emAfReadOrWriteAttribute
             56 -- Indirect call
             56 -> emAfGetManufacturerCodeForAttribute
             56 -> emAfMatchAttribute
             56 -> emAfMatchCluster
             56 -> emberAfCopyLongString
             56 -> emberAfCopyString
             56 -> emberAfEndpointIndexIsEnabled
             56 -> emberAfIsLongStringAttributeType
             56 -> emberAfIsStringAttributeType
             56 -> halCommonMemCopy
             56 -> halCommonMemSet
        0  emAfSaveAttributeToToken
       16  emberAfClusterCount
             16 -> emberAfIndexFromEndpoint
       24  emberAfClusterDefaultResponseCallback
             24 -- Indirect call
             24 -> emberAfFindCluster
             24 -> emberAfFindClusterFunction
              0 -> emberAfPopNetworkIndex
             24 -> emberAfPushEndpointNetworkIndex
       32  emberAfClusterIndex
             32 -> emberAfFindClusterInType
       40  emberAfClusterMessageSentCallback
             40 -- Indirect call
             40 -> emberAfFindCluster
             40 -> emberAfFindClusterFunction
              0 -> emberAfPopNetworkIndex
             40 -> emberAfPushEndpointNetworkIndex
        8  emberAfContainsClient
              8 -> emberAfFindCluster
        8  emberAfContainsCluster
              8 -> emberAfFindCluster
        8  emberAfContainsServer
              8 -> emberAfFindCluster
       16  emberAfEndpointConfigure
        0  emberAfEndpointCount
       16  emberAfEndpointEnableDisable
             16 -> emberAfDeactivateClusterTick
             16 -> findIndexFromEndpoint
             16 -> initializeEndpoint
        0  emberAfEndpointFromIndex
        0  emberAfEndpointIndexIsEnabled
        8  emberAfEndpointIsEnabled
              8 -> emberAfEndpointIndexIsEnabled
              8 -> findIndexFromEndpoint
       40  emberAfExtractCommandIds
       16  emberAfFindCluster
              0 -> emberAfFindClusterInType
             16 -> emberAfIndexFromEndpoint
        0  emberAfFindClusterClientEndpointIndex
              0 -> findClusterEndpointIndex
       12  emberAfFindClusterFunction
       12  emberAfFindClusterInType
        0  emberAfFindClusterServerEndpointIndex
              0 -> findClusterEndpointIndex
       32  emberAfGetClustersFromEndpoint
             32 -> emberAfClusterCount
             32 -> emberAfGetNthCluster
       16  emberAfGetNthCluster
             16 -> emberAfIndexFromEndpoint
        0  emberAfIndexFromEndpoint
              0 -> findIndexFromEndpoint
        0  emberAfInitializeAttributes
              0 -> emAfLoadAttributeDefaults
        0  emberAfIsLongStringAttributeType
        0  emberAfIsStringAttributeType
        0  emberAfIsThisDataTypeAStringType
       32  emberAfLocateAttributeMetadata
             32 -> emAfReadOrWriteAttribute
        0  emberAfResetAttributes
              0 -> emAfLoadAttributeDefaults
       32  findClusterEndpointIndex
             32 -> emberAfFindCluster
       12  findIndexFromEndpoint
        8  getManufacturerCode
       24  initializeEndpoint
             24 -- Indirect call
             24 -> emberAfClusterInitCallback
             24 -> emberAfFindClusterFunction
              0 -> emberAfPopNetworkIndex
             24 -> emberAfPushEndpointNetworkIndex


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Constant {0}>
       1  ?<Constant {0}>_1
       1  ?<Constant {0}>_2
       2  ?<Constant {1026}>
       1  ?<Constant {1}>
       2  ?<Constant {260}>
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       8  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine2
       2  attributeManufacturerCodeCount
       4  attributeManufacturerCodes
       2  clusterManufacturerCodeCount
       4  clusterManufacturerCodes
      38  emAfCallInits
      72  emAfClusterAttributeChangedCallback
      78  emAfClusterPreAttributeChangedCallback
      52  emAfEndpoints
          emberEndpointCount
          singletonAttributeData
          attributeData
      34  emAfGetManufacturerCodeForAttribute
      22  emAfGetManufacturerCodeForCluster
     228  emAfLoadAttributeDefaults
       2  emAfLoadAttributesFromTokens
      38  emAfMatchAttribute
      44  emAfMatchCluster
       4  emAfNetworks
     400  emAfReadOrWriteAttribute
       2  emAfSaveAttributeToToken
      72  emberAfClusterCount
      44  emberAfClusterDefaultResponseCallback
      64  emberAfClusterIndex
      86  emberAfClusterMessageSentCallback
       6  emberAfContainsClient
       6  emberAfContainsCluster
       4  emberAfContainsServer
     124  emberAfEndpointConfigure
       8  emberAfEndpointCount
      96  emberAfEndpointEnableDisable
       8  emberAfEndpointFromIndex
      16  emberAfEndpointIndexIsEnabled
      24  emberAfEndpointIsEnabled
     150  emberAfExtractCommandIds
      36  emberAfFindCluster
       2  emberAfFindClusterClientEndpointIndex
      40  emberAfFindClusterFunction
      60  emberAfFindClusterInType
       4  emberAfFindClusterServerEndpointIndex
       8  emberAfFuncArrayIasZoneClusterServer
       8  emberAfFuncArrayIdentifyClusterServer
      72  emberAfGetClustersFromEndpoint
      74  emberAfGetNthCluster
       4  emberAfIndexFromEndpoint
       4  emberAfInitializeAttributes
      16  emberAfIsLongStringAttributeType
      16  emberAfIsStringAttributeType
      24  emberAfIsThisDataTypeAStringType
      50  emberAfLocateAttributeMetadata
       4  emberAfResetAttributes
      72  findClusterEndpointIndex
      44  findIndexFromEndpoint
     132  generatedAttributes
     100  generatedClusters
      44  generatedCommands
      12  generatedDefaults
       8  generatedEmberAfEndpointTypes
      30  getManufacturerCode
      58  initializeEndpoint

 
    52 bytes in section .bss
    39 bytes in section .rodata
 2 609 bytes in section .text
 
 2 609 bytes of CODE  memory
    39 bytes of CONST memory
    52 bytes of DATA  memory

Errors: none
Warnings: none
