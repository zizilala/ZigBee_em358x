###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     04/Feb/2015  16:37:46 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\clie #
#                    nt-api.c                                                 #
#    Command line =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\clie #
#                    nt-api.c -D "GENERATED_TOKEN_HEADER=\"app/builder/DoorSe #
#                    nsor_SM6011/DoorSensor_SM6011_tokens.h\"" -D             #
#                    "ZA_GENERATED_HEADER=\"app/builder/DoorSensor_SM6011/Doo #
#                    rSensor_SM6011.h\"" -D LOCAL_STORAGE_BTL -D              #
#                    "BOARD_HEADER=\"app\builder\DoorSensor_SM6011\DoorSensor #
#                    _SM6011_board.h\"" -D "PLATFORM_HEADER=\"hal/micro/corte #
#                    xm3/compiler/iar.h\"" -D CORTEXM3 -D                     #
#                    CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3585 -D PHY_EM3XX -D  #
#                    "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\ #
#                    "" -D "CONFIGURATION_HEADER=\"app/framework/util/config. #
#                    h\"" -D "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/D #
#                    oorSensor_SM6011/DoorSensor_SM6011_endpoint_config.h\""  #
#                    -D "__SOURCEFILE__=\"client-api.c\"" -lC                 #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \ --diag_suppress Pa050 -o C:\Ember\EmberZNet5.3.0-GA\em #
#                    35x\build\DoorSensor_SM6011\ --debug --endian=little     #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\ -I  #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\ #
#                    DoorSensor_SM6011\..\..\..\ -I                           #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\app\framework\include\ -I                #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app #
#                    \builder\DoorSensor_SM6011\..\..\..\stack\ -I            #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\hal\ -I C:\Ember\EmberZNet5.3.0-GA\em35x #
#                    \app\builder\DoorSensor_SM6011\..\..\..\hal\..\ -Ohz     #
#                    --use_c++_inline                                         #
#    List file    =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \client-api.lst                                          #
#    Object file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \client-api.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\client-api.c
      1          // Copyright 2009 by Ember Corporation. All rights reserved.
      2          //
      3          // This file contains the C portion of the client api.
      4          //
      5          
      6          #include PLATFORM_HEADER
      7          #include "common.h"
      8          #include "util.h"
      9          #include "client-api.h"
     10          

   \                                 In section .bss, align 4
     11          int8u *emAfZclBuffer = NULL;
     12          int16u emAfZclBufferLen = 0;
   \                     emAfZclBufferLen:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \                     emAfZclBuffer:
   \   00000004                      DS8 4
     13          
     14          // Pointer to where this API should put the length
     15          int16u *emAfResponseLengthPtr = NULL;
   \                     emAfResponseLengthPtr:
   \   00000008                      DS8 4
     16          
     17          // Pointer to where the API should put the cluster ID
     18          EmberApsFrame *emAfCommandApsFrame = NULL;
   \                     emAfCommandApsFrame:
   \   0000000C                      DS8 4
     19          
     20          /////////////////
     21          
     22          // Method that fills in the buffer.
     23          // It returns number of bytes filled
     24          // and 0 on error.

   \                                 In section .text, align 2, keep-with-next
     25          static int16u vFillBuffer(int8u *buffer,
     26                                    int16u bufferLen,
     27                                    int8u frameControl,
     28                                    int16u manufacturerCode,
     29                                    int8u commandId,
     30                                    PGM_P format,
     31                                    va_list argPointer)
     32          {
   \                     vFillBuffer:
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x9C0C             LDR      R4,[SP, #+48]
     33            int32u value;
     34            int8u valueLen;
     35            int8u *data;
     36            int16u dataLen;
     37            int8u i;
     38            int16u bytes = 0;
     39          
     40            // The destination buffer must be at least large enough to hold the ZCL
     41            // overhead: frame control, manufacturer code (if applicable), sequence
     42            // number, and command id.  If it is, add these in order.
     43            if (bufferLen < EMBER_AF_ZCL_OVERHEAD
     44                || (manufacturerCode != EMBER_AF_NULL_MANUFACTURER_CODE
     45                    && bufferLen < EMBER_AF_ZCL_MANUFACTURER_SPECIFIC_OVERHEAD)) {
   \   0000000A   0x2903             CMP      R1,#+3
   \   0000000C   0xD302             BCC.N    ??vFillBuffer_0
   \   0000000E   0xB14B             CBZ.N    R3,??vFillBuffer_1
   \   00000010   0x2905             CMP      R1,#+5
   \   00000012   0xD205             BCS.N    ??vFillBuffer_2
     46              emberAfDebugPrintln("ERR: Buffer too short for ZCL header");
   \                     ??vFillBuffer_0:
   \   00000014   0x.... 0x....      ADR.W    R1,`?<Constant "ERR: Buffer too short...">`
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      BL       emberAfPrintln
     47              return 0;
   \   0000001E   0xE09A             B.N      ??vFillBuffer_3
     48            }
     49            if (manufacturerCode != EMBER_AF_NULL_MANUFACTURER_CODE) {
     50              frameControl |= ZCL_MANUFACTURER_SPECIFIC_MASK;
   \                     ??vFillBuffer_2:
   \   00000020   0xF042 0x0204      ORR      R2,R2,#0x4
     51            }
     52            buffer[bytes++] = frameControl;
   \                     ??vFillBuffer_1:
   \   00000024   0xF889 0x2000      STRB     R2,[R9, #+0]
   \   00000028   0x2701             MOVS     R7,#+1
     53            if (manufacturerCode != EMBER_AF_NULL_MANUFACTURER_CODE) {
   \   0000002A   0xB12B             CBZ.N    R3,??vFillBuffer_4
     54              buffer[bytes++] = LOW_BYTE(manufacturerCode);
   \   0000002C   0xF889 0x3001      STRB     R3,[R9, #+1]
     55              buffer[bytes++] = HIGH_BYTE(manufacturerCode);
   \   00000030   0x0A18             LSRS     R0,R3,#+8
   \   00000032   0xF889 0x0002      STRB     R0,[R9, #+2]
   \   00000036   0x2703             MOVS     R7,#+3
     56            }
     57            buffer[bytes++] = emberAfNextSequence();
   \                     ??vFillBuffer_4:
   \   00000038   0x.... 0x....      BL       emberAfNextSequence
   \   0000003C   0xF807 0x0009      STRB     R0,[R7, R9]
   \   00000040   0x1C78             ADDS     R0,R7,#+1
     58            buffer[bytes++] = commandId;
   \   00000042   0xB280             UXTH     R0,R0
   \   00000044   0xF800 0x4009      STRB     R4,[R0, R9]
   \   00000048   0x1C44             ADDS     R4,R0,#+1
     59          
     60            // Each argument comes in as an integer value, a pointer to a buffer, or a
     61            // pointer to a buffer followed by an integer length.
     62            for (i = 0; format[i] != 0; i++) {
   \   0000004A   0x2700             MOVS     R7,#+0
   \   0000004C   0x980D             LDR      R0,[SP, #+52]
   \   0000004E   0x900D             STR      R0,[SP, #+52]
   \   00000050   0xF8DD 0x8038      LDR      R8,[SP, #+56]
   \   00000054   0xE011             B.N      ??vFillBuffer_5
     63              char cmd = format[i];
     64              if (cmd <= 's') {
     65                //  0--9, A--G, L, S, b, l, and s all have a pointer to a buffer.  The
     66                // length of that buffer is implied by 0--9 and A--G (0 to 16 bytes).
     67                // For L, S, and b, a separate integer specifies the length.  That length
     68                // will precede the data in the destination buffer for L and S, which
     69                // turns them into regular ZigBee strings.  In this case, care must be
     70                // taken to account for invalid strings, which have length 0xFFFF or 0xFF
     71                // for L and S respectively.  In the case of invalid strings, the length
     72                // byte(s) are copied to the destination buffer but the string itself is
     73                // not.  Finally, l and s are just ZigBee strings and the length of the
     74                // string data is contained within the buffer itself and the entire
     75                // buffer is copied as is to the destination buffer.  Note that
     76                // emberAf(Long)StringLength handles invalid strings, but it does not
     77                // include the length byte(s) in the total length, so the overhead
     78                // must be maually accounted for when copying.
     79                data = (int8u *)va_arg(argPointer, int8u *);
     80                valueLen = 0;
     81                if (cmd == 'L' || cmd == 'S' || cmd == 'b') {
     82                  dataLen = (int16u)va_arg(argPointer, int);
     83                  if (cmd == 'L') {
     84                    value = dataLen;
     85                    valueLen = (value == 0xFFFF ? 0 : 2);
     86                  } else if (cmd == 'S') {
     87                    value = (int8u)dataLen;
     88                    valueLen = (value == 0xFF ? 0 : 1);
     89                  }
     90                } else if (cmd == 'l') {
     91                  dataLen = emberAfLongStringLength(data) + 2;
     92                } else if (cmd == 's') {
     93                  dataLen = emberAfStringLength(data) + 1;
     94                } else if ('0' <= cmd && cmd <= '9') {
     95                  dataLen = cmd - '0';
     96                } else if ('A' <= cmd && cmd <= 'G') {
     97                  dataLen = cmd - 'A' + 10;
     98                } else {
     99                  emberAfDebugPrintln("ERR: Unknown format '%c'", cmd);
    100                  return 0;
    101                }
    102              } else {
    103                // u, v, x, and w are one-, two-, three-, or four-byte integers.  u and v
    104                // must be extracted as an int while x and w come through as an int32u.
    105                // In all cases, the value is copied to the destination buffer in little-
    106                // endian format.
    107                dataLen = 0;
    108                if (cmd == 'u') {
    109                  valueLen = 1;
    110                } else if (cmd == 'v') {
    111                  valueLen = 2;
    112                } else if (cmd == 'x') {
    113                  valueLen = 3;
    114                } else if (cmd == 'w') {
    115                  valueLen = 4;
    116                } else {
    117                  emberAfDebugPrintln("ERR: Unknown format '%c'", cmd);
    118                  return 0;
    119                }
    120                value = (int32u)(valueLen <= 2
    121                                 ? va_arg(argPointer, int)
    122                                 : va_arg(argPointer, int32u));
    123              }
    124          
    125              // The destination buffer must be at least as large as the running total
    126              // plus the length of the integer value (if applicable) plus the length of
    127              // the data (if applicable).
    128              if (bufferLen < bytes + dataLen + valueLen) {
    129                emberAfDebugPrintln("ERR: Buffer too short for %d bytes for format '%c'",
    130                                    dataLen + valueLen,
    131                                    cmd);
    132                return 0;
    133              }
    134          
    135              // If there is an integer value, add it to destination buffer in little-
    136              // endian format.
    137              for (; 0 < valueLen; valueLen--) {
    138                buffer[bytes++] = LOW_BYTE(value);
   \                     ??vFillBuffer_6:
   \   00000056   0xF804 0xA009      STRB     R10,[R4, R9]
   \   0000005A   0x1C64             ADDS     R4,R4,#+1
    139                value = value >> 8;
   \   0000005C   0xEA4F 0x2A1A      LSR      R10,R10,#+8
    140              }
   \   00000060   0x1E46             SUBS     R6,R0,#+1
   \                     ??vFillBuffer_7:
   \   00000062   0xB2A4             UXTH     R4,R4
   \   00000064   0xB2F0             UXTB     R0,R6
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD1F5             BNE.N    ??vFillBuffer_6
    141          
    142              // Finally, if there is data, add it to the destination buffer as is.
    143              MEMCOPY(buffer + bytes, data, dataLen);
   \   0000006A   0x465A             MOV      R2,R11
   \   0000006C   0x9900             LDR      R1,[SP, #+0]
   \   0000006E   0xEB04 0x0009      ADD      R0,R4,R9
   \   00000072   0x.... 0x....      BL       halCommonMemCopy
    144              bytes += dataLen;
   \   00000076   0x445C             ADD      R4,R11,R4
   \   00000078   0x1C7F             ADDS     R7,R7,#+1
   \                     ??vFillBuffer_5:
   \   0000007A   0xB2FF             UXTB     R7,R7
   \   0000007C   0x980D             LDR      R0,[SP, #+52]
   \   0000007E   0x5C3D             LDRB     R5,[R7, R0]
   \   00000080   0x2D00             CMP      R5,#+0
   \   00000082   0xD06A             BEQ.N    ??vFillBuffer_8
   \   00000084   0x2D74             CMP      R5,#+116
   \   00000086   0xDA3A             BGE.N    ??vFillBuffer_9
   \   00000088   0xF858 0x0B04      LDR      R0,[R8], #+4
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0x2600             MOVS     R6,#+0
   \   00000090   0x2D4C             CMP      R5,#+76
   \   00000092   0xBF1C             ITT      NE 
   \   00000094   0x2D53             CMPNE    R5,#+83
   \   00000096   0x2D62             CMPNE    R5,#+98
   \   00000098   0xD115             BNE.N    ??vFillBuffer_10
   \   0000009A   0xF858 0xBB04      LDR      R11,[R8], #+4
   \   0000009E   0x2D4C             CMP      R5,#+76
   \   000000A0   0xD108             BNE.N    ??vFillBuffer_11
   \   000000A2   0xFA1F 0xFB8B      UXTH     R11,R11
   \   000000A6   0x46DA             MOV      R10,R11
   \   000000A8   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000AC   0x4582             CMP      R10,R0
   \   000000AE   0xD035             BEQ.N    ??vFillBuffer_12
   \   000000B0   0x2602             MOVS     R6,#+2
   \   000000B2   0xE033             B.N      ??vFillBuffer_12
   \                     ??vFillBuffer_11:
   \   000000B4   0x2D53             CMP      R5,#+83
   \   000000B6   0xD131             BNE.N    ??vFillBuffer_12
   \   000000B8   0xFA5F 0xFA8B      UXTB     R10,R11
   \   000000BC   0xF1BA 0x0FFF      CMP      R10,#+255
   \   000000C0   0xD02C             BEQ.N    ??vFillBuffer_12
   \   000000C2   0x2601             MOVS     R6,#+1
   \   000000C4   0xE02A             B.N      ??vFillBuffer_12
   \                     ??vFillBuffer_10:
   \   000000C6   0x2D6C             CMP      R5,#+108
   \   000000C8   0xD104             BNE.N    ??vFillBuffer_13
   \   000000CA   0x.... 0x....      BL       emberAfLongStringLength
   \   000000CE   0xF100 0x0B02      ADD      R11,R0,#+2
   \   000000D2   0xE023             B.N      ??vFillBuffer_12
   \                     ??vFillBuffer_13:
   \   000000D4   0x2D73             CMP      R5,#+115
   \   000000D6   0xD104             BNE.N    ??vFillBuffer_14
   \   000000D8   0x.... 0x....      BL       emberAfStringLength
   \   000000DC   0xF100 0x0B01      ADD      R11,R0,#+1
   \   000000E0   0xE01C             B.N      ??vFillBuffer_12
   \                     ??vFillBuffer_14:
   \   000000E2   0xF1A5 0x0030      SUB      R0,R5,#+48
   \   000000E6   0x280A             CMP      R0,#+10
   \   000000E8   0xBF38             IT       CC 
   \   000000EA   0xF1A5 0x0B30      SUBCC    R11,R5,#+48
   \   000000EE   0xD315             BCC.N    ??vFillBuffer_12
   \   000000F0   0xF1A5 0x0041      SUB      R0,R5,#+65
   \   000000F4   0x2807             CMP      R0,#+7
   \   000000F6   0xD228             BCS.N    ??vFillBuffer_15
   \   000000F8   0xF1A5 0x0B37      SUB      R11,R5,#+55
   \   000000FC   0xE00E             B.N      ??vFillBuffer_12
   \                     ??vFillBuffer_9:
   \   000000FE   0xF04F 0x0B00      MOV      R11,#+0
   \   00000102   0x2D75             CMP      R5,#+117
   \   00000104   0xBF08             IT       EQ 
   \   00000106   0x2601             MOVEQ    R6,#+1
   \   00000108   0xD006             BEQ.N    ??vFillBuffer_16
   \   0000010A   0x2D76             CMP      R5,#+118
   \   0000010C   0xBF08             IT       EQ 
   \   0000010E   0x2602             MOVEQ    R6,#+2
   \   00000110   0xD002             BEQ.N    ??vFillBuffer_16
   \   00000112   0x2D78             CMP      R5,#+120
   \   00000114   0xD115             BNE.N    ??vFillBuffer_17
   \   00000116   0x2603             MOVS     R6,#+3
   \                     ??vFillBuffer_16:
   \   00000118   0xF858 0xAB04      LDR      R10,[R8], #+4
   \                     ??vFillBuffer_12:
   \   0000011C   0xFA1F 0xFB8B      UXTH     R11,R11
   \   00000120   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000124   0xB2A4             UXTH     R4,R4
   \   00000126   0xEB0B 0x0104      ADD      R1,R11,R4
   \   0000012A   0x1871             ADDS     R1,R6,R1
   \   0000012C   0x4288             CMP      R0,R1
   \   0000012E   0xDA98             BGE.N    ??vFillBuffer_7
   \   00000130   0x462B             MOV      R3,R5
   \   00000132   0xEB06 0x020B      ADD      R2,R6,R11
   \   00000136   0x.... 0x....      ADR.W    R1,`?<Constant "ERR: Buffer too short...">_1`
   \   0000013A   0x2002             MOVS     R0,#+2
   \   0000013C   0x.... 0x....      BL       emberAfPrintln
   \   00000140   0xE009             B.N      ??vFillBuffer_3
   \                     ??vFillBuffer_17:
   \   00000142   0x2D77             CMP      R5,#+119
   \   00000144   0xBF08             IT       EQ 
   \   00000146   0x2604             MOVEQ    R6,#+4
   \   00000148   0xD0E6             BEQ.N    ??vFillBuffer_16
   \                     ??vFillBuffer_15:
   \   0000014A   0x462A             MOV      R2,R5
   \   0000014C   0x.... 0x....      ADR.W    R1,`?<Constant "ERR: Unknown format \\'%c\\'">`
   \   00000150   0x2002             MOVS     R0,#+2
   \   00000152   0x.... 0x....      BL       emberAfPrintln
   \                     ??vFillBuffer_3:
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xE000             B.N      ??vFillBuffer_18
    145            }
    146          
    147            return bytes;
   \                     ??vFillBuffer_8:
   \   0000015A   0xB2A0             UXTH     R0,R4
   \                     ??vFillBuffer_18:
   \   0000015C   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    148          }
    149          
    150          ////////////////////// Public API ////////////////////////
    151          

   \                                 In section .text, align 2, keep-with-next
    152          void emberAfSetExternalBuffer(int8u *buffer,
    153                                        int16u bufferLen,
    154                                        int16u *lenPtr,
    155                                        EmberApsFrame *apsFrame)
    156          {
   \                     emberAfSetExternalBuffer:
   \   00000000   0xB510             PUSH     {R4,LR}
    157            emAfZclBuffer = buffer;
   \   00000002   0x....             LDR.N    R4,??DataTable11
   \   00000004   0x6060             STR      R0,[R4, #+4]
    158            emAfZclBufferLen = bufferLen;
   \   00000006   0x8021             STRH     R1,[R4, #+0]
    159            emAfResponseLengthPtr = lenPtr;
   \   00000008   0x60A2             STR      R2,[R4, #+8]
    160            emAfCommandApsFrame = apsFrame;
   \   0000000A   0x60E3             STR      R3,[R4, #+12]
    161          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    162          

   \                                 In section .text, align 2, keep-with-next
    163          int16u emberAfFillExternalManufacturerSpecificBuffer(int8u frameControl,
    164                                                               EmberAfClusterId clusterId,
    165                                                               int16u manufacturerCode,
    166                                                               int8u commandId,
    167                                                               PGM_P format,
    168                                                               ...)
    169          {
   \                     emberAfFillExternalManufacturerSpecificBuffer:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x9908             LDR      R1,[SP, #+32]
    170            int16u returnValue;
    171            va_list argPointer;
    172          
    173            va_start(argPointer, format);
   \   00000008   0xAD09             ADD      R5,SP,#+36
    174            returnValue = vFillBuffer(emAfZclBuffer,
    175                                      emAfZclBufferLen,
    176                                      frameControl,
    177                                      manufacturerCode,
    178                                      commandId,
    179                                      format,
    180                                      argPointer);
   \   0000000A   0x....             LDR.N    R6,??DataTable11
   \   0000000C   0x9502             STR      R5,[SP, #+8]
   \   0000000E   0x9101             STR      R1,[SP, #+4]
   \   00000010   0x9300             STR      R3,[SP, #+0]
   \   00000012   0x4613             MOV      R3,R2
   \   00000014   0x4602             MOV      R2,R0
   \   00000016   0x8831             LDRH     R1,[R6, #+0]
   \   00000018   0x6870             LDR      R0,[R6, #+4]
   \   0000001A   0x.... 0x....      BL       vFillBuffer
    181            va_end(argPointer);
    182            *emAfResponseLengthPtr = returnValue;
   \   0000001E   0x68B1             LDR      R1,[R6, #+8]
   \   00000020   0x8008             STRH     R0,[R1, #+0]
    183            emAfCommandApsFrame->clusterId = clusterId;
   \   00000022   0x68F1             LDR      R1,[R6, #+12]
   \   00000024   0x804C             STRH     R4,[R1, #+2]
    184            emAfCommandApsFrame->options = EMBER_AF_DEFAULT_APS_OPTIONS;
   \   00000026   0xF44F 0x528A      MOV      R2,#+4416
   \   0000002A   0x80CA             STRH     R2,[R1, #+6]
    185            return returnValue;
   \   0000002C   0xB004             ADD      SP,SP,#+16
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    186          }
    187          

   \                                 In section .text, align 2, keep-with-next
    188          int16u emberAfFillExternalBuffer(int8u frameControl,
    189                                           EmberAfClusterId clusterId,
    190                                           int8u commandId,
    191                                           PGM_P format,
    192                                           ...)
    193          {
   \                     emberAfFillExternalBuffer:
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    194            int16u returnValue;
    195            va_list argPointer;
    196          
    197            va_start(argPointer, format);
   \   00000004   0xA906             ADD      R1,SP,#+24
    198            returnValue = vFillBuffer(emAfZclBuffer,
    199                                      emAfZclBufferLen,
    200                                      frameControl,
    201                                      EMBER_AF_NULL_MANUFACTURER_CODE,
    202                                      commandId,
    203                                      format,
    204                                      argPointer);
   \   00000006   0x....             LDR.N    R5,??DataTable11
   \   00000008   0x9102             STR      R1,[SP, #+8]
   \   0000000A   0x9301             STR      R3,[SP, #+4]
   \   0000000C   0x9200             STR      R2,[SP, #+0]
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x4602             MOV      R2,R0
   \   00000012   0x8829             LDRH     R1,[R5, #+0]
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0x.... 0x....      BL       vFillBuffer
    205            va_end(argPointer);
    206            *emAfResponseLengthPtr = returnValue;
   \   0000001A   0x68A9             LDR      R1,[R5, #+8]
   \   0000001C   0x8008             STRH     R0,[R1, #+0]
    207            emAfCommandApsFrame->clusterId = clusterId;
   \   0000001E   0x68E9             LDR      R1,[R5, #+12]
   \   00000020   0x804C             STRH     R4,[R1, #+2]
    208            emAfCommandApsFrame->options = EMBER_AF_DEFAULT_APS_OPTIONS;
   \   00000022   0xF44F 0x528A      MOV      R2,#+4416
   \   00000026   0x80CA             STRH     R2,[R1, #+6]
    209            return returnValue;
   \   00000028   0xBD3E             POP      {R1-R5,PC}       ;; return
    210          }
    211          

   \                                 In section .text, align 2, keep-with-next
    212          int16u emberAfFillBuffer(int8u *buffer,
    213                                   int16u bufferLen,
    214                                   int8u frameControl,
    215                                   int8u commandId,
    216                                   PGM_P format,
    217                                   ...)
    218          {
   \                     emberAfFillBuffer:
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x9C06             LDR      R4,[SP, #+24]
    219            int16u returnValue;
    220            va_list argPointer;
    221          
    222            va_start(argPointer, format);
   \   00000004   0xAD07             ADD      R5,SP,#+28
    223            returnValue = vFillBuffer(buffer,
    224                                      bufferLen,
    225                                      frameControl,
    226                                      EMBER_AF_NULL_MANUFACTURER_CODE,
    227                                      commandId,
    228                                      format,
    229                                      argPointer);
    230            va_end(argPointer);
    231            return returnValue;
   \   00000006   0x9502             STR      R5,[SP, #+8]
   \   00000008   0x9401             STR      R4,[SP, #+4]
   \   0000000A   0x9300             STR      R3,[SP, #+0]
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x.... 0x....      BL       vFillBuffer
   \   00000012   0xBD3E             POP      {R1-R5,PC}       ;; return
    232          }
    233          

   \                                 In section .text, align 2, keep-with-next
    234          EmberStatus emberAfSendCommandUnicastToBindingsWithCallback(EmberAfMessageSentFunction callback)
    235          {
   \                     emberAfSendCommandUnicastToBindingsWithCallback:
   \   00000000   0xB510             PUSH     {R4,LR}
    236            return emberAfSendUnicastToBindingsWithCallback(emAfCommandApsFrame,
    237                                                            *emAfResponseLengthPtr,
    238                                                            emAfZclBuffer, 
    239                                                            callback);
   \   00000002   0x....             LDR.N    R4,??DataTable11
   \   00000004   0x4603             MOV      R3,R0
   \   00000006   0x6862             LDR      R2,[R4, #+4]
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   \   0000000A   0x8801             LDRH     R1,[R0, #+0]
   \   0000000C   0x68E0             LDR      R0,[R4, #+12]
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      emberAfSendUnicastToBindingsWithCallback
    240          }
    241          

   \                                 In section .text, align 2, keep-with-next
    242          EmberStatus emberAfSendCommandUnicastToBindings(void)
    243          {
    244            return emberAfSendCommandUnicastToBindingsWithCallback(NULL);
   \                     emberAfSendCommandUnicastToBindings:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      emberAfSendCommandUnicastToBindingsWithCallback
    245          }
    246          

   \                                 In section .text, align 2, keep-with-next
    247          EmberStatus emberAfSendCommandMulticastWithCallback(EmberMulticastId multicastId,
    248                                                              EmberAfMessageSentFunction callback)
    249          {
   \                     emberAfSendCommandMulticastWithCallback:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    250            return emberAfSendMulticastWithCallback(multicastId,
    251                                                    emAfCommandApsFrame,
    252                                                    *emAfResponseLengthPtr,
    253                                                    emAfZclBuffer, 
    254                                                    callback);
   \   00000004   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   00000008   0x.... 0x....      BL       emberAfSendMulticastWithCallback
   \   0000000C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    255          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x....             LDR.N    R4,??DataTable11
   \   00000002   0x9100             STR      R1,[SP, #+0]
   \   00000004   0x6863             LDR      R3,[R4, #+4]
   \   00000006   0x68A1             LDR      R1,[R4, #+8]
   \   00000008   0x880A             LDRH     R2,[R1, #+0]
   \   0000000A   0x68E1             LDR      R1,[R4, #+12]
   \   0000000C   0x4770             BX       LR
    256          

   \                                 In section .text, align 2, keep-with-next
    257          EmberStatus emberAfSendCommandMulticast(EmberMulticastId multicastId)
    258          {
    259            return emberAfSendCommandMulticastWithCallback(multicastId, NULL);
   \                     emberAfSendCommandMulticast:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      emberAfSendCommandMulticastWithCallback
    260          }
    261          

   \                                 In section .text, align 2, keep-with-next
    262          EmberStatus emberAfSendCommandUnicastWithCallback(EmberOutgoingMessageType type,
    263                                                            int16u indexOrDestination,
    264                                                            EmberAfMessageSentFunction callback)
    265          {
   \                     emberAfSendCommandUnicastWithCallback:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    266            return emberAfSendUnicastWithCallback(type,
    267                                                  indexOrDestination,
    268                                                  emAfCommandApsFrame,
    269                                                  *emAfResponseLengthPtr,
    270                                                  emAfZclBuffer,
    271                                                  callback);
   \   00000002   0x....             LDR.N    R4,??DataTable11
   \   00000004   0x9201             STR      R2,[SP, #+4]
   \   00000006   0x6862             LDR      R2,[R4, #+4]
   \   00000008   0x9200             STR      R2,[SP, #+0]
   \   0000000A   0x68A2             LDR      R2,[R4, #+8]
   \   0000000C   0x8813             LDRH     R3,[R2, #+0]
   \   0000000E   0x68E2             LDR      R2,[R4, #+12]
   \   00000010   0x.... 0x....      BL       emberAfSendUnicastWithCallback
   \   00000014   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    272          }
    273          

   \                                 In section .text, align 2, keep-with-next
    274          EmberStatus emberAfSendCommandUnicast(EmberOutgoingMessageType type,
    275                                                int16u indexOrDestination)
    276          {
    277            return emberAfSendCommandUnicastWithCallback(type, indexOrDestination, NULL);
   \                     emberAfSendCommandUnicast:
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x....             B.N      emberAfSendCommandUnicastWithCallback
    278          }
    279          

   \                                 In section .text, align 2, keep-with-next
    280          EmberStatus emberAfSendCommandBroadcastWithCallback(EmberNodeId destination,
    281                                                              EmberAfMessageSentFunction callback)
    282          {
   \                     emberAfSendCommandBroadcastWithCallback:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    283            return emberAfSendBroadcastWithCallback(destination,
    284                                                    emAfCommandApsFrame,
    285                                                    *emAfResponseLengthPtr,
    286                                                    emAfZclBuffer,
    287                                                    callback);
   \   00000004   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   00000008   0x.... 0x....      BL       emberAfSendBroadcastWithCallback
   \   0000000C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    288          }
    289          

   \                                 In section .text, align 2, keep-with-next
    290          EmberStatus emberAfSendCommandBroadcast(EmberNodeId destination)
    291          {
    292            return emberAfSendCommandBroadcastWithCallback(destination, NULL);
   \                     emberAfSendCommandBroadcast:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      emberAfSendCommandBroadcastWithCallback
    293          }
    294          

   \                                 In section .text, align 2, keep-with-next
    295          EmberStatus emberAfSendCommandInterPan(EmberPanId panId,
    296                                                 const EmberEUI64 destinationLongId,
    297                                                 EmberNodeId destinationShortId,
    298                                                 EmberMulticastId multicastId,
    299                                                 EmberAfProfileId profileId)
    300          {
   \                     emberAfSendCommandInterPan:
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x9C08             LDR      R4,[SP, #+32]
    301            return emberAfSendInterPan(panId,
    302                                       destinationLongId,
    303                                       destinationShortId,
    304                                       multicastId,
    305                                       emAfCommandApsFrame->clusterId,
    306                                       profileId,
    307                                       *emAfResponseLengthPtr,
    308                                       emAfZclBuffer);
   \   00000004   0x....             LDR.N    R5,??DataTable11
   \   00000006   0x686E             LDR      R6,[R5, #+4]
   \   00000008   0x9603             STR      R6,[SP, #+12]
   \   0000000A   0x68AE             LDR      R6,[R5, #+8]
   \   0000000C   0x8836             LDRH     R6,[R6, #+0]
   \   0000000E   0x9602             STR      R6,[SP, #+8]
   \   00000010   0xB2A4             UXTH     R4,R4
   \   00000012   0x9401             STR      R4,[SP, #+4]
   \   00000014   0x68EC             LDR      R4,[R5, #+12]
   \   00000016   0x8864             LDRH     R4,[R4, #+2]
   \   00000018   0x9400             STR      R4,[SP, #+0]
   \   0000001A   0x.... 0x....      BL       emberAfSendInterPan
   \   0000001E   0xB004             ADD      SP,SP,#+16
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    309          }
    310          

   \                                 In section .text, align 2, keep-with-next
    311          EmberApsFrame *emberAfGetCommandApsFrame(void)
    312          {
    313            return emAfCommandApsFrame;
   \                     emberAfGetCommandApsFrame:
   \   00000000   0x....             LDR.N    R0,??DataTable11
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0x4770             BX       LR               ;; return
    314          }
    315          

   \                                 In section .text, align 2, keep-with-next
    316          void emberAfSetCommandEndpoints(int8u sourceEndpoint, int8u destinationEndpoint)
    317          {
    318            emAfCommandApsFrame->sourceEndpoint = sourceEndpoint;
   \                     emberAfSetCommandEndpoints:
   \   00000000   0x....             LDR.N    R2,??DataTable11
   \   00000002   0x68D3             LDR      R3,[R2, #+12]
   \   00000004   0x7118             STRB     R0,[R3, #+4]
    319            emAfCommandApsFrame->destinationEndpoint = destinationEndpoint;
   \   00000006   0x68D0             LDR      R0,[R2, #+12]
   \   00000008   0x7141             STRB     R1,[R0, #+5]
    320          }
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     emAfZclBufferLen

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ERR: Buffer too short...">`:
   \   00000000   0x45 0x52          DC8 "ERR: Buffer too short for ZCL header"
   \              0x52 0x3A    
   \              0x20 0x42    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x5A 0x43    
   \              0x4C 0x20    
   \              0x68 0x65    
   \              0x61 0x64    
   \              0x65 0x72    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ERR: Unknown format \\'%c\\'">`:
   \   00000000   0x45 0x52          DC8 "ERR: Unknown format '%c'"
   \              0x52 0x3A    
   \              0x20 0x55    
   \              0x6E 0x6B    
   \              0x6E 0x6F    
   \              0x77 0x6E    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x6D 0x61    
   \              0x74 0x20    
   \              0x27 0x25    
   \              0x63 0x27    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ERR: Buffer too short...">_1`:
   \   00000000   0x45 0x52          DC8 45H, 52H, 52H, 3AH, 20H, 42H, 75H, 66H
   \              0x52 0x3A    
   \              0x20 0x42    
   \              0x75 0x66    
   \   00000008   0x66 0x65          DC8 66H, 65H, 72H, 20H, 74H, 6FH, 6FH, 20H
   \              0x72 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \   00000010   0x73 0x68          DC8 73H, 68H, 6FH, 72H, 74H, 20H, 66H, 6FH
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x66 0x6F    
   \   00000018   0x72 0x20          DC8 72H, 20H, 25H, 64H, 20H, 62H, 79H, 74H
   \              0x25 0x64    
   \              0x20 0x62    
   \              0x79 0x74    
   \   00000020   0x65 0x73          DC8 65H, 73H, 20H, 66H, 6FH, 72H, 20H, 66H
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x66    
   \   00000028   0x6F 0x72          DC8 6FH, 72H, 6DH, 61H, 74H, 20H, 27H, 25H
   \              0x6D 0x61    
   \              0x74 0x20    
   \              0x27 0x25    
   \   00000030   0x63 0x27          DC8 63H, 27H, 0
   \              0x00         
   \   00000033   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  emberAfFillBuffer
             24 -> vFillBuffer
       24  emberAfFillExternalBuffer
             24 -> vFillBuffer
       32  emberAfFillExternalManufacturerSpecificBuffer
             32 -> vFillBuffer
        0  emberAfGetCommandApsFrame
        0  emberAfSendCommandBroadcast
              0 -> emberAfSendCommandBroadcastWithCallback
       16  emberAfSendCommandBroadcastWithCallback
             16 -> emberAfSendBroadcastWithCallback
       32  emberAfSendCommandInterPan
             32 -> emberAfSendInterPan
        0  emberAfSendCommandMulticast
              0 -> emberAfSendCommandMulticastWithCallback
       16  emberAfSendCommandMulticastWithCallback
             16 -> emberAfSendMulticastWithCallback
        0  emberAfSendCommandUnicast
              0 -> emberAfSendCommandUnicastWithCallback
        0  emberAfSendCommandUnicastToBindings
              0 -> emberAfSendCommandUnicastToBindingsWithCallback
        8  emberAfSendCommandUnicastToBindingsWithCallback
              0 -> emberAfSendUnicastToBindingsWithCallback
       16  emberAfSendCommandUnicastWithCallback
             16 -> emberAfSendUnicastWithCallback
        0  emberAfSetCommandEndpoints
        8  emberAfSetExternalBuffer
       48  vFillBuffer
             48 -> emberAfLongStringLength
             48 -> emberAfNextSequence
             48 -> emberAfPrintln
             48 -> emberAfStringLength
             48 -> halCommonMemCopy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      40  ?<Constant "ERR: Buffer too short...">
      52  ?<Constant "ERR: Buffer too short...">_1
      28  ?<Constant "ERR: Unknown format \'%c\'">
       4  ??DataTable11
      14  ?Subroutine0
      16  emAfZclBufferLen
          emAfZclBuffer
          emAfResponseLengthPtr
          emAfCommandApsFrame
      20  emberAfFillBuffer
      42  emberAfFillExternalBuffer
      48  emberAfFillExternalManufacturerSpecificBuffer
       6  emberAfGetCommandApsFrame
       4  emberAfSendCommandBroadcast
      14  emberAfSendCommandBroadcastWithCallback
      34  emberAfSendCommandInterPan
       4  emberAfSendCommandMulticast
      14  emberAfSendCommandMulticastWithCallback
       4  emberAfSendCommandUnicast
       4  emberAfSendCommandUnicastToBindings
      22  emberAfSendCommandUnicastToBindingsWithCallback
      22  emberAfSendCommandUnicastWithCallback
      12  emberAfSetCommandEndpoints
      14  emberAfSetExternalBuffer
     352  vFillBuffer

 
  16 bytes in section .bss
 754 bytes in section .text
 
 754 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
