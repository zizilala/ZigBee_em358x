###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     04/Feb/2015  16:38:20 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\util #
#                    .c                                                       #
#    Command line =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\util #
#                    .c -D "GENERATED_TOKEN_HEADER=\"app/builder/DoorSensor_S #
#                    M6011/DoorSensor_SM6011_tokens.h\"" -D                   #
#                    "ZA_GENERATED_HEADER=\"app/builder/DoorSensor_SM6011/Doo #
#                    rSensor_SM6011.h\"" -D LOCAL_STORAGE_BTL -D              #
#                    "BOARD_HEADER=\"app\builder\DoorSensor_SM6011\DoorSensor #
#                    _SM6011_board.h\"" -D "PLATFORM_HEADER=\"hal/micro/corte #
#                    xm3/compiler/iar.h\"" -D CORTEXM3 -D                     #
#                    CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3585 -D PHY_EM3XX -D  #
#                    "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\ #
#                    "" -D "CONFIGURATION_HEADER=\"app/framework/util/config. #
#                    h\"" -D "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/D #
#                    oorSensor_SM6011/DoorSensor_SM6011_endpoint_config.h\""  #
#                    -D "__SOURCEFILE__=\"util.c\"" -lC                       #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \ --diag_suppress Pa050 -o C:\Ember\EmberZNet5.3.0-GA\em #
#                    35x\build\DoorSensor_SM6011\ --debug --endian=little     #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\ -I  #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\ #
#                    DoorSensor_SM6011\..\..\..\ -I                           #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\app\framework\include\ -I                #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app #
#                    \builder\DoorSensor_SM6011\..\..\..\stack\ -I            #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\hal\ -I C:\Ember\EmberZNet5.3.0-GA\em35x #
#                    \app\builder\DoorSensor_SM6011\..\..\..\hal\..\ -Ohz     #
#                    --use_c++_inline                                         #
#    List file    =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \util.lst                                                #
#    Object file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \util.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\util\util.c
      1          // *******************************************************************
      2          // * util.c
      3          // *
      4          // * This file contains all of the common ZCL command and attribute handling 
      5          // * code for Ember's ZCL implementation
      6          // *
      7          // * The actual compiled version of this code will vary depending on
      8          // * #defines for clusters included in the built application.
      9          // *
     10          // * Copyright 2014 Silicon Laboratories, Inc.                              *80*
     11          // *******************************************************************
     12          
     13          
     14          #include "../include/af.h"
     15          #include "af-main.h"
     16          #include "common.h"
     17          #include "../security/crypto-state.h"
     18          #include "../plugin/time-server/time-server.h"
     19          #include "../../util/source-route-common.h"
     20          
     21          #include "app/framework/util/af-event.h"
     22          
     23          //------------------------------------------------------------------------------
     24          // Forward Declarations
     25          
     26          static void platformTick(void);
     27          
     28          #ifdef EMBER_AF_HEARTBEAT_ENABLE
     29            #define blinkHeartbeat() halToggleLed(EMBER_AF_HEARTBEAT_LED)
     30          #else
     31            #define blinkHeartbeat()
     32          #endif 
     33          
     34          //------------------------------------------------------------------------------
     35          // Globals
     36          
     37          // Storage and functions for turning on and off devices

   \                                 In section .bss, align 1
     38          boolean afDeviceEnabled[MAX_ENDPOINT_COUNT];
   \                     afDeviceEnabled:
   \   00000000                      DS8 1
     39          
     40          #ifdef EMBER_AF_ENABLE_STATISTICS
     41          // a variable containing the number of messages send from the utilities
     42          // since emberAfInit was called.
     43          int32u afNumPktsSent;
     44          #endif
     45          

   \                                 In section .text, align 4, keep-with-next
     46          PGM EmberAfClusterName zclClusterNames[] = {
   \                     zclClusterNames:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 `?<Constant "Basic">`
   \   00000008   0x0003             DC16 3
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x........         DC32 `?<Constant "Identify">`
   \   00000010   0x0019             DC16 25
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x........         DC32 `?<Constant "Over the Air Bootloading">`
   \   00000018   0x0500             DC16 1280
   \   0000001A   0x00 0x00          DC8 0, 0
   \   0000001C   0x........         DC32 `?<Constant "IAS Zone">`
   \   00000020   0xFFFF             DC16 65535
   \   00000022   0x00 0x00          DC8 0, 0
   \   00000024   0x00000000         DC32 0H
     47            CLUSTER_IDS_TO_NAMES                 // defined in print-cluster.h
     48            { ZCL_NULL_CLUSTER_ID, NULL },  // terminator
     49          };
     50          
     51          // A pointer to the current command being processed
     52          // This struct is allocated on the stack inside
     53          // emberAfProcessMessage. The pointer below is set
     54          // to NULL when the function exits.
     55          EmberAfClusterCommand *emAfCurrentCommand;
     56          
     57          // variable used for turning off Aps Link security. Set by the CLI 

   \                                 In section .bss, align 1
     58          boolean emAfApsSecurityOff = FALSE;
   \                     emAfApsSecurityOff:
   \   00000000                      DS8 1
     59          
     60          // DEPRECATED.
     61          int8u emberAfIncomingZclSequenceNumber = 0xFF;
     62          

   \                                 In section .bss, align 1
   \   00000000                      DS8 1
     63          static boolean afNoSecurityForDefaultResponse = FALSE;
     64          
     65          // Sequence used for outgoing messages if they are
     66          // not responses.
     67          int8u emberAfSequenceNumber = 0xFF;
     68          
     69          // A boolean value so we know when the device is performing
     70          // key establishment.

   \                                 In section .bss, align 1
     71          boolean emAfDeviceIsPerformingKeyEstablishment = FALSE;
   \                     emAfDeviceIsPerformingKeyEstablishment:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
   \                     emberAfIncomingZclSequenceNumber:
   \   00000000   0xFF               DC8 255
     72          
     73          int8u emberAfApsRetryOverride = EMBER_AF_RETRY_OVERRIDE_NONE;
   \                     emberAfApsRetryOverride:
   \   00000001   0x00               DC8 0
     74          
     75          // Holds the response type
     76          int8u emberAfResponseType = ZCL_UTIL_RESP_NORMAL;
   \                     emberAfResponseType:
   \   00000002   0x00               DC8 0
   \   00000003   0x00               DC8 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     emAfCurrentCommand:
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 1
   \                     emberAfSequenceNumber:
   \   00000000   0xFF               DC8 255
     77          
     78          static EmberAfInterpanHeader interpanResponseHeader;
     79          
     80          #if EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE != 0

   \                                 In section .bss, align 2
     81            static int8u addressTableReferenceCounts[EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE];
   \                     addressTableReferenceCounts:
   \   00000000                      DS8 2
     82          #endif
     83          
     84          #define SECONDS_IN_DAY 86400L
     85          #define SECONDS_IN_HOUR 3600

   \                                 In section .text, align 4, keep-with-next
     86          PGM int8u emberAfDaysInMonth[] =
   \                     emberAfDaysInMonth:
   \   00000000   0x1F 0x1C          DC8 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
   \              0x1F 0x1E    
   \              0x1F 0x1E    
   \              0x1F 0x1F    
   \              0x1E 0x1F    
   \              0x1E 0x1F    
     87            { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
     88          

   \                                 In section .text, align 4, keep-with-next
     89          static PGM int8u emberAfAnalogDiscreteThresholds[] = {
   \                     emberAfAnalogDiscreteThresholds:
   \   00000000   0x07 0x02          DC8 7, 2, 31, 1, 47, 0, 55, 1, 63, 0, 87, 1, 223, 2, 231, 0, 255, 2
   \              0x1F 0x01    
   \              0x2F 0x00    
   \              0x37 0x01    
   \              0x3F 0x00    
   \              0x57 0x01    
   \              0xDF 0x02    
   \              0xE7 0x00    
   \              0xFF 0x02    
   \   00000012   0x00 0x00          DC8 0, 0
     90            0x07, EMBER_AF_DATA_TYPE_NONE,
     91            0x1F, EMBER_AF_DATA_TYPE_DISCRETE,
     92            0x2F, EMBER_AF_DATA_TYPE_ANALOG,
     93            0x37, EMBER_AF_DATA_TYPE_DISCRETE,
     94            0x3F, EMBER_AF_DATA_TYPE_ANALOG,
     95            0x57, EMBER_AF_DATA_TYPE_DISCRETE,
     96            0xDF, EMBER_AF_DATA_TYPE_NONE,
     97            0xE7, EMBER_AF_DATA_TYPE_ANALOG,
     98            0xFF, EMBER_AF_DATA_TYPE_NONE 
     99          };
    100          
    101          typedef void (TickFunction)(void);
    102          

   \                                 In section .text, align 4, keep-with-next
    103          static TickFunction* PGM internalTickFunctions[] = {
   \                     internalTickFunctions:
   \   00000000   0x........         DC32 emberAfMainTickCallback, platformTick, 0H
   \              0x........   
   \              0x00000000   
    104            // This is the main customer tick
    105            emberAfMainTickCallback,
    106          
    107            platformTick,
    108          
    109            NULL            // terminator, must be last
    110          };
    111          
    112          #ifdef EMBER_AF_GENERATED_PLUGIN_INIT_FUNCTION_DECLARATIONS
    113            EMBER_AF_GENERATED_PLUGIN_INIT_FUNCTION_DECLARATIONS
    114          #endif
    115          
    116          //------------------------------------------------------------------------------
    117          

   \                                 In section .text, align 2, keep-with-next
    118          static void platformTick(void)
    119          {
   \                     platformTick:
   \   00000000   0xB580             PUSH     {R7,LR}
    120            static int16u lastBlinkTime = 0;
    121            int16u time;
    122          
    123            emberAfSchedulePollEventCallback();
   \   00000002   0x.... 0x....      BL       emberAfSchedulePollEventCallback
    124            emberAfCheckForSleepCallback();
   \   00000006   0x.... 0x....      BL       emberAfCheckForSleepCallback
    125          
    126            time = halCommonGetInt16uMillisecondTick();
   \   0000000A   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
    127          
    128            if (elapsedTimeInt16u(lastBlinkTime, time) > 200 /*ms*/) {
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable53
   \   00000012   0x880A             LDRH     R2,[R1, #+0]
   \   00000014   0x1A82             SUBS     R2,R0,R2
   \   00000016   0xB292             UXTH     R2,R2
   \   00000018   0x2AC9             CMP      R2,#+201
   \   0000001A   0xBF28             IT       CS 
   \   0000001C   0x8008             STRHCS   R0,[R1, #+0]
    129              blinkHeartbeat();
    130              lastBlinkTime = time;
    131            }
    132          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 2
   \                     ??lastBlinkTime:
   \   00000000                      DS8 2
    133          
    134          // Device enabled/disabled functions

   \                                 In section .text, align 2, keep-with-next
    135          boolean emberAfIsDeviceEnabled(int8u endpoint)
    136          {
   \                     emberAfIsDeviceEnabled:
   \   00000000   0xB580             PUSH     {R7,LR}
    137            int8u index;
    138          #ifdef ZCL_USING_BASIC_CLUSTER_DEVICE_ENABLED_ATTRIBUTE
    139            boolean deviceEnabled;
    140            if (emberAfReadServerAttribute(endpoint,
    141                                           ZCL_BASIC_CLUSTER_ID,
    142                                           ZCL_DEVICE_ENABLED_ATTRIBUTE_ID,
    143                                           (int8u *)&deviceEnabled,
    144                                           sizeof(deviceEnabled))
    145                == EMBER_ZCL_STATUS_SUCCESS) {
    146              return deviceEnabled;
    147            }
    148          #endif
    149            index = emberAfIndexFromEndpoint(endpoint);
   \   00000002   0x.... 0x....      BL       emberAfIndexFromEndpoint
    150            if (index != 0xFF && index < sizeof(afDeviceEnabled)) {
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD004             BEQ.N    ??emberAfIsDeviceEnabled_0
   \   0000000A   0xB918             CBNZ.N   R0,??emberAfIsDeviceEnabled_0
    151              return afDeviceEnabled[index];
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xBD02             POP      {R1,PC}
    152            }
    153            return FALSE;
   \                     ??emberAfIsDeviceEnabled_0:
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    154          }
    155          

   \                                 In section .text, align 2, keep-with-next
    156          void emberAfSetDeviceEnabled(int8u endpoint, boolean enabled)
    157          {
   \                     emberAfSetDeviceEnabled:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    158            int8u index = emberAfIndexFromEndpoint(endpoint);
   \   00000004   0x.... 0x....      BL       emberAfIndexFromEndpoint
    159            if (index != 0xFF && index < sizeof(afDeviceEnabled)) {
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xD003             BEQ.N    ??emberAfSetDeviceEnabled_0
   \   0000000C   0xB910             CBNZ.N   R0,??emberAfSetDeviceEnabled_0
    160              afDeviceEnabled[index] = enabled;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \   00000012   0x7004             STRB     R4,[R0, #+0]
    161            }
    162          #ifdef ZCL_USING_BASIC_CLUSTER_DEVICE_ENABLED_ATTRIBUTE
    163            emberAfWriteServerAttribute(endpoint,
    164                                        ZCL_BASIC_CLUSTER_ID,
    165                                        ZCL_DEVICE_ENABLED_ATTRIBUTE_ID,
    166                                        (int8u *)&enabled,
    167                                        ZCL_BOOLEAN_ATTRIBUTE_TYPE);
    168          #endif
    169          }
   \                     ??emberAfSetDeviceEnabled_0:
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    170          
    171          // Is the device identifying?

   \                                 In section .text, align 2, keep-with-next
    172          boolean emberAfIsDeviceIdentifying(int8u endpoint)
    173          {
   \                     emberAfIsDeviceIdentifying:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    174          #ifdef ZCL_USING_IDENTIFY_CLUSTER_SERVER
    175            int16u identifyTime;
    176            EmberAfStatus status = emberAfReadServerAttribute(endpoint,
    177                                                              ZCL_IDENTIFY_CLUSTER_ID,
    178                                                              ZCL_IDENTIFY_TIME_ATTRIBUTE_ID,
    179                                                              (int8u *)&identifyTime,
    180                                                              sizeof(identifyTime));
    181            return (status == EMBER_ZCL_STATUS_SUCCESS && 0 < identifyTime);
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x9100             STR      R1,[SP, #+0]
   \   00000008   0xAB01             ADD      R3,SP,#+4
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2103             MOVS     R1,#+3
   \   0000000E   0x.... 0x....      BL       emberAfReadServerAttribute
   \   00000012   0xB920             CBNZ.N   R0,??emberAfIsDeviceIdentifying_0
   \   00000014   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000018   0xB110             CBZ.N    R0,??emberAfIsDeviceIdentifying_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE000             B.N      ??emberAfIsDeviceIdentifying_1
   \                     ??emberAfIsDeviceIdentifying_0:
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??emberAfIsDeviceIdentifying_1:
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
    182          #else
    183            return FALSE;
    184          #endif
    185          }
    186          
    187          
    188          // Calculates difference. Works only for dataSizes of 4 or less.

   \                                 In section .text, align 2, keep-with-next
    189          int32u emberAfGetDifference(int8u *pData, int32u value, int8u dataSize) 
    190          {
   \                     emberAfGetDifference:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    191            int32u value2 = 0, diff;
   \   00000002   0x2300             MOVS     R3,#+0
    192            int8u i;
    193          
    194            // only support data types up to 4 bytes
    195            if (dataSize > 4) {
   \   00000004   0x2A05             CMP      R2,#+5
   \   00000006   0xD301             BCC.N    ??emberAfGetDifference_0
    196              return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD30             POP      {R4,R5,PC}
    197            }
    198          
    199            // get the 32-bit value
    200            for (i = 0; i < dataSize; i++) {
   \                     ??emberAfGetDifference_0:
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE006             B.N      ??emberAfGetDifference_1
    201              value2 = value2 << 8;
    202          #if (BIGENDIAN_CPU)
    203              value2 += pData[i];
    204          #else //BIGENDIAN
    205              value2 += pData[dataSize - i - 1];
   \                     ??emberAfGetDifference_2:
   \   00000010   0x1B15             SUBS     R5,R2,R4
   \   00000012   0x182D             ADDS     R5,R5,R0
   \   00000014   0xF815 0x5C01      LDRB     R5,[R5, #-1]
   \   00000018   0xEB05 0x2303      ADD      R3,R5,R3, LSL #+8
    206          #endif //BIGENDIAN
    207            }
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   \                     ??emberAfGetDifference_1:
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x4294             CMP      R4,R2
   \   00000022   0xD3F5             BCC.N    ??emberAfGetDifference_2
    208          
    209            if (value > value2) {
   \   00000024   0x428B             CMP      R3,R1
   \   00000026   0xD201             BCS.N    ??emberAfGetDifference_3
    210              diff = value - value2; 
   \   00000028   0x1AC8             SUBS     R0,R1,R3
   \   0000002A   0xBD30             POP      {R4,R5,PC}
    211            } else {
    212              diff = value2 - value; 
   \                     ??emberAfGetDifference_3:
   \   0000002C   0x1A58             SUBS     R0,R3,R1
    213            }
    214          
    215            //emberAfDebugPrintln("comparing 0x%4x and 0x%4x, diff is 0x%4x",
    216            //                    value, value2, diff);
    217            
    218            return diff;
   \   0000002E   0xBD30             POP      {R4,R5,PC}       ;; return
    219          }
    220          
    221          // --------------------------------------------------
    222          

   \                                 In section .text, align 2, keep-with-next
    223          static void prepareForResponse(const EmberAfClusterCommand *cmd)
    224          {
   \                     prepareForResponse:
   \   00000000   0xB510             PUSH     {R4,LR}
    225            emberAfResponseApsFrame.profileId           = cmd->apsFrame->profileId;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable53_2
   \   00000008   0x880B             LDRH     R3,[R1, #+0]
   \   0000000A   0x8013             STRH     R3,[R2, #+0]
    226            emberAfResponseApsFrame.clusterId           = cmd->apsFrame->clusterId;
   \   0000000C   0x884B             LDRH     R3,[R1, #+2]
   \   0000000E   0x8053             STRH     R3,[R2, #+2]
    227            emberAfResponseApsFrame.sourceEndpoint      = cmd->apsFrame->destinationEndpoint;
   \   00000010   0x7949             LDRB     R1,[R1, #+5]
   \   00000012   0x7111             STRB     R1,[R2, #+4]
    228            emberAfResponseApsFrame.destinationEndpoint = cmd->apsFrame->sourceEndpoint;
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x7909             LDRB     R1,[R1, #+4]
   \   00000018   0x7151             STRB     R1,[R2, #+5]
    229          
    230            // Use the default APS options for the response, but also use encryption and
    231            // retries if the incoming message used them.  The rationale is that the
    232            // sender of the request cares about some aspects of the delivery, so we as
    233            // the receiver should make equal effort for the response.
    234            emberAfResponseApsFrame.options = EMBER_AF_DEFAULT_APS_OPTIONS;
   \   0000001A   0xF44F 0x518A      MOV      R1,#+4416
   \   0000001E   0x80D1             STRH     R1,[R2, #+6]
    235            if (cmd->apsFrame->options & EMBER_APS_OPTION_ENCRYPTION) {
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x7989             LDRB     R1,[R1, #+6]
   \   00000024   0x0689             LSLS     R1,R1,#+26
   \   00000026   0xBF44             ITT      MI 
   \   00000028   0xF44F 0x518B      MOVMI    R1,#+4448
   \   0000002C   0x80D1             STRHMI   R1,[R2, #+6]
    236              emberAfResponseApsFrame.options |= EMBER_APS_OPTION_ENCRYPTION;
    237            }
    238            if (cmd->apsFrame->options & EMBER_APS_OPTION_RETRY) {
    239              emberAfResponseApsFrame.options |= EMBER_APS_OPTION_RETRY;
    240            }
    241          
    242            if (cmd->interPanHeader == NULL) {
   \   0000002E   0x.... 0x....      LDR.W    R4,??DataTable53_3
   \   00000032   0x78A1             LDRB     R1,[R4, #+2]
   \   00000034   0x6982             LDR      R2,[R0, #+24]
   \   00000036   0xB93A             CBNZ.N   R2,??prepareForResponse_0
    243              emberAfResponseDestination = cmd->source;
   \   00000038   0x88C0             LDRH     R0,[R0, #+6]
   \   0000003A   0x.... 0x....      LDR.W    R2,??DataTable53_4
   \   0000003E   0x8010             STRH     R0,[R2, #+0]
    244              emberAfResponseType &= ~ZCL_UTIL_RESP_INTERPAN;
   \   00000040   0xF001 0x00FD      AND      R0,R1,#0xFD
   \   00000044   0x70A0             STRB     R0,[R4, #+2]
   \   00000046   0xBD10             POP      {R4,PC}
    245            } else {
    246              emberAfResponseType |= ZCL_UTIL_RESP_INTERPAN;
   \                     ??prepareForResponse_0:
   \   00000048   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000004C   0x70A1             STRB     R1,[R4, #+2]
    247              MEMCOPY(&interpanResponseHeader, 
    248                      cmd->interPanHeader, 
    249                      sizeof(EmberAfInterpanHeader));
   \   0000004E   0x2216             MOVS     R2,#+22
   \   00000050   0x6981             LDR      R1,[R0, #+24]
   \   00000052   0x1D20             ADDS     R0,R4,#+4
   \   00000054   0x.... 0x....      BL       halCommonMemCopy
    250              // Always send responses as unicast
    251              interpanResponseHeader.messageType = EMBER_AF_INTER_PAN_UNICAST;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x7120             STRB     R0,[R4, #+4]
    252            }
    253          }
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    254          
    255          // ****************************************
    256          // Initialize Clusters
    257          // ****************************************

   \                                 In section .text, align 2, keep-with-next
    258          void emberAfInit(void) 
    259          {
   \                     emberAfInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    260            int8u i;
    261          #ifdef EMBER_AF_ENABLE_STATISTICS  
    262            afNumPktsSent = 0;
    263          #endif
    264          
    265            for (i = 0; i < EMBER_SUPPORTED_NETWORKS; i++) {
    266              emberAfPushNetworkIndex(i);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       emberAfPushNetworkIndex
    267              emberAfInitializeAttributes(EMBER_BROADCAST_ENDPOINT);
   \   00000008   0x20FF             MOVS     R0,#+255
   \   0000000A   0x.... 0x....      BL       emberAfInitializeAttributes
    268              emberAfPopNetworkIndex();
   \   0000000E   0x.... 0x....      BL       emberAfPopNetworkIndex
    269            }
    270          
    271            MEMSET(afDeviceEnabled, TRUE, emberAfEndpointCount());
   \   00000012   0x.... 0x....      BL       emberAfEndpointCount
   \   00000016   0x4602             MOV      R2,R0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \   0000001E   0x.... 0x....      BL       halCommonMemSet
    272          
    273            // Set up client API buffer.
    274            emberAfSetExternalBuffer(appResponseData,
    275                                     EMBER_AF_RESPONSE_BUFFER_LEN,
    276                                     &appResponseLength,
    277                                     &emberAfResponseApsFrame);
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable53_2
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable53_5
   \   0000002A   0x2152             MOVS     R1,#+82
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable53_6
   \   00000030   0x.... 0x....      BL       emberAfSetExternalBuffer
    278          
    279           // initialize event management system
    280           emAfInitEvents();
   \   00000034   0x.... 0x....      BL       emAfInitEvents
    281          
    282          #ifdef EMBER_AF_GENERATED_PLUGIN_INIT_FUNCTION_CALLS
    283            EMBER_AF_GENERATED_PLUGIN_INIT_FUNCTION_CALLS
   \   00000038   0x.... 0x....      BL       emberAfPluginAddressTableInitCallback
   \   0000003C   0x.... 0x....      BL       emberAfPluginBatteryMonitorInitCallback
   \   00000040   0x.... 0x....      BL       emberAfPluginCountersInitCallback
   \   00000044   0x.... 0x....      BL       emberAfPluginEndDeviceSupportInitCallback
   \   00000048   0x.... 0x....      BL       emberAfPluginNetworkFindInitCallback
   \   0000004C   0x.... 0x....      BL       emberAfPluginReportingInitCallback
   \   00000050   0x.... 0x....      BL       emberAfPluginSensorIfaceInitCallback
    284          #endif
    285          
    286            emAfCallInits();
   \   00000054   0xE8BD 0x4001      POP      {R0,LR}
   \   00000058   0x.... 0x....      B.W      emAfCallInits
    287          }
    288          

   \                                 In section .text, align 2, keep-with-next
    289          void emberAfTick(void) 
    290          {
   \                     emberAfTick:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    291            int8u i = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x.... 0x....      ADR.W    R5,internalTickFunctions
   \   00000008   0xE001             B.N      ??emberAfTick_0
    292          
    293            while (internalTickFunctions[i] != NULL) {
    294              if (emAfIsCryptoOperationInProgress()) {
    295                // Wait until ECC operations are done.  Don't allow
    296                // any of the clusters to send messages.  This is necessary
    297                // on host or SOC application.
    298                return;
    299              }
    300          
    301              (internalTickFunctions[i])();
   \                     ??emberAfTick_1:
   \   0000000A   0x47B0             BLX      R6
    302              i++;
   \   0000000C   0x1C64             ADDS     R4,R4,#+1
   \                     ??emberAfTick_0:
   \   0000000E   0xB2E4             UXTB     R4,R4
   \   00000010   0xF855 0x6024      LDR      R6,[R5, R4, LSL #+2]
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xD003             BEQ.N    ??emberAfTick_2
   \   00000018   0x.... 0x....      BL       emAfGetCryptoStatus
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD1F4             BNE.N    ??emberAfTick_1
   \                     ??emberAfTick_2:
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    303            }
    304          }
    305          
    306          // ****************************************
    307          // This function is called by the application when the stack goes down,
    308          // such as after a leave network. This allows zcl utils to clear state 
    309          // that should not be kept when changing networks
    310          // ****************************************

   \                                 In section .text, align 2, keep-with-next
    311          void emberAfStackDown(void)
    312          {
   \                     emberAfStackDown:
   \   00000000   0xB580             PUSH     {R7,LR}
    313            // (Case 14696) Clearing the report table is only necessary if the stack is
    314            // going down for good; if we're rejoining, leave the table intact since we'll
    315            // be right back, hopefully.
    316            // (Issue 77101) Also don't clear the table if the stack has gone down as a 
    317            // a result of losing its parent or some other transient state where a future
    318            // rejoin is expected to get us back online.
    319            if (emberStackIsPerformingRejoin() == FALSE
    320              && emberNetworkState() == EMBER_NO_NETWORK) {
   \   00000002   0x.... 0x....      BL       emberStackIsPerformingRejoin
   \   00000006   0xB920             CBNZ.N   R0,??emberAfStackDown_0
   \   00000008   0x.... 0x....      BL       emberNetworkState
   \   0000000C   0xB908             CBNZ.N   R0,??emberAfStackDown_0
    321              // the report table should be cleared when the stack comes down. 
    322              // going to a new network means new report devices should be discovered.
    323              // if the table isnt cleared the device keeps trying to send messages.
    324              emberAfClearReportTableCallback();
   \   0000000E   0x.... 0x....      BL       emberAfClearReportTableCallback
    325            }
    326          
    327            emberAfRegistrationAbortCallback();
   \                     ??emberAfStackDown_0:
   \   00000012   0x.... 0x....      BL       emberAfRegistrationAbortCallback
    328            emberAfTrustCenterKeepaliveAbortCallback();
   \   00000016   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001A   0x.... 0x....      B.W      emberAfTrustCenterKeepaliveAbortCallback
    329          }
    330          
    331          // ****************************************
    332          // Print out information about each cluster
    333          // ****************************************
    334          

   \                                 In section .text, align 2, keep-with-next
    335          int16u emberAfFindClusterNameIndex(int16u cluster)
    336          {
   \                     emberAfFindClusterNameIndex:
   \   00000000   0xB510             PUSH     {R4,LR}
    337            int16u index = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000008   0x.... 0x....      ADR.W    R3,zclClusterNames
   \   0000000C   0xE000             B.N      ??emberAfFindClusterNameIndex_0
    338            while (zclClusterNames[index].id != ZCL_NULL_CLUSTER_ID) {
    339              if (zclClusterNames[index].id == cluster) {
    340                return index;
    341              }
    342              index++;
   \                     ??emberAfFindClusterNameIndex_1:
   \   0000000E   0x1C52             ADDS     R2,R2,#+1
   \                     ??emberAfFindClusterNameIndex_0:
   \   00000010   0xB292             UXTH     R2,R2
   \   00000012   0xF833 0x4032      LDRH     R4,[R3, R2, LSL #+3]
   \   00000016   0x428C             CMP      R4,R1
   \   00000018   0xD003             BEQ.N    ??emberAfFindClusterNameIndex_2
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD1F7             BNE.N    ??emberAfFindClusterNameIndex_1
   \   0000001E   0x4610             MOV      R0,R2
   \   00000020   0xBD10             POP      {R4,PC}
    343            }  
    344            return 0xFFFF;
   \                     ??emberAfFindClusterNameIndex_2:
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    345          }
    346          

   \                                 In section .text, align 2, keep-with-next
    347          void emberAfDecodeAndPrintCluster(int16u cluster)
    348          {
   \                     emberAfDecodeAndPrintCluster:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    349            int16u index = emberAfFindClusterNameIndex(cluster);
   \   00000004   0x.... 0x....      BL       emberAfFindClusterNameIndex
   \   00000008   0x4601             MOV      R1,R0
    350            if (index == 0xFFFF) { 
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable53_7
   \   0000000E   0x8828             LDRH     R0,[R5, #+0]
   \   00000010   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD103             BNE.N    ??emberAfDecodeAndPrintCluster_0
    351              emberAfPrint(emberAfPrintActiveArea,
    352                           "(Unknown clus. [0x%2x])", 
    353                           cluster);
   \   00000018   0x4622             MOV      R2,R4
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "(Unknown clus. [0x%2x])">`
   \   0000001E   0xE006             B.N      ??emberAfDecodeAndPrintCluster_1
    354            } else {
    355              emberAfPrint(emberAfPrintActiveArea, 
    356                           "(%p)", 
    357                           zclClusterNames[index].name);
   \                     ??emberAfDecodeAndPrintCluster_0:
   \   00000020   0x.... 0x....      ADR.W    R2,zclClusterNames
   \   00000024   0xEB02 0x01C1      ADD      R1,R2,R1, LSL #+3
   \   00000028   0x684A             LDR      R2,[R1, #+4]
   \   0000002A   0x.... 0x....      ADR.W    R1,`?<Constant "(%p)">`
   \                     ??emberAfDecodeAndPrintCluster_1:
   \   0000002E   0x.... 0x....      BL       emberAfPrint
    358            }
    359            emberAfFlush(emberAfPrintActiveArea);
   \   00000032   0x8828             LDRH     R0,[R5, #+0]
   \   00000034   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000038   0x.... 0x....      B.W      emberAfFlush
    360          }
    361          

   \                                 In section .text, align 2, keep-with-next
    362          static void printIncomingZclMessage(const EmberAfClusterCommand *cmd)
    363          {
   \                     printIncomingZclMessage:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    364          #if defined(EMBER_AF_PRINT_ENABLE) && defined(EMBER_AF_PRINT_APP)
    365            if (emberAfPrintReceivedMessages) {
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable53_8
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD03B             BEQ.N    ??printIncomingZclMessage_0
    366              emberAfAppPrint("\r\nT%4x:", emberAfGetCurrentTime());
   \   00000010   0x.... 0x....      BL       emberAfGetCurrentTimeCallback
   \   00000014   0x4602             MOV      R2,R0
   \   00000016   0x.... 0x....      ADR.W    R1,`?<Constant "\\r\\nT%4x:">`
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0x.... 0x....      BL       emberAfPrint
    367              emberAfAppPrint("RX len %d, ep %x, clus 0x%2x ",
    368                              cmd->bufLen,
    369                              cmd->apsFrame->destinationEndpoint,
    370                              cmd->apsFrame->clusterId);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x8841             LDRH     R1,[R0, #+2]
   \   00000024   0x9100             STR      R1,[SP, #+0]
   \   00000026   0x7943             LDRB     R3,[R0, #+5]
   \   00000028   0x89A2             LDRH     R2,[R4, #+12]
   \   0000002A   0x.... 0x....      ADR.W    R1,`?<Constant "RX len %d, ep %x, clu...">`
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x.... 0x....      BL       emberAfPrint
    371              emberAfAppDebugExec(emberAfDecodeAndPrintCluster(cmd->apsFrame->clusterId));
   \   00000034   0x2004             MOVS     R0,#+4
   \   00000036   0x.... 0x....      BL       emberAfPrintEnabled
   \   0000003A   0xB118             CBZ.N    R0,??printIncomingZclMessage_1
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x8840             LDRH     R0,[R0, #+2]
   \   00000040   0x.... 0x....      BL       emberAfDecodeAndPrintCluster
    372              if (cmd->mfgSpecific) {
   \                     ??printIncomingZclMessage_1:
   \   00000044   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000046   0xB128             CBZ.N    R0,??printIncomingZclMessage_2
    373                emberAfAppPrint(" mfgId %2x", cmd->mfgCode);
   \   00000048   0x8A22             LDRH     R2,[R4, #+16]
   \   0000004A   0x.... 0x....      ADR.W    R1,`?<Constant " mfgId %2x">`
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x.... 0x....      BL       emberAfPrint
    374              }
    375              emberAfAppPrint(" FC %x seq %x cmd %x payload[",
    376                              cmd->buffer[0], // frame control
    377                              cmd->seqNum,
    378                              cmd->commandId);
   \                     ??printIncomingZclMessage_2:
   \   00000054   0x7CE0             LDRB     R0,[R4, #+19]
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0x7CA3             LDRB     R3,[R4, #+18]
   \   0000005A   0x68A0             LDR      R0,[R4, #+8]
   \   0000005C   0x7802             LDRB     R2,[R0, #+0]
   \   0000005E   0x.... 0x....      ADR.W    R1,`?<Constant " FC %x seq %x cmd %x ...">`
   \   00000062   0x2004             MOVS     R0,#+4
   \   00000064   0x.... 0x....      BL       emberAfPrint
    379              emberAfAppFlush();
    380              emberAfAppPrintBuffer(cmd->buffer + cmd->payloadStartIndex, // message
    381                                    cmd->bufLen - cmd->payloadStartIndex, // length
    382                                    TRUE);                                // spaces?
   \   00000068   0x7D20             LDRB     R0,[R4, #+20]
   \   0000006A   0x2301             MOVS     R3,#+1
   \   0000006C   0x89A1             LDRH     R1,[R4, #+12]
   \   0000006E   0x1A0A             SUBS     R2,R1,R0
   \   00000070   0xB292             UXTH     R2,R2
   \   00000072   0x68A1             LDR      R1,[R4, #+8]
   \   00000074   0x1841             ADDS     R1,R0,R1
   \   00000076   0x2004             MOVS     R0,#+4
   \   00000078   0x.... 0x....      BL       emberAfPrintBuffer
    383              emberAfAppFlush();
    384              emberAfAppPrintln("]");
   \   0000007C   0x....             ADR.N    R1,??DataTable45  ;; "]"
   \   0000007E   0x2004             MOVS     R0,#+4
   \   00000080   0xE8BD 0x401C      POP      {R2-R4,LR}
   \   00000084   0x.... 0x....      B.W      emberAfPrintln
    385            }
    386          #endif
    387          }
   \                     ??printIncomingZclMessage_0:
   \   00000088   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    388          

   \                                 In section .text, align 2, keep-with-next
    389          static boolean dispatchZclMessage(EmberAfClusterCommand *cmd)
    390          {
   \                     dispatchZclMessage:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    391            int8u index = emberAfIndexFromEndpoint(cmd->apsFrame->destinationEndpoint);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x7940             LDRB     R0,[R0, #+5]
   \   00000008   0x.... 0x....      BL       emberAfIndexFromEndpoint
    392            if (index == 0xFF) {
   \   0000000C   0x6822             LDR      R2,[R4, #+0]
   \   0000000E   0x.... 0x....      ADR.W    R5,`?<Constant "Drop cluster 0x%2x co...">`
   \   00000012   0x28FF             CMP      R0,#+255
   \   00000014   0xD10B             BNE.N    ??dispatchZclMessage_0
    393              emberAfDebugPrint("Drop cluster 0x%2x command 0x%x",
    394                                cmd->apsFrame->clusterId,
    395                                cmd->commandId);
   \   00000016   0x.... 0x....      BL       ?Subroutine3
    396              emberAfDebugPrint(" due to invalid endpoint: ");
   \                     ??CrossCallReturnLabel_12:
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant " due to invalid endpo...">`
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x.... 0x....      BL       emberAfPrint
    397              emberAfDebugPrintln("0x%x", cmd->apsFrame->destinationEndpoint);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x7942             LDRB     R2,[R0, #+5]
   \   00000028   0x.... 0x....      ADR.W    R1,`?<Constant "0x%x">`
   \   0000002C   0xE040             B.N      ??dispatchZclMessage_1
    398              return FALSE;
    399            } else if (emberAfNetworkIndexFromEndpointIndex(index) != cmd->networkIndex) {
   \                     ??dispatchZclMessage_0:
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable53_9
   \   00000032   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000036   0x.... 0x....      ADR.W    R6,`?<Constant " for endpoint 0x%x du...">`
   \   0000003A   0x7B01             LDRB     R1,[R0, #+12]
   \   0000003C   0x7F23             LDRB     R3,[R4, #+28]
   \   0000003E   0x4299             CMP      R1,R3
   \   00000040   0xD008             BEQ.N    ??dispatchZclMessage_2
    400              emberAfDebugPrint("Drop cluster 0x%2x command 0x%x",
    401                                cmd->apsFrame->clusterId,
    402                                cmd->commandId);
   \   00000042   0x.... 0x....      BL       ?Subroutine3
    403              emberAfDebugPrint(" for endpoint 0x%x due to wrong %p: ",
    404                                cmd->apsFrame->destinationEndpoint,
    405                                "network");
   \                     ??CrossCallReturnLabel_11:
   \   00000046   0x.... 0x....      ADR.W    R3,`?<Constant "network">`
   \   0000004A   0x.... 0x....      BL       ?Subroutine1
    406              emberAfDebugPrintln("%d", cmd->networkIndex);
   \                     ??CrossCallReturnLabel_6:
   \   0000004E   0x7F22             LDRB     R2,[R4, #+28]
   \   00000050   0x....             ADR.N    R1,??DataTable46  ;; 0x25, 0x64, 0x00, 0x00
   \   00000052   0xE02D             B.N      ??dispatchZclMessage_1
    407              return FALSE;
    408            } else if (emberAfProfileIdFromIndex(index) != cmd->apsFrame->profileId
    409                       && (cmd->apsFrame->profileId != EMBER_WILDCARD_PROFILE_ID
    410                           || (EMBER_MAXIMUM_STANDARD_PROFILE_ID
    411                               < emberAfProfileIdFromIndex(index)))) {
   \                     ??dispatchZclMessage_2:
   \   00000054   0x8840             LDRH     R0,[R0, #+2]
   \   00000056   0x8811             LDRH     R1,[R2, #+0]
   \   00000058   0x.... 0x....      ADR.W    R7,`?<Constant "0x%2x">`
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD00F             BEQ.N    ??dispatchZclMessage_3
   \   00000060   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000064   0x4299             CMP      R1,R3
   \   00000066   0xD102             BNE.N    ??dispatchZclMessage_4
   \   00000068   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000006C   0xD308             BCC.N    ??dispatchZclMessage_3
    412              emberAfDebugPrint("Drop cluster 0x%2x command 0x%x",
    413                                cmd->apsFrame->clusterId,
    414                                cmd->commandId);
   \                     ??dispatchZclMessage_4:
   \   0000006E   0x.... 0x....      BL       ?Subroutine3
    415              emberAfDebugPrint(" for endpoint 0x%x due to wrong %p: ",
    416                                cmd->apsFrame->destinationEndpoint,
    417                                "profile");
   \                     ??CrossCallReturnLabel_10:
   \   00000072   0x.... 0x....      ADR.W    R3,`?<Constant "profile">`
   \   00000076   0x.... 0x....      BL       ?Subroutine1
    418              emberAfDebugPrintln("0x%2x", cmd->apsFrame->profileId);
   \                     ??CrossCallReturnLabel_5:
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x8802             LDRH     R2,[R0, #+0]
   \   0000007E   0xE016             B.N      ??dispatchZclMessage_5
    419              return FALSE;
    420            } else if ((cmd->type == EMBER_INCOMING_MULTICAST
    421                        || cmd->type == EMBER_INCOMING_MULTICAST_LOOPBACK)
    422                       && !emberAfGroupsClusterEndpointInGroupCallback(cmd->apsFrame->destinationEndpoint,
    423                                                                       cmd->apsFrame->groupId)) {
   \                     ??dispatchZclMessage_3:
   \   00000080   0x7920             LDRB     R0,[R4, #+4]
   \   00000082   0x2802             CMP      R0,#+2
   \   00000084   0xBF18             IT       NE 
   \   00000086   0x2803             CMPNE    R0,#+3
   \   00000088   0xD117             BNE.N    ??dispatchZclMessage_6
   \   0000008A   0x8911             LDRH     R1,[R2, #+8]
   \   0000008C   0x7950             LDRB     R0,[R2, #+5]
   \   0000008E   0x.... 0x....      BL       emberAfGroupsClusterEndpointInGroupCallback
   \   00000092   0xB990             CBNZ.N   R0,??dispatchZclMessage_6
    424              emberAfDebugPrint("Drop cluster 0x%2x command 0x%x",
    425                                cmd->apsFrame->clusterId,
    426                                cmd->commandId);
   \   00000094   0x7CE3             LDRB     R3,[R4, #+19]
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x8842             LDRH     R2,[R0, #+2]
   \   0000009A   0x4629             MOV      R1,R5
   \   0000009C   0x2002             MOVS     R0,#+2
   \   0000009E   0x.... 0x....      BL       emberAfPrint
    427              emberAfDebugPrint(" for endpoint 0x%x due to wrong %p: ",
    428                                cmd->apsFrame->destinationEndpoint,
    429                                "group");
   \   000000A2   0x.... 0x....      ADR.W    R3,`?<Constant "group">`
   \   000000A6   0x.... 0x....      BL       ?Subroutine1
    430              emberAfDebugPrintln("0x%2x", cmd->apsFrame->groupId);
   \                     ??CrossCallReturnLabel_4:
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x8902             LDRH     R2,[R0, #+8]
   \                     ??dispatchZclMessage_5:
   \   000000AE   0x4639             MOV      R1,R7
   \                     ??dispatchZclMessage_1:
   \   000000B0   0x2002             MOVS     R0,#+2
   \   000000B2   0x.... 0x....      BL       emberAfPrintln
    431              return FALSE;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xBDF2             POP      {R1,R4-R7,PC}
    432            } else {
    433              return (cmd->clusterSpecific
    434                      ? emAfProcessClusterSpecificCommand(cmd)
    435                      : emAfProcessGlobalCommand(cmd));
   \                     ??dispatchZclMessage_6:
   \   000000BA   0x7BA0             LDRB     R0,[R4, #+14]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0xBF1C             ITT      NE 
   \   000000C2   0xE8BD 0x40F2      POPNE    {R1,R4-R7,LR}
   \   000000C6   0x.... 0x....      BNE.W    emAfProcessClusterSpecificCommand
   \   000000CA   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000CE   0x.... 0x....      B.W      emAfProcessGlobalCommand
    436            }
    437          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0x7CE3             LDRB     R3,[R4, #+19]
   \   00000002   0x8852             LDRH     R2,[R2, #+2]
   \   00000004   0x4629             MOV      R1,R5
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x.... 0x....      B.W      emberAfPrint

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x7942             LDRB     R2,[R0, #+5]
   \   00000004   0x4631             MOV      R1,R6
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x.... 0x....      B.W      emberAfPrint
    438          
    439          // a single call to process global and cluster-specific messages and callbacks.

   \                                 In section .text, align 2, keep-with-next
    440          boolean emberAfProcessMessage(EmberApsFrame *apsFrame,
    441                                        EmberIncomingMessageType type,
    442                                        int8u *message,
    443                                        int16u msgLen,
    444                                        EmberNodeId source,
    445                                        InterPanHeader *interPanHeader)
    446          {
   \                     emberAfProcessMessage:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x461A             MOV      R2,R3
   \   0000000A   0x990E             LDR      R1,[SP, #+56]
    447            EmberAfClusterCommand cmd;
    448            boolean msgHandled = FALSE;
   \   0000000C   0x2400             MOVS     R4,#+0
    449          
    450            // This function handles ZCL messages, so the message must have the header.
    451            if (msgLen < EMBER_AF_ZCL_OVERHEAD
    452                || (message[0] & ZCL_MANUFACTURER_SPECIFIC_MASK
    453                    && msgLen < EMBER_AF_ZCL_MANUFACTURER_SPECIFIC_OVERHEAD)) {
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable53_3
   \   00000012   0x2A03             CMP      R2,#+3
   \   00000014   0xD304             BCC.N    ??emberAfProcessMessage_0
   \   00000016   0x783B             LDRB     R3,[R7, #+0]
   \   00000018   0x075B             LSLS     R3,R3,#+29
   \   0000001A   0xD509             BPL.N    ??emberAfProcessMessage_1
   \   0000001C   0x2A05             CMP      R2,#+5
   \   0000001E   0xD207             BCS.N    ??emberAfProcessMessage_1
    454              emberAfAppPrintln("%pRX pkt too short!", "ERROR: ");
   \                     ??emberAfProcessMessage_0:
   \   00000020   0x.... 0x....      ADR.W    R2,`?<Constant "ERROR: ">`
   \   00000024   0x.... 0x....      ADR.W    R1,`?<Constant "%pRX pkt too short!">`
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x.... 0x....      BL       emberAfPrintln
    455              goto kickout;
   \   0000002E   0xE0A1             B.N      ??emberAfProcessMessage_2
    456            }
    457          
    458            // Populate the cluster command struct for processing.
    459            cmd.apsFrame        = apsFrame;
   \                     ??emberAfProcessMessage_1:
   \   00000030   0x9001             STR      R0,[SP, #+4]
    460            cmd.type            = type;
   \   00000032   0xF88D 0x6008      STRB     R6,[SP, #+8]
    461            cmd.source          = source;
   \   00000036   0xF8AD 0x100A      STRH     R1,[SP, #+10]
    462            cmd.buffer          = message;
   \   0000003A   0x9703             STR      R7,[SP, #+12]
    463            cmd.bufLen          = msgLen;
   \   0000003C   0xF8AD 0x2010      STRH     R2,[SP, #+16]
    464            cmd.clusterSpecific = (message[0] & ZCL_CLUSTER_SPECIFIC_COMMAND);
   \   00000040   0x7838             LDRB     R0,[R7, #+0]
   \   00000042   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000046   0xF88D 0x0012      STRB     R0,[SP, #+18]
    465            cmd.mfgSpecific     = (message[0] & ZCL_MANUFACTURER_SPECIFIC_MASK);
   \   0000004A   0x7838             LDRB     R0,[R7, #+0]
   \   0000004C   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000050   0xF88D 0x0013      STRB     R0,[SP, #+19]
    466            cmd.direction       = ((message[0] & ZCL_FRAME_CONTROL_DIRECTION_MASK)
    467                                    ? ZCL_DIRECTION_SERVER_TO_CLIENT
    468                                    : ZCL_DIRECTION_CLIENT_TO_SERVER);
   \   00000054   0x7838             LDRB     R0,[R7, #+0]
   \   00000056   0x08C0             LSRS     R0,R0,#+3
   \   00000058   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000005C   0xF88D 0x0019      STRB     R0,[SP, #+25]
    469            cmd.payloadStartIndex = 1;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xF88D 0x0018      STRB     R0,[SP, #+24]
    470            if (cmd.mfgSpecific) {
   \   00000066   0xF89D 0x0013      LDRB     R0,[SP, #+19]
   \   0000006A   0xB158             CBZ.N    R0,??emberAfProcessMessage_3
    471              cmd.mfgCode = emberAfGetInt16u(message, cmd.payloadStartIndex, msgLen);
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x4638             MOV      R0,R7
   \   00000070   0x.... 0x....      BL       emberAfGetInt16u
   \   00000074   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    472              cmd.payloadStartIndex += 2;
   \   00000078   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000007C   0x1C80             ADDS     R0,R0,#+2
   \   0000007E   0xF88D 0x0018      STRB     R0,[SP, #+24]
   \   00000082   0xE001             B.N      ??emberAfProcessMessage_4
    473            } else {
    474              cmd.mfgCode = EMBER_AF_NULL_MANUFACTURER_CODE;
   \                     ??emberAfProcessMessage_3:
   \   00000084   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    475            }
    476            cmd.seqNum         = message[cmd.payloadStartIndex++];
   \                     ??emberAfProcessMessage_4:
   \   00000088   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000008C   0x5DC1             LDRB     R1,[R0, R7]
   \   0000008E   0xF88D 0x1016      STRB     R1,[SP, #+22]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0xF88D 0x0018      STRB     R0,[SP, #+24]
    477            cmd.commandId      = message[cmd.payloadStartIndex++];
   \   00000098   0xB2C0             UXTB     R0,R0
   \   0000009A   0x5DC1             LDRB     R1,[R0, R7]
   \   0000009C   0xF88D 0x1017      STRB     R1,[SP, #+23]
   \   000000A0   0x1C40             ADDS     R0,R0,#+1
   \   000000A2   0xF88D 0x0018      STRB     R0,[SP, #+24]
   \   000000A6   0x9F0F             LDR      R7,[SP, #+60]
    478            cmd.interPanHeader = interPanHeader;
   \   000000A8   0x9707             STR      R7,[SP, #+28]
    479            cmd.networkIndex   = emberGetCurrentNetwork();
   \   000000AA   0x.... 0x....      BL       emberGetCurrentNetwork
   \   000000AE   0xF88D 0x0020      STRB     R0,[SP, #+32]
    480            emAfCurrentCommand = &cmd;
   \   000000B2   0xA801             ADD      R0,SP,#+4
   \   000000B4   0x61E8             STR      R0,[R5, #+28]
    481          
    482            // All of these should be covered by the EmberAfClusterCommand but are
    483            // still here until all the code is moved over to use the cmd. -WEH
    484            emberAfIncomingZclSequenceNumber = cmd.seqNum;
   \   000000B6   0xF89D 0x0016      LDRB     R0,[SP, #+22]
   \   000000BA   0x7028             STRB     R0,[R5, #+0]
    485          
    486            printIncomingZclMessage(&cmd);
   \   000000BC   0xA801             ADD      R0,SP,#+4
   \   000000BE   0x.... 0x....      BL       printIncomingZclMessage
    487            prepareForResponse(&cmd);
   \   000000C2   0xA801             ADD      R0,SP,#+4
   \   000000C4   0x.... 0x....      BL       prepareForResponse
    488          
    489            if (emberAfPreCommandReceivedCallback(&cmd)) {
   \   000000C8   0xA801             ADD      R0,SP,#+4
   \   000000CA   0x.... 0x....      BL       emberAfPreCommandReceivedCallback
   \   000000CE   0xBB28             CBNZ.N   R0,??emberAfProcessMessage_5
    490              msgHandled = TRUE;
    491              goto kickout;
    492            }
    493          
    494            if (interPanHeader == NULL) {
   \   000000D0   0xBB37             CBNZ.N   R7,??emberAfProcessMessage_6
    495              boolean broadcast = (type == EMBER_INCOMING_BROADCAST
    496                                   || type == EMBER_INCOMING_BROADCAST_LOOPBACK
    497                                   || type == EMBER_INCOMING_MULTICAST
    498                                   || type == EMBER_INCOMING_MULTICAST_LOOPBACK);
   \   000000D2   0x2E04             CMP      R6,#+4
   \   000000D4   0xBF18             IT       NE 
   \   000000D6   0x2E05             CMPNE    R6,#+5
   \   000000D8   0xD003             BEQ.N    ??emberAfProcessMessage_7
   \   000000DA   0x2E02             CMP      R6,#+2
   \   000000DC   0xBF18             IT       NE 
   \   000000DE   0x2E03             CMPNE    R6,#+3
   \   000000E0   0xD101             BNE.N    ??emberAfProcessMessage_8
   \                     ??emberAfProcessMessage_7:
   \   000000E2   0x2201             MOVS     R2,#+1
   \   000000E4   0xE000             B.N      ??emberAfProcessMessage_9
   \                     ??emberAfProcessMessage_8:
   \   000000E6   0x2200             MOVS     R2,#+0
    499          
    500              // if the cluster for the incoming message requires security and
    501              // doesnt have it return default response STATUS_FAILURE
    502              if (emberAfDetermineIfLinkSecurityIsRequired(cmd.commandId,
    503                                                           TRUE, // incoming
    504                                                           broadcast,
    505                                                           cmd.apsFrame->profileId,
    506                                                           cmd.apsFrame->clusterId)
    507                  && (!(cmd.apsFrame->options & EMBER_APS_OPTION_ENCRYPTION))) {
   \                     ??emberAfProcessMessage_9:
   \   000000E8   0x9801             LDR      R0,[SP, #+4]
   \   000000EA   0x8840             LDRH     R0,[R0, #+2]
   \   000000EC   0x9000             STR      R0,[SP, #+0]
   \   000000EE   0x9801             LDR      R0,[SP, #+4]
   \   000000F0   0x8803             LDRH     R3,[R0, #+0]
   \   000000F2   0x2101             MOVS     R1,#+1
   \   000000F4   0xF89D 0x0017      LDRB     R0,[SP, #+23]
   \   000000F8   0x.... 0x....      BL       emberAfDetermineIfLinkSecurityIsRequired
   \   000000FC   0xB198             CBZ.N    R0,??emberAfProcessMessage_10
   \   000000FE   0x9801             LDR      R0,[SP, #+4]
   \   00000100   0x7980             LDRB     R0,[R0, #+6]
   \   00000102   0x0680             LSLS     R0,R0,#+26
   \   00000104   0xD40F             BMI.N    ??emberAfProcessMessage_10
    508                emberAfDebugPrintln("Drop clus %2x due to no aps security",
    509                                    cmd.apsFrame->clusterId);
   \   00000106   0x9801             LDR      R0,[SP, #+4]
   \   00000108   0x8842             LDRH     R2,[R0, #+2]
   \   0000010A   0x.... 0x....      ADR.W    R1,`?<Constant "Drop clus %2x due to ...">`
   \   0000010E   0x2002             MOVS     R0,#+2
   \   00000110   0x.... 0x....      BL       emberAfPrintln
    510                afNoSecurityForDefaultResponse = TRUE;
    511                emberAfSendDefaultResponse(&cmd, EMBER_ZCL_STATUS_FAILURE);
   \   00000114   0x2101             MOVS     R1,#+1
   \   00000116   0xA801             ADD      R0,SP,#+4
   \   00000118   0x.... 0x....      BL       emberAfSendDefaultResponse
    512                afNoSecurityForDefaultResponse = FALSE;
    513          
    514                // Mark the message as processed.  It failed security processing, so no
    515                // other parts of the code act should upon it.
    516                msgHandled = TRUE;
   \                     ??emberAfProcessMessage_5:
   \   0000011C   0x2401             MOVS     R4,#+1
    517                goto kickout;
   \   0000011E   0xE029             B.N      ??emberAfProcessMessage_2
    518              }
    519            } else if (!(interPanHeader->options
    520                         & EMBER_AF_INTERPAN_OPTION_MAC_HAS_LONG_ADDRESS)) {
   \                     ??emberAfProcessMessage_6:
   \   00000120   0x7D38             LDRB     R0,[R7, #+20]
   \   00000122   0x0780             LSLS     R0,R0,#+30
   \   00000124   0xD526             BPL.N    ??emberAfProcessMessage_2
    521              // For safety, dump all interpan messages that don't have a long
    522              // source in the MAC layer.  In theory they should not get past
    523              // the MAC filters but this is insures they will not get processed.
    524              goto kickout;
    525            }
    526          
    527            if (cmd.apsFrame->destinationEndpoint == EMBER_BROADCAST_ENDPOINT) {
   \                     ??emberAfProcessMessage_10:
   \   00000126   0x9801             LDR      R0,[SP, #+4]
   \   00000128   0x7940             LDRB     R0,[R0, #+5]
   \   0000012A   0x28FF             CMP      R0,#+255
   \   0000012C   0xD11E             BNE.N    ??emberAfProcessMessage_11
    528              int8u i;
    529              for (i = 0; i < emberAfEndpointCount(); i++) {
   \   0000012E   0x2600             MOVS     R6,#+0
   \   00000130   0x.... 0x....      LDR.W    R7,??DataTable53_2
   \                     ??emberAfProcessMessage_12:
   \   00000134   0x.... 0x....      BL       emberAfEndpointCount
   \   00000138   0xB2F6             UXTB     R6,R6
   \   0000013A   0x4286             CMP      R6,R0
   \   0000013C   0xD21A             BCS.N    ??emberAfProcessMessage_2
    530                if (!emberAfEndpointIndexIsEnabled(i)) {
   \   0000013E   0x4630             MOV      R0,R6
   \   00000140   0x.... 0x....      BL       emberAfEndpointIndexIsEnabled
   \   00000144   0xB180             CBZ.N    R0,??emberAfProcessMessage_13
    531                  continue;
    532                }
    533                // Since the APS frame is cleared after each sending, 
    534                // we must reinitialize it.  It is cleared to prevent
    535                // data from leaking out and being sent inadvertently.
    536                prepareForResponse(&cmd);
   \   00000146   0xA801             ADD      R0,SP,#+4
   \   00000148   0x.... 0x....      BL       prepareForResponse
    537          
    538                // Change the destination endpoint of the incoming command and the source
    539                // source endpoint of the response so they both reflect the endpoint the
    540                // message is actually being passed to in this iteration of the loop.
    541                cmd.apsFrame->destinationEndpoint      = emberAfEndpointFromIndex(i);
   \   0000014C   0x4630             MOV      R0,R6
   \   0000014E   0x.... 0x....      BL       emberAfEndpointFromIndex
   \   00000152   0x9901             LDR      R1,[SP, #+4]
   \   00000154   0x7148             STRB     R0,[R1, #+5]
    542                emberAfResponseApsFrame.sourceEndpoint = emberAfEndpointFromIndex(i);
   \   00000156   0x4630             MOV      R0,R6
   \   00000158   0x.... 0x....      BL       emberAfEndpointFromIndex
   \   0000015C   0x7138             STRB     R0,[R7, #+4]
    543                if (dispatchZclMessage(&cmd)) {
   \   0000015E   0xA801             ADD      R0,SP,#+4
   \   00000160   0x.... 0x....      BL       dispatchZclMessage
   \   00000164   0xB100             CBZ.N    R0,??emberAfProcessMessage_13
    544                  msgHandled = TRUE;
   \   00000166   0x2401             MOVS     R4,#+1
    545                }
    546              }
   \                     ??emberAfProcessMessage_13:
   \   00000168   0x1C76             ADDS     R6,R6,#+1
   \   0000016A   0xE7E3             B.N      ??emberAfProcessMessage_12
    547            } else {
    548              msgHandled = dispatchZclMessage(&cmd);
   \                     ??emberAfProcessMessage_11:
   \   0000016C   0xA801             ADD      R0,SP,#+4
   \   0000016E   0x.... 0x....      BL       dispatchZclMessage
   \   00000172   0x4604             MOV      R4,R0
    549            }
    550          
    551          kickout:
    552            emberAfClearResponseData();
   \                     ??emberAfProcessMessage_2:
   \   00000174   0x.... 0x....      BL       emberAfClearResponseData
    553            MEMSET(&interpanResponseHeader,
    554                   0,
    555                   sizeof(EmberAfInterpanHeader));
   \   00000178   0x2216             MOVS     R2,#+22
   \   0000017A   0x2100             MOVS     R1,#+0
   \   0000017C   0x1D28             ADDS     R0,R5,#+4
   \   0000017E   0x.... 0x....      BL       halCommonMemSet
    556            emAfCurrentCommand = NULL;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x61E8             STR      R0,[R5, #+28]
    557            return msgHandled;
   \   00000186   0x4620             MOV      R0,R4
   \   00000188   0xB009             ADD      SP,SP,#+36
   \   0000018A   0xBDF0             POP      {R4-R7,PC}       ;; return
    558          }
    559          

   \                                 In section .text, align 2, keep-with-next
    560          int8u emberAfNextSequence(void)
    561          {
    562            return ((++emberAfSequenceNumber) & EMBER_AF_ZCL_SEQUENCE_MASK);
   \                     emberAfNextSequence:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable53_10
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   \   0000000A   0xF001 0x007F      AND      R0,R1,#0x7F
   \   0000000E   0x4770             BX       LR               ;; return
    563          }
    564          

   \                                 In section .text, align 2, keep-with-next
    565          int8u emberAfGetLastSequenceNumber(void)
    566          {
    567            return (emberAfSequenceNumber & EMBER_AF_ZCL_SEQUENCE_MASK);
   \                     emberAfGetLastSequenceNumber:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable53_10
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF000 0x007F      AND      R0,R0,#0x7F
   \   0000000A   0x4770             BX       LR               ;; return
    568          }
    569          
    570          // the caller to the library can set a flag to say do not respond to the
    571          // next ZCL message passed in to the library. Passing TRUE means disable
    572          // the reply for the next ZCL message. Setting to FALSE re-enables the
    573          // reply (in the case where the app disables it and then doesnt send a 
    574          // message that gets parsed).

   \                                 In section .text, align 2, keep-with-next
    575          void emberAfSetNoReplyForNextMessage(boolean set)
    576          {
    577            if (set) {
   \                     emberAfSetNoReplyForNextMessage:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable53_3
   \   00000004   0x788A             LDRB     R2,[R1, #+2]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xBF14             ITE      NE 
   \   0000000A   0xF042 0x0001      ORRNE    R0,R2,#0x1
   \   0000000E   0xF002 0x00FE      ANDEQ    R0,R2,#0xFE
    578              emberAfResponseType |= ZCL_UTIL_RESP_NONE;
    579            } else {
    580              emberAfResponseType &= ~ZCL_UTIL_RESP_NONE;
   \   00000012   0x7088             STRB     R0,[R1, #+2]
    581            }
    582          }
   \   00000014   0x4770             BX       LR               ;; return
    583          

   \                                 In section .text, align 2, keep-with-next
    584          EmberStatus emberAfSendResponseWithCallback(EmberAfMessageSentFunction callback)
    585          {
   \                     emberAfSendResponseWithCallback:
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
    586            EmberStatus status;
    587            int8u label;
    588          
    589            // If the no-response flag is set, dont send anything.
    590            if (emberAfResponseType & ZCL_UTIL_RESP_NONE) {
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable53_3
   \   00000008   0x78A2             LDRB     R2,[R4, #+2]
   \   0000000A   0x07D1             LSLS     R1,R2,#+31
   \   0000000C   0xD506             BPL.N    ??emberAfSendResponseWithCallback_0
    591              emberAfDebugPrintln("ZCL Util: no response at user request");
   \   0000000E   0x.... 0x....      ADR.W    R1,`?<Constant "ZCL Util: no response...">`
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x.... 0x....      BL       emberAfPrintln
    592              return EMBER_SUCCESS;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE067             B.N      ??emberAfSendResponseWithCallback_1
    593            }
    594          
    595            if (emberAfApsRetryOverride == EMBER_AF_RETRY_OVERRIDE_SET) {
   \                     ??emberAfSendResponseWithCallback_0:
   \   0000001C   0x7861             LDRB     R1,[R4, #+1]
   \   0000001E   0x.... 0x....      LDR.W    R5,??DataTable53_2
   \   00000022   0x2901             CMP      R1,#+1
   \   00000024   0xD103             BNE.N    ??emberAfSendResponseWithCallback_2
    596              emberAfResponseApsFrame.options |= EMBER_APS_OPTION_RETRY;
   \   00000026   0x88E9             LDRH     R1,[R5, #+6]
   \   00000028   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000002C   0xE005             B.N      ??emberAfSendResponseWithCallback_3
    597            } else if (emberAfApsRetryOverride == EMBER_AF_RETRY_OVERRIDE_UNSET) {
   \                     ??emberAfSendResponseWithCallback_2:
   \   0000002E   0x2902             CMP      R1,#+2
   \   00000030   0xD104             BNE.N    ??emberAfSendResponseWithCallback_4
    598              emberAfResponseApsFrame.options &= ~EMBER_APS_OPTION_RETRY;
   \   00000032   0x88E9             LDRH     R1,[R5, #+6]
   \   00000034   0xF64F 0x73BF      MOVW     R3,#+65471
   \   00000038   0x4019             ANDS     R1,R3,R1
   \                     ??emberAfSendResponseWithCallback_3:
   \   0000003A   0x80E9             STRH     R1,[R5, #+6]
    599            }
    600          
    601            // Fill commands may increase the sequence.  For responses, we want to make
    602            // sure the sequence is reset to that of the request.
    603            if (appResponseData[0] & ZCL_MANUFACTURER_SPECIFIC_MASK) {
   \                     ??emberAfSendResponseWithCallback_4:
   \   0000003C   0x7821             LDRB     R1,[R4, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R6,??DataTable53_6
   \   00000042   0x7833             LDRB     R3,[R6, #+0]
   \   00000044   0x075B             LSLS     R3,R3,#+29
   \   00000046   0xBF4C             ITE      MI 
   \   00000048   0x70F1             STRBMI   R1,[R6, #+3]
   \   0000004A   0x7071             STRBPL   R1,[R6, #+1]
    604              appResponseData[3] = emberAfIncomingZclSequenceNumber;
    605            } else {
    606              appResponseData[1] = emberAfIncomingZclSequenceNumber;
    607            }
    608          
    609            // The manner in which the message is sent depends on the response flags and
    610            // the destination of the message.
    611            if (emberAfResponseType & ZCL_UTIL_RESP_INTERPAN) {
   \   0000004C   0x.... 0x....      LDR.W    R8,??DataTable53_5
   \   00000050   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   00000054   0x0792             LSLS     R2,R2,#+30
   \   00000056   0xD50A             BPL.N    ??emberAfSendResponseWithCallback_5
    612              label = 'I';
   \   00000058   0x2749             MOVS     R7,#+73
    613              status = emberAfInterpanSendMessageCallback(&interpanResponseHeader,
    614                                                          appResponseLength,
    615                                                          appResponseData);
   \   0000005A   0x4632             MOV      R2,R6
   \   0000005C   0x1D20             ADDS     R0,R4,#+4
   \   0000005E   0x.... 0x....      BL       emberAfInterpanSendMessageCallback
   \   00000062   0x4681             MOV      R9,R0
    616              emberAfResponseType &= ~ZCL_UTIL_RESP_INTERPAN;
   \   00000064   0x78A0             LDRB     R0,[R4, #+2]
   \   00000066   0xF000 0x00FD      AND      R0,R0,#0xFD
   \   0000006A   0x70A0             STRB     R0,[R4, #+2]
   \   0000006C   0xE019             B.N      ??emberAfSendResponseWithCallback_6
    617            } else if (emberAfResponseDestination < EMBER_BROADCAST_ADDRESS) {
   \                     ??emberAfSendResponseWithCallback_5:
   \   0000006E   0x.... 0x....      LDR.W    R2,??DataTable53_4
   \   00000072   0x8814             LDRH     R4,[R2, #+0]
   \   00000074   0xF64F 0x72FC      MOVW     R2,#+65532
   \   00000078   0x4294             CMP      R4,R2
   \   0000007A   0xD209             BCS.N    ??emberAfSendResponseWithCallback_7
    618              label = 'U';
   \   0000007C   0x2755             MOVS     R7,#+85
    619              status = emberAfSendUnicastWithCallback(EMBER_OUTGOING_DIRECT,
    620                                                      emberAfResponseDestination,
    621                                                      &emberAfResponseApsFrame,
    622                                                      appResponseLength,
    623                                                      appResponseData,
    624                                                      callback);
   \   0000007E   0x9001             STR      R0,[SP, #+4]
   \   00000080   0x9600             STR      R6,[SP, #+0]
   \   00000082   0x460B             MOV      R3,R1
   \   00000084   0x462A             MOV      R2,R5
   \   00000086   0x4621             MOV      R1,R4
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x.... 0x....      BL       emberAfSendUnicastWithCallback
   \   0000008E   0xE007             B.N      ??emberAfSendResponseWithCallback_8
    625            } else {
    626              label = 'B';
   \                     ??emberAfSendResponseWithCallback_7:
   \   00000090   0x2742             MOVS     R7,#+66
    627              status = emberAfSendBroadcastWithCallback(emberAfResponseDestination,
    628                                                        &emberAfResponseApsFrame,
    629                                                        appResponseLength,
    630                                                        appResponseData,
    631                                                        callback);
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0x4633             MOV      R3,R6
   \   00000096   0x460A             MOV      R2,R1
   \   00000098   0x4629             MOV      R1,R5
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       emberAfSendBroadcastWithCallback
   \                     ??emberAfSendResponseWithCallback_8:
   \   000000A0   0x4681             MOV      R9,R0
    632            }
    633          
    634            emberAfDebugPrintln("T%4x:TX (%p) %ccast 0x%x%p",
    635                                emberAfGetCurrentTime(),
    636                                "resp",
    637                                label,
    638                                status,
    639                                ((emberAfResponseApsFrame.options
    640                                  & EMBER_APS_OPTION_ENCRYPTION)
    641                                 ? " w/ link key" : ""));
   \                     ??emberAfSendResponseWithCallback_6:
   \   000000A2   0x79A8             LDRB     R0,[R5, #+6]
   \   000000A4   0x0680             LSLS     R0,R0,#+26
   \   000000A6   0xBF4C             ITE      MI 
   \   000000A8   0x.... 0x....      ADRMI.W  R4,`?<Constant " w/ link key">`
   \   000000AC   0x....             ADRPL.N  R4,??DataTable48  ;; ""
   \   000000AE   0x.... 0x....      BL       emberAfGetCurrentTimeCallback
   \   000000B2   0x9402             STR      R4,[SP, #+8]
   \   000000B4   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   000000B8   0x9700             STR      R7,[SP, #+0]
   \   000000BA   0x.... 0x....      ADR.W    R3,`?<Constant "resp">`
   \   000000BE   0x4602             MOV      R2,R0
   \   000000C0   0x.... 0x....      ADR.W    R1,`?<Constant "T%4x:TX (%p) %ccast 0...">`
   \   000000C4   0x2002             MOVS     R0,#+2
   \   000000C6   0x.... 0x....      BL       emberAfPrintln
    642            emberAfDebugPrint("TX buffer: [");
   \   000000CA   0x.... 0x....      ADR.W    R1,`?<Constant "TX buffer: [">`
   \   000000CE   0x2002             MOVS     R0,#+2
   \   000000D0   0x.... 0x....      BL       emberAfPrint
    643            emberAfDebugFlush();
    644            emberAfDebugPrintBuffer(appResponseData, appResponseLength, TRUE);
   \   000000D4   0x2301             MOVS     R3,#+1
   \   000000D6   0xF8B8 0x2000      LDRH     R2,[R8, #+0]
   \   000000DA   0x4631             MOV      R1,R6
   \   000000DC   0x2002             MOVS     R0,#+2
   \   000000DE   0x.... 0x....      BL       emberAfPrintBuffer
    645            emberAfDebugPrintln("]");
   \   000000E2   0x....             ADR.N    R1,??DataTable48_1  ;; "]"
   \   000000E4   0x2002             MOVS     R0,#+2
   \   000000E6   0x.... 0x....      BL       emberAfPrintln
    646            emberAfDebugFlush();
    647          
    648          #ifdef EMBER_AF_ENABLE_STATISTICS
    649            if (status == EMBER_SUCCESS) {
    650              afNumPktsSent++;
    651            }
    652          #endif
    653          
    654            return status;
   \   000000EA   0x4648             MOV      R0,R9
   \                     ??emberAfSendResponseWithCallback_1:
   \   000000EC   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    655          }
    656          

   \                                 In section .text, align 2, keep-with-next
    657          EmberStatus emberAfSendResponse(void)
    658          {
    659            return emberAfSendResponseWithCallback(NULL);
   \                     emberAfSendResponse:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      emberAfSendResponseWithCallback
    660          }
    661          

   \                                 In section .text, align 2, keep-with-next
    662          EmberStatus emberAfSendImmediateDefaultResponseWithCallback(EmberAfStatus status,
    663                                                                      EmberAfMessageSentFunction callback)
    664          {
    665            return emberAfSendDefaultResponseWithCallback(emberAfCurrentCommand(), status, callback);
   \                     emberAfSendImmediateDefaultResponseWithCallback:
   \   00000000   0x460A             MOV      R2,R1
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable53_3
   \   00000008   0x69C0             LDR      R0,[R0, #+28]
   \   0000000A   0x....             B.N      emberAfSendDefaultResponseWithCallback
    666          }
    667          

   \                                 In section .text, align 2, keep-with-next
    668          EmberStatus emberAfSendImmediateDefaultResponse(EmberAfStatus status)
    669          {
    670            return emberAfSendImmediateDefaultResponseWithCallback(status, NULL);
   \                     emberAfSendImmediateDefaultResponse:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      emberAfSendImmediateDefaultResponseWithCallback
    671          }
    672          

   \                                 In section .text, align 2, keep-with-next
    673          EmberStatus emberAfSendDefaultResponseWithCallback(const EmberAfClusterCommand *cmd,
    674                                                             EmberAfStatus status,
    675                                                             EmberAfMessageSentFunction callback)
    676          {
   \                     emberAfSendDefaultResponseWithCallback:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    677            int8u frameControl;
    678          
    679            // Default Response commands are only sent in response to unicast commands.
    680            if (cmd->type != EMBER_INCOMING_UNICAST
    681                && cmd->type != EMBER_INCOMING_UNICAST_REPLY) {
   \   00000008   0x7920             LDRB     R0,[R4, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2801             CMPNE    R0,#+1
   \   00000010   0xD10A             BNE.N    ??emberAfSendDefaultResponseWithCallback_0
    682              return EMBER_SUCCESS;
    683            }
    684          
    685            // If the Disable Default Response sub-field is set, Default Response commands
    686            // are only sent if there was an error.
    687            if ((cmd->buffer[0] & ZCL_DISABLE_DEFAULT_RESPONSE_MASK)
    688                && status == EMBER_ZCL_STATUS_SUCCESS) {
   \   00000012   0x68A0             LDR      R0,[R4, #+8]
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x06C0             LSLS     R0,R0,#+27
   \   00000018   0xD500             BPL.N    ??emberAfSendDefaultResponseWithCallback_1
   \   0000001A   0xB12D             CBZ.N    R5,??emberAfSendDefaultResponseWithCallback_0
    689              return EMBER_SUCCESS;
    690            }
    691          
    692            // Default Response commands are never sent in response to other Default
    693            // Response commands.
    694            if (!cmd->clusterSpecific
    695                && cmd->commandId == ZCL_DEFAULT_RESPONSE_COMMAND_ID) {
   \                     ??emberAfSendDefaultResponseWithCallback_1:
   \   0000001C   0x7BA0             LDRB     R0,[R4, #+14]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xBF04             ITT      EQ 
   \   00000022   0x7CE0             LDRBEQ   R0,[R4, #+19]
   \   00000024   0x280B             CMPEQ    R0,#+11
   \   00000026   0xD101             BNE.N    ??emberAfSendDefaultResponseWithCallback_2
    696              return EMBER_SUCCESS;
   \                     ??emberAfSendDefaultResponseWithCallback_0:
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD70             POP      {R4-R6,PC}
    697            }
    698          
    699            appResponseLength = 0;
   \                     ??emberAfSendDefaultResponseWithCallback_2:
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x8001             STRH     R1,[R0, #+0]
    700            frameControl = (ZCL_PROFILE_WIDE_COMMAND
    701                            | (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER
    702                               ? ZCL_FRAME_CONTROL_SERVER_TO_CLIENT
    703                               : ZCL_FRAME_CONTROL_CLIENT_TO_SERVER));
   \   00000034   0x7D60             LDRB     R0,[R4, #+21]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xBF0C             ITE      EQ 
   \   0000003A   0x2008             MOVEQ    R0,#+8
   \   0000003C   0x2000             MOVNE    R0,#+0
    704            if (!cmd->mfgSpecific) {
   \   0000003E   0x7BE1             LDRB     R1,[R4, #+15]
   \   00000040   0xB911             CBNZ.N   R1,??emberAfSendDefaultResponseWithCallback_3
    705              emberAfPutInt8uInResp(frameControl & ~ZCL_MANUFACTURER_SPECIFIC_MASK);
   \   00000042   0x.... 0x....      BL       emberAfPutInt8uInResp
   \   00000046   0xE006             B.N      ??emberAfSendDefaultResponseWithCallback_4
    706            } else {
    707              emberAfPutInt8uInResp(frameControl | ZCL_MANUFACTURER_SPECIFIC_MASK);
   \                     ??emberAfSendDefaultResponseWithCallback_3:
   \   00000048   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000004C   0x.... 0x....      BL       emberAfPutInt8uInResp
    708              emberAfPutInt16uInResp(cmd->mfgCode);
   \   00000050   0x8A20             LDRH     R0,[R4, #+16]
   \   00000052   0x.... 0x....      BL       emberAfPutInt16uInResp
    709            }
    710            emberAfPutInt8uInResp(cmd->seqNum);
   \                     ??emberAfSendDefaultResponseWithCallback_4:
   \   00000056   0x7CA0             LDRB     R0,[R4, #+18]
   \   00000058   0x.... 0x....      BL       emberAfPutInt8uInResp
    711            emberAfPutInt8uInResp(ZCL_DEFAULT_RESPONSE_COMMAND_ID);
   \   0000005C   0x200B             MOVS     R0,#+11
   \   0000005E   0x.... 0x....      BL       emberAfPutInt8uInResp
    712            emberAfPutInt8uInResp(cmd->commandId);
   \   00000062   0x7CE0             LDRB     R0,[R4, #+19]
   \   00000064   0x.... 0x....      BL       emberAfPutInt8uInResp
    713            emberAfPutInt8uInResp(status);
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       emberAfPutInt8uInResp
    714          
    715            prepareForResponse(cmd);
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       prepareForResponse
    716            return emberAfSendResponseWithCallback(callback);
   \   00000074   0x4630             MOV      R0,R6
   \   00000076   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000007A   0x....             B.N      emberAfSendResponseWithCallback
    717          }
    718          

   \                                 In section .text, align 2, keep-with-next
    719          EmberStatus emberAfSendDefaultResponse(const EmberAfClusterCommand *cmd,
    720                                                 EmberAfStatus status)
    721          {
    722            return emberAfSendDefaultResponseWithCallback(cmd, status, NULL);
   \                     emberAfSendDefaultResponse:
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x....             B.N      emberAfSendDefaultResponseWithCallback
    723          }
    724          

   \                                 In section .text, align 2, keep-with-next
    725          boolean emberAfDetermineIfLinkSecurityIsRequired(int8u commandId,
    726                                                           boolean incoming,
    727                                                           boolean broadcast,
    728                                                           EmberAfProfileId profileId,
    729                                                           EmberAfClusterId clusterId)
    730          {
   \                     emberAfDetermineIfLinkSecurityIsRequired:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x461D             MOV      R5,R3
   \   00000004   0x9C04             LDR      R4,[SP, #+16]
    731            (void)afNoSecurityForDefaultResponse; // remove warning if not used
    732          
    733          #ifdef EMBER_AF_HAS_SECURITY_PROFILE_SE
    734            if (emberAfIsCurrentSecurityProfileSmartEnergy()) {
    735              // If we have turned off all APS security (needed for testing), then just
    736              // always return false.
    737              if (emAfApsSecurityOff || afNoSecurityForDefaultResponse) {
    738                afNoSecurityForDefaultResponse = FALSE;
    739                return FALSE;
    740              }
    741          
    742              // NOTE: In general if it is a unicast, and one of the SE clusters, it
    743              // requires APS encryption.  A few special cases exists that we allow for
    744              // but those must be explicitly spelled out here.
    745          
    746              // Assume that if the local device is broadcasting, even if it is using one
    747              // of the SE clusters, this is okay.
    748              if (!incoming && broadcast) {
    749                return FALSE;
    750              }
    751          
    752              // Check against profile IDs that use APS security on these clusters.
    753              if (profileId != SE_PROFILE_ID && profileId != EMBER_WILDCARD_PROFILE_ID) {
    754                return FALSE;
    755              }
    756          
    757              // This list comes from Section 5.4.6 of the SE spec.
    758              switch (clusterId) {
    759              case ZCL_TIME_CLUSTER_ID:
    760              case ZCL_COMMISSIONING_CLUSTER_ID:
    761              case ZCL_PRICE_CLUSTER_ID:
    762              case ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID:
    763              case ZCL_SIMPLE_METERING_CLUSTER_ID:
    764              case ZCL_MESSAGING_CLUSTER_ID:
    765              case ZCL_TUNNELING_CLUSTER_ID:
    766              case ZCL_GENERIC_TUNNEL_CLUSTER_ID:
    767              case ZCL_PREPAYMENT_CLUSTER_ID:
    768              case ZCL_TOU_CALENDAR_CLUSTER_ID:
    769              case ZCL_DEVICE_MANAGEMENT_CLUSTER_ID:
    770              case ZCL_EVENTS_CLUSTER_ID:
    771              case ZCL_MDU_PAIRING_CLUSTER_ID:
    772              case ZCL_ENERGY_MANAGEMENT_CLUSTER_ID:
    773                return TRUE;
    774              case ZCL_OTA_BOOTLOAD_CLUSTER_ID:
    775                if (commandId == ZCL_IMAGE_NOTIFY_COMMAND_ID && broadcast) {
    776                  return FALSE;
    777                } else {
    778                  return TRUE;
    779                }
    780              default:
    781                break;
    782              }
    783            }
    784          #endif //EMBER_AF_HAS_SECURITY_PROFILE_SE
    785          
    786            if (emberAfClusterSecurityCustomCallback(profileId,
    787                                                     clusterId,
    788                                                     incoming,
    789                                                     commandId)) {
   \   00000006   0x4603             MOV      R3,R0
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0xB2A1             UXTH     R1,R4
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       emberAfClusterSecurityCustomCallback
   \   00000012   0xB100             CBZ.N    R0,??emberAfDetermineIfLinkSecurityIsRequired_0
   \   00000014   0x2001             MOVS     R0,#+1
    790              return TRUE;
    791            }
    792          
    793            return FALSE;
   \                     ??emberAfDetermineIfLinkSecurityIsRequired_0:
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    794          }
    795          

   \                                 In section .text, align 2, keep-with-next
    796          int8u emberAfMaximumApsPayloadLength(EmberOutgoingMessageType type,
    797                                               int16u indexOrDestination,
    798                                               EmberApsFrame *apsFrame)
    799          {
   \                     emberAfMaximumApsPayloadLength:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    800            EmberNodeId destination = EMBER_UNKNOWN_NODE_ID;
   \   00000002   0xF64F 0x73FD      MOVW     R3,#+65533
    801            int8u max = EMBER_AF_MAXIMUM_APS_PAYLOAD_LENGTH;
   \   00000006   0x2452             MOVS     R4,#+82
    802          
    803            if (apsFrame->options & EMBER_APS_OPTION_ENCRYPTION) {
   \   00000008   0x88D2             LDRH     R2,[R2, #+6]
   \   0000000A   0x0695             LSLS     R5,R2,#+26
   \   0000000C   0xBF48             IT       MI 
   \   0000000E   0x2449             MOVMI    R4,#+73
    804              max -= EMBER_AF_APS_ENCRYPTION_OVERHEAD;
    805            }
    806            if (apsFrame->options & EMBER_APS_OPTION_SOURCE_EUI64) {
   \   00000010   0x0555             LSLS     R5,R2,#+21
   \   00000012   0xBF44             ITT      MI 
   \   00000014   0x3C08             SUBMI    R4,R4,#+8
   \   00000016   0xB2E4             UXTBMI   R4,R4
    807              max -= EUI64_SIZE;
    808            }
    809            if (apsFrame->options & EMBER_APS_OPTION_DESTINATION_EUI64) {
   \   00000018   0x0515             LSLS     R5,R2,#+20
   \   0000001A   0xBF44             ITT      MI 
   \   0000001C   0x3C08             SUBMI    R4,R4,#+8
   \   0000001E   0xB2E4             UXTBMI   R4,R4
    810              max -= EUI64_SIZE;
    811            }
    812            if (apsFrame->options & EMBER_APS_OPTION_FRAGMENT) {
   \   00000020   0x0412             LSLS     R2,R2,#+16
   \   00000022   0xBF44             ITT      MI 
   \   00000024   0x1EA4             SUBMI    R4,R4,#+2
   \   00000026   0xB2E4             UXTBMI   R4,R4
    813              max -= EMBER_AF_APS_FRAGMENTATION_OVERHEAD;
    814            }
    815          
    816            switch (type) {
   \   00000028   0xB138             CBZ.N    R0,??emberAfMaximumApsPayloadLength_0
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD00B             BEQ.N    ??emberAfMaximumApsPayloadLength_1
   \   0000002E   0xD306             BCC.N    ??emberAfMaximumApsPayloadLength_2
   \   00000030   0x2803             CMP      R0,#+3
   \   00000032   0xBF04             ITT      EQ 
   \   00000034   0x1E64             SUBEQ    R4,R4,#+1
   \   00000036   0xB2E4             UXTBEQ   R4,R4
   \   00000038   0xE009             B.N      ??emberAfMaximumApsPayloadLength_3
    817            case EMBER_OUTGOING_DIRECT:
    818              destination = indexOrDestination;
   \                     ??emberAfMaximumApsPayloadLength_0:
   \   0000003A   0x460B             MOV      R3,R1
    819              break;
   \   0000003C   0xE007             B.N      ??emberAfMaximumApsPayloadLength_3
    820            case EMBER_OUTGOING_VIA_ADDRESS_TABLE:
    821              destination = emberGetAddressTableRemoteNodeId(indexOrDestination);
   \                     ??emberAfMaximumApsPayloadLength_2:
   \   0000003E   0xB2C8             UXTB     R0,R1
   \   00000040   0x.... 0x....      BL       emberGetAddressTableRemoteNodeId
   \   00000044   0xE002             B.N      ??emberAfMaximumApsPayloadLength_4
    822              break;
    823            case EMBER_OUTGOING_VIA_BINDING:
    824              destination = emberGetBindingRemoteNodeId(indexOrDestination);
   \                     ??emberAfMaximumApsPayloadLength_1:
   \   00000046   0xB2C8             UXTB     R0,R1
   \   00000048   0x.... 0x....      BL       emberGetBindingRemoteNodeId
   \                     ??emberAfMaximumApsPayloadLength_4:
   \   0000004C   0x4603             MOV      R3,R0
    825              break;
    826            case EMBER_OUTGOING_MULTICAST:
    827              // APS multicast messages include the two-byte group id and exclude the
    828              // one-byte destination endpoint, for a net loss of an extra byte.
    829              max--;
    830              break;
    831            case EMBER_OUTGOING_BROADCAST:
    832              break;
    833            }
    834          
    835            max -= emberAfGetSourceRouteOverheadCallback(destination);
    836          
    837            return max;
   \                     ??emberAfMaximumApsPayloadLength_3:
   \   0000004E   0x4618             MOV      R0,R3
   \   00000050   0x.... 0x....      BL       emberAfGetSourceRouteOverheadCallback
   \   00000054   0x1A20             SUBS     R0,R4,R0
   \   00000056   0xB2C0             UXTB     R0,R0
   \   00000058   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    838          }
    839          

   \                                 In section .text, align 2, keep-with-next
    840          void emberAfCopyInt16u(int8u *data, int16u index, int16u x) {
    841            data[index]   = (int8u) ( ((x)    ) & 0xFF);      
   \                     emberAfCopyInt16u:
   \   00000000   0x540A             STRB     R2,[R1, R0]
    842            data[index+1] = (int8u) ( ((x)>> 8) & 0xFF);
   \   00000002   0x1808             ADDS     R0,R1,R0
   \   00000004   0x0A11             LSRS     R1,R2,#+8
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    843          }
   \   00000008   0x4770             BX       LR               ;; return
    844          

   \                                 In section .text, align 2, keep-with-next
    845          void emberAfCopyInt24u(int8u *data, int16u index, int32u x) {
    846            data[index]   = (int8u) ( ((x)    ) & 0xFF );
   \                     emberAfCopyInt24u:
   \   00000000   0x540A             STRB     R2,[R1, R0]
    847            data[index+1] = (int8u) ( ((x)>> 8) & 0xFF );
   \   00000002   0x1808             ADDS     R0,R1,R0
   \   00000004   0x0A11             LSRS     R1,R2,#+8
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    848            data[index+2] = (int8u) ( ((x)>>16) & 0xFF );
   \   00000008   0x0C11             LSRS     R1,R2,#+16
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    849          }
   \   0000000C   0x4770             BX       LR               ;; return
    850          

   \                                 In section .text, align 2, keep-with-next
    851          void emberAfCopyInt32u(int8u *data, int16u index, int32u x) {
    852            data[index]   = (int8u) ( ((x)    ) & 0xFF );    
   \                     emberAfCopyInt32u:
   \   00000000   0x540A             STRB     R2,[R1, R0]
    853            data[index+1] = (int8u) ( ((x)>> 8) & 0xFF );  
   \   00000002   0x1808             ADDS     R0,R1,R0
   \   00000004   0x0A11             LSRS     R1,R2,#+8
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    854            data[index+2] = (int8u) ( ((x)>>16) & 0xFF );  
   \   00000008   0x0C11             LSRS     R1,R2,#+16
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    855            data[index+3] = (int8u) ( ((x)>>24) & 0xFF );
   \   0000000C   0x0E11             LSRS     R1,R2,#+24
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
    856          }
   \   00000010   0x4770             BX       LR               ;; return
    857          

   \                                 In section .text, align 2, keep-with-next
    858          void emberAfCopyString(int8u *dest, int8u *src, int8u size)
    859          {
   \                     emberAfCopyString:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4616             MOV      R6,R2
    860            if ( src == NULL ) {
   \   00000008   0xD102             BNE.N    ??emberAfCopyString_0
    861              dest[0] = 0; // Zero out the length of string
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x7020             STRB     R0,[R4, #+0]
   \   0000000E   0xBD70             POP      {R4-R6,PC}
    862            } else {
    863              int8u length = emberAfStringLength(src);
   \                     ??emberAfCopyString_0:
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       emberAfStringLength
    864              if (size < length) {
   \   00000016   0x4286             CMP      R6,R0
   \   00000018   0xBF88             IT       HI 
   \   0000001A   0x4606             MOVHI    R6,R0
    865                length = size;
    866              }
    867              MEMCOPY(dest + 1, src + 1, length);
   \   0000001C   0x4632             MOV      R2,R6
   \   0000001E   0x1C69             ADDS     R1,R5,#+1
   \   00000020   0x1C60             ADDS     R0,R4,#+1
   \   00000022   0x.... 0x....      BL       halCommonMemCopy
    868              dest[0] = length;
   \   00000026   0x7026             STRB     R6,[R4, #+0]
    869            }
    870          }
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    871          

   \                                 In section .text, align 2, keep-with-next
    872          void emberAfCopyLongString(int8u *dest, int8u *src, int16u size)
    873          {
   \                     emberAfCopyLongString:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4616             MOV      R6,R2
    874            if ( src == NULL ) {
   \   00000008   0xD103             BNE.N    ??emberAfCopyLongString_0
    875              dest[0] = dest[1] = 0; // Zero out the length of string
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x7060             STRB     R0,[R4, #+1]
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
   \   00000010   0xBD70             POP      {R4-R6,PC}
    876            } else {
    877              int16u length = emberAfLongStringLength(src);
   \                     ??emberAfCopyLongString_0:
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       emberAfLongStringLength
    878              if (size < length) {
   \   00000018   0x4286             CMP      R6,R0
   \   0000001A   0xBF88             IT       HI 
   \   0000001C   0x4606             MOVHI    R6,R0
    879                length = size;
    880              }
    881              MEMCOPY(dest + 2, src + 2, length);
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0x1CA9             ADDS     R1,R5,#+2
   \   00000022   0x1CA0             ADDS     R0,R4,#+2
   \   00000024   0x.... 0x....      BL       halCommonMemCopy
    882              dest[0] = LOW_BYTE(length);
   \   00000028   0x7026             STRB     R6,[R4, #+0]
    883              dest[1] = HIGH_BYTE(length);
   \   0000002A   0x0A30             LSRS     R0,R6,#+8
   \   0000002C   0x7060             STRB     R0,[R4, #+1]
    884            }
    885          }
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    886          
    887          #if (BIGENDIAN_CPU)
    888            #define EM_BIG_ENDIAN TRUE
    889          #else
    890            #define EM_BIG_ENDIAN FALSE
    891          #endif
    892          
    893          // You can pass in val1 as NULL, which will assume that it is
    894          // pointing to an array of all zeroes. This is used so that
    895          // default value of NULL is treated as all zeroes.

   \                                 In section .text, align 2, keep-with-next
    896          int8s emberAfCompareValues(int8u* val1,
    897                                     int8u* val2,
    898                                     int8u len,
    899                                     boolean signedNumber) 
    900          {
   \                     emberAfCompareValues:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    901            int8u i, j, k;
    902            if (signedNumber){ // signed number comparison 
   \   00000002   0x1E54             SUBS     R4,R2,#+1
   \   00000004   0xB393             CBZ.N    R3,??emberAfCompareValues_0
    903              if (len <= 4){ // only number with 32-bits or less is supported
   \   00000006   0x2A05             CMP      R2,#+5
   \   00000008   0xD245             BCS.N    ??emberAfCompareValues_1
    904                int32s accum1 = 0x0;
   \   0000000A   0x2300             MOVS     R3,#+0
    905                int32s accum2 = 0x0;
   \   0000000C   0x2500             MOVS     R5,#+0
    906                int32s all1s = -1;
    907          
    908                for (i = 0; i < len; i++) {
   \   0000000E   0x461E             MOV      R6,R3
   \   00000010   0xE00B             B.N      ??emberAfCompareValues_2
    909                  j = ( val1 == NULL 
    910                      ? 0 
    911                      : (EM_BIG_ENDIAN ? val1[i] : val1[(len-1)-i])
    912                      );
    913                  accum1 |= j << (8*(len-i));
   \                     ??emberAfCompareValues_3:
   \   00000012   0x1B97             SUBS     R7,R2,R6
   \   00000014   0x00FF             LSLS     R7,R7,#+3
   \   00000016   0xFA0C 0xFC07      LSL      R12,R12,R7
   \   0000001A   0xEA4C 0x0303      ORR      R3,R12,R3
    914          
    915                  k = (EM_BIG_ENDIAN
    916                      ? val2[i]
    917                      : val2[(len-1)-i]);
    918                  accum2 |= k << (8*(len-i));
   \   0000001E   0xF81E 0xC001      LDRB     R12,[LR, R1]
   \   00000022   0xFA0C 0xF707      LSL      R7,R12,R7
   \   00000026   0x433D             ORRS     R5,R7,R5
   \   00000028   0x1C76             ADDS     R6,R6,#+1
   \                     ??emberAfCompareValues_2:
   \   0000002A   0xB2F6             UXTB     R6,R6
   \   0000002C   0x4296             CMP      R6,R2
   \   0000002E   0xD208             BCS.N    ??emberAfCompareValues_4
   \   00000030   0xEBA4 0x0E06      SUB      LR,R4,R6
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xBF0C             ITE      EQ 
   \   00000038   0xF04F 0x0C00      MOVEQ    R12,#+0
   \   0000003C   0xF81E 0xC000      LDRBNE   R12,[LR, R0]
   \   00000040   0xE7E7             B.N      ??emberAfCompareValues_3
    919                }
    920          
    921                // sign extending, no need for 32-bits numbers
    922                if (len < 4){
   \                     ??emberAfCompareValues_4:
   \   00000042   0x2A04             CMP      R2,#+4
   \   00000044   0xD20D             BCS.N    ??emberAfCompareValues_5
    923                  if (accum1 & (1<<(8*len - 1))){ // check sign
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x00D1             LSLS     R1,R2,#+3
   \   0000004A   0x1E49             SUBS     R1,R1,#+1
   \   0000004C   0xFA00 0xF101      LSL      R1,R0,R1
   \   00000050   0x00D2             LSLS     R2,R2,#+3
   \   00000052   0x4090             LSLS     R0,R0,R2
   \   00000054   0x4240             RSBS     R0,R0,#+0
   \   00000056   0x420B             TST      R3,R1
   \   00000058   0xBF18             IT       NE 
   \   0000005A   0x4303             ORRNE    R3,R0,R3
    924                    accum1 |= all1s - ((1 << (len*8)) - 1);
    925                  }
    926                  if (accum2 & (1<<(8*len - 1))){ // check sign
   \   0000005C   0x420D             TST      R5,R1
   \   0000005E   0xBF18             IT       NE 
   \   00000060   0x4305             ORRNE    R5,R0,R5
    927                    accum2 |= all1s - ((1 << (len*8)) - 1);
    928                  }
    929                }
    930          
    931                if (accum1 > accum2) {
   \                     ??emberAfCompareValues_5:
   \   00000062   0x429D             CMP      R5,R3
   \   00000064   0xDB10             BLT.N    ??emberAfCompareValues_6
    932                  return 1;
    933                } else if (accum1 < accum2) {
   \   00000066   0x42AB             CMP      R3,R5
   \   00000068   0xDA15             BGE.N    ??emberAfCompareValues_1
    934                  return -1;
   \   0000006A   0xE011             B.N      ??emberAfCompareValues_7
    935                } else {
    936                  return 0;
    937                }
    938              } else { // not supported
    939                return 0;
    940              }
    941            } else { // regular unsigned number comparison
    942              for (i = 0; i < len; i++) {
   \                     ??emberAfCompareValues_0:
   \   0000006C   0x2600             MOVS     R6,#+0
   \   0000006E   0xE000             B.N      ??emberAfCompareValues_8
   \                     ??emberAfCompareValues_9:
   \   00000070   0x1C76             ADDS     R6,R6,#+1
   \                     ??emberAfCompareValues_8:
   \   00000072   0xB2F6             UXTB     R6,R6
   \   00000074   0x4296             CMP      R6,R2
   \   00000076   0xD20E             BCS.N    ??emberAfCompareValues_1
    943                j = ( val1 == NULL 
    944                    ? 0 
    945                    : (EM_BIG_ENDIAN ? val1[i] : val1[(len-1)-i])
    946                    );
   \   00000078   0x1BA3             SUBS     R3,R4,R6
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xBF0C             ITE      EQ 
   \   0000007E   0x2500             MOVEQ    R5,#+0
   \   00000080   0x5C1D             LDRBNE   R5,[R3, R0]
    947                k = (EM_BIG_ENDIAN
    948                    ? val2[i]
    949                    : val2[(len-1)-i]);
   \   00000082   0x5C5B             LDRB     R3,[R3, R1]
    950          
    951                if (j > k) {
   \   00000084   0x42AB             CMP      R3,R5
   \   00000086   0xDA01             BGE.N    ??emberAfCompareValues_10
    952                  return 1;
   \                     ??emberAfCompareValues_6:
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xBDF2             POP      {R1,R4-R7,PC}
    953                } else if (k > j) {
   \                     ??emberAfCompareValues_10:
   \   0000008C   0x429D             CMP      R5,R3
   \   0000008E   0xDAEF             BGE.N    ??emberAfCompareValues_9
    954                  return -1;
   \                     ??emberAfCompareValues_7:
   \   00000090   0xF04F 0x30FF      MOV      R0,#-1
   \   00000094   0xBDF2             POP      {R1,R4-R7,PC}
    955                }
    956              }
    957              return 0;
   \                     ??emberAfCompareValues_1:
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    958            }
    959          }
    960          
    961          // returns the type that the attribute is, either EMBER_AF_DATA_TYPE_ANALOG,
    962          // EMBER_AF_DATA_TYPE_DISCRETE, or EMBER_AF_DATA_TYPE_NONE. This is based on table
    963          // 2.15 from the ZCL spec 075123r02

   \                                 In section .text, align 2, keep-with-next
    964          int8u emberAfGetAttributeAnalogOrDiscreteType(int8u dataType)
    965          {
    966            int8u index = 0;
   \                     emberAfGetAttributeAnalogOrDiscreteType:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      ADR.W    R2,emberAfAnalogDiscreteThresholds
   \   00000006   0xE001             B.N      ??emberAfGetAttributeAnalogOrDiscreteType_0
    967          
    968            while ( emberAfAnalogDiscreteThresholds[index] < dataType ) {
    969              index += 2;
   \                     ??emberAfGetAttributeAnalogOrDiscreteType_1:
   \   00000008   0x1C89             ADDS     R1,R1,#+2
   \   0000000A   0xB2C9             UXTB     R1,R1
    970            }
   \                     ??emberAfGetAttributeAnalogOrDiscreteType_0:
   \   0000000C   0x5C8B             LDRB     R3,[R1, R2]
   \   0000000E   0x4283             CMP      R3,R0
   \   00000010   0xD3FA             BCC.N    ??emberAfGetAttributeAnalogOrDiscreteType_1
    971            return emberAfAnalogDiscreteThresholds[index+1];
   \   00000012   0x1888             ADDS     R0,R1,R2
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x4770             BX       LR               ;; return
    972          }
    973          
    974          // Zigbee spec says types between signed 8 bit and signed 64 bit

   \                                 In section .text, align 2, keep-with-next
    975          boolean emberAfIsTypeSigned(EmberAfAttributeType dataType) {
    976            return (dataType >= ZCL_INT8S_ATTRIBUTE_TYPE &&
    977              dataType <= ZCL_INT64S_ATTRIBUTE_TYPE);
   \                     emberAfIsTypeSigned:
   \   00000000   0xF1A0 0x0128      SUB      R1,R0,#+40
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x2908             CMP      R1,#+8
   \   00000008   0x4180             SBCS     R0,R0,R0
   \   0000000A   0x0FC0             LSRS     R0,R0,#+31
   \   0000000C   0x4770             BX       LR               ;; return
    978          }
    979          

   \                                 In section .text, align 2, keep-with-next
    980          int32u emberAfGetCurrentTime(void)
    981          {
    982          #ifdef EMBER_AF_PLUGIN_TIME_SERVER
    983            return emAfTimeClusterServerGetCurrentTime();
    984          #else
    985            return emberAfGetCurrentTimeCallback();
   \                     emberAfGetCurrentTime:
   \   00000000   0x.... 0x....      B.W      emberAfGetCurrentTimeCallback
    986          #endif
    987          }
    988          

   \                                 In section .text, align 2, keep-with-next
    989          EmberStatus emberAfEndpointEventControlSetInactive(EmberEventControl *controls,
    990                                                             int8u endpoint)
    991          {
   \                     emberAfEndpointEventControlSetInactive:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    992            int8u index = emberAfIndexFromEndpoint(endpoint);
    993            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_9:
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetInactive_0
    994              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD10             POP      {R4,PC}
    995            }
    996            emberEventControlSetInactive(controls[index]);
   \                     ??emberAfEndpointEventControlSetInactive_0:
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF804 0x1030      STRB     R1,[R4, R0, LSL #+3]
    997            return EMBER_SUCCESS;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    998          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x4608             MOV      R0,R1
   \   00000004   0x.... 0x....      B.W      emberAfIndexFromEndpoint
    999          

   \                                 In section .text, align 2, keep-with-next
   1000          boolean emberAfEndpointEventControlGetActive(EmberEventControl *controls,
   1001                                                       int8u endpoint)
   1002          {
   \                     emberAfEndpointEventControlGetActive:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
   1003            int8u index = emberAfIndexFromEndpoint(endpoint);
   1004            return (index != 0xFF && emberEventControlGetActive(controls[index]));
   \                     ??CrossCallReturnLabel_8:
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD004             BEQ.N    ??emberAfEndpointEventControlGetActive_0
   \   0000000A   0xF814 0x0030      LDRB     R0,[R4, R0, LSL #+3]
   \   0000000E   0xB110             CBZ.N    R0,??emberAfEndpointEventControlGetActive_1
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xBD10             POP      {R4,PC}
   \                     ??emberAfEndpointEventControlGetActive_0:
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??emberAfEndpointEventControlGetActive_1:
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   1005          }
   1006          

   \                                 In section .text, align 2, keep-with-next
   1007          EmberStatus emberAfEndpointEventControlSetActive(EmberEventControl *controls,
   1008                                                           int8u endpoint)
   1009          {
   \                     emberAfEndpointEventControlSetActive:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
   1010            int8u index = emberAfIndexFromEndpoint(endpoint);
   1011            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_7:
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetActive_0
   1012              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD10             POP      {R4,PC}
   1013            }
   1014            emberEventControlSetActive(controls[index]);
   \                     ??emberAfEndpointEventControlSetActive_0:
   \   0000000E   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000012   0x.... 0x....      BL       emEventControlSetActive
   1015            return EMBER_SUCCESS;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1016          }
   1017          

   \                                 In section .text, align 2, keep-with-next
   1018          EmberStatus emberAfEndpointEventControlSetDelay(EmberEventControl *controls,
   1019                                                          int8u endpoint,
   1020                                                          int32u timeMs)
   1021          {
   \                     emberAfEndpointEventControlSetDelay:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
   1022            int8u index = emberAfIndexFromEndpoint(endpoint);
   1023            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_3:
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetDelay_0
   1024              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   1025            }
   1026            return emberAfEventControlSetDelay(&controls[index], timeMs);
   \                     ??emberAfEndpointEventControlSetDelay_0:
   \   0000000E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_13:
   \   00000012   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000016   0x.... 0x....      B.W      emberAfEventControlSetDelay
   1027          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0x4629             MOV      R1,R5
   \   00000002   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000006   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x4608             MOV      R0,R1
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x.... 0x....      B.W      emberAfIndexFromEndpoint
   1028          

   \                                 In section .text, align 2, keep-with-next
   1029          EmberStatus emberAfEndpointEventControlSetDelayMS(EmberEventControl *controls,
   1030                                                            int8u endpoint,
   1031                                                            int16u delay)
   1032          {
   \                     emberAfEndpointEventControlSetDelayMS:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
   1033            int8u index = emberAfIndexFromEndpoint(endpoint);
   1034            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_2:
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetDelayMS_0
   1035              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   1036            }
   1037            emberEventControlSetDelayMS(controls[index], delay);
   \                     ??emberAfEndpointEventControlSetDelayMS_0:
   \   0000000E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_14:
   \   00000012   0x.... 0x....      BL       emEventControlSetDelayMS
   1038            return EMBER_SUCCESS;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1039          }
   1040          

   \                                 In section .text, align 2, keep-with-next
   1041          EmberStatus emberAfEndpointEventControlSetDelayQS(EmberEventControl *controls,
   1042                                                            int8u endpoint,
   1043                                                            int16u delay)
   1044          {
   \                     emberAfEndpointEventControlSetDelayQS:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
   1045            int8u index = emberAfIndexFromEndpoint(endpoint);
   1046            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_1:
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetDelayQS_0
   1047              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   1048            }
   1049            emberEventControlSetDelayQS(controls[index], delay);
   \                     ??emberAfEndpointEventControlSetDelayQS_0:
   \   0000000E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_15:
   \   00000012   0x.... 0x....      BL       emEventControlSetDelayQS
   1050            return EMBER_SUCCESS;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1051          }
   1052          

   \                                 In section .text, align 2, keep-with-next
   1053          EmberStatus emberAfEndpointEventControlSetDelayMinutes(EmberEventControl *controls,
   1054                                                                 int8u endpoint,
   1055                                                                 int16u delay)
   1056          {
   \                     emberAfEndpointEventControlSetDelayMinutes:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
   1057            int8u index = emberAfIndexFromEndpoint(endpoint);
   1058            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_0:
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetDelayMinutes_0
   1059              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   1060            }
   1061            emberEventControlSetDelayMinutes(controls[index], delay);
   \                     ??emberAfEndpointEventControlSetDelayMinutes_0:
   \   0000000E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_16:
   \   00000012   0x.... 0x....      BL       emEventControlSetDelayMinutes
   1062            return EMBER_SUCCESS;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1063          }
   1064          
   1065          // *******************************************************
   1066          // emberAfPrintTime and emberAfSetTime are convienience methods for setting
   1067          // and displaying human readable times.
   1068          
   1069          // Expects to be passed a ZigBee time which is the number of seconds
   1070          // since the year 2000

   \                                 In section .text, align 2, keep-with-next
   1071          void emberAfSetTime(int32u utcTime) {
   1072          #ifdef EMBER_AF_PLUGIN_TIME_SERVER
   1073            emAfTimeClusterServerSetCurrentTime(utcTime);
   1074          #endif //EMBER_AF_PLUGIN_TIME_SERVER
   1075            emberAfSetTimeCallback(utcTime);
   \                     emberAfSetTime:
   \   00000000   0x.... 0x....      B.W      emberAfSetTimeCallback
   1076          }
   1077          

   \                                 In section .text, align 2, keep-with-next
   1078          void emberAfFillTimeStructFromUtc(int32u utcTime,
   1079                                            EmberAfTimeStruct* returnTime)
   1080          {
   \                     emberAfFillTimeStructFromUtc:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   1081            int32u i;
   1082            int32u daysSince2000 = utcTime / SECONDS_IN_DAY;
   \   00000002   0x....             LDR.N    R3,??DataTable53_11  ;; 0x15180
   \   00000004   0xFBB0 0xF2F3      UDIV     R2,R0,R3
   1083            int32u secToday = utcTime - (daysSince2000 * SECONDS_IN_DAY);
   \   00000008   0xFB03 0x0012      MLS      R0,R3,R2,R0
   1084            returnTime->hours = (int8u)(secToday / SECONDS_IN_HOUR);
   \   0000000C   0xF44F 0x6361      MOV      R3,#+3600
   \   00000010   0xFBB0 0xF4F3      UDIV     R4,R0,R3
   \   00000014   0x710C             STRB     R4,[R1, #+4]
   \   00000016   0x790C             LDRB     R4,[R1, #+4]
   \   00000018   0x4363             MULS     R3,R3,R4
   \   0000001A   0x243C             MOVS     R4,#+60
   \   0000001C   0x1AC5             SUBS     R5,R0,R3
   \   0000001E   0xFBB5 0xF5F4      UDIV     R5,R5,R4
   \   00000022   0x714D             STRB     R5,[R1, #+5]
   1085            returnTime->minutes = (int8u)((secToday
   1086                                          - (returnTime->hours * SECONDS_IN_HOUR)) / 60);
   1087            returnTime->seconds = (int8u)(secToday
   1088                                          - ((returnTime->hours * SECONDS_IN_HOUR)
   1089                                             + (returnTime->minutes * 60)));
   \   00000024   0x794D             LDRB     R5,[R1, #+5]
   \   00000026   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   0000002A   0x1AC0             SUBS     R0,R0,R3
   \   0000002C   0x7188             STRB     R0,[R1, #+6]
   1090            returnTime->year = 2000;
   \   0000002E   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000032   0x8008             STRH     R0,[R1, #+0]
   1091            returnTime->month = 1;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x7088             STRB     R0,[R1, #+2]
   1092            returnTime->day = 1;
   \   00000038   0x70C8             STRB     R0,[R1, #+3]
   1093            boolean isLeapYear = TRUE; // 2000 was a leap year
   \   0000003A   0x2601             MOVS     R6,#+1
   1094            
   1095            // march through the calendar, counting months, days and years
   1096            // being careful to account for leapyears.
   1097            for (i = 0; i < daysSince2000; i++) {
   \   0000003C   0x2500             MOVS     R5,#+0
   \   0000003E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000042   0x2364             MOVS     R3,#+100
   \   00000044   0x.... 0x....      ADR.W    R4,emberAfDaysInMonth
   \   00000048   0xE001             B.N      ??emberAfFillTimeStructFromUtc_0
   1098              int8u daysInMonth;
   1099              if (isLeapYear && (returnTime->month == 2)) {
   1100                daysInMonth = 29;
   1101              } else {
   1102                daysInMonth = emberAfDaysInMonth[returnTime->month - 1];
   1103              }
   1104              if (daysInMonth == returnTime->day) {
   1105                returnTime->month++;
   1106                returnTime->day = 1;
   1107              } else {
   1108                returnTime->day++;
   1109              }
   1110              if (returnTime->month == 13) {
   1111                returnTime->year++;
   1112                returnTime->month = 1;
   1113                if (returnTime->year % 4 == 0 && 
   1114                    (returnTime->year % 100 != 0 || 
   1115                     (returnTime->year % 400 == 0)))
   1116                  isLeapYear = TRUE;
   1117                else
   1118                  isLeapYear = FALSE;
   \                     ??emberAfFillTimeStructFromUtc_1:
   \   0000004A   0x2600             MOVS     R6,#+0
   \                     ??emberAfFillTimeStructFromUtc_2:
   \   0000004C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??emberAfFillTimeStructFromUtc_0:
   \   0000004E   0x4295             CMP      R5,R2
   \   00000050   0xD22F             BCS.N    ??emberAfFillTimeStructFromUtc_3
   \   00000052   0x788F             LDRB     R7,[R1, #+2]
   \   00000054   0xB126             CBZ.N    R6,??emberAfFillTimeStructFromUtc_4
   \   00000056   0x2F02             CMP      R7,#+2
   \   00000058   0xBF08             IT       EQ 
   \   0000005A   0xF04F 0x0C1D      MOVEQ    R12,#+29
   \   0000005E   0xD003             BEQ.N    ??emberAfFillTimeStructFromUtc_5
   \                     ??emberAfFillTimeStructFromUtc_4:
   \   00000060   0xEB07 0x0C04      ADD      R12,R7,R4
   \   00000064   0xF81C 0xCC01      LDRB     R12,[R12, #-1]
   \                     ??emberAfFillTimeStructFromUtc_5:
   \   00000068   0xF891 0xE003      LDRB     LR,[R1, #+3]
   \   0000006C   0x45F4             CMP      R12,LR
   \   0000006E   0xBF03             ITTTE    EQ 
   \   00000070   0x1C7F             ADDEQ    R7,R7,#+1
   \   00000072   0x708F             STRBEQ   R7,[R1, #+2]
   \   00000074   0x2701             MOVEQ    R7,#+1
   \   00000076   0xF10E 0x0701      ADDNE    R7,LR,#+1
   \   0000007A   0x70CF             STRB     R7,[R1, #+3]
   \   0000007C   0x788F             LDRB     R7,[R1, #+2]
   \   0000007E   0x2F0D             CMP      R7,#+13
   \   00000080   0xD1E4             BNE.N    ??emberAfFillTimeStructFromUtc_2
   \   00000082   0x880E             LDRH     R6,[R1, #+0]
   \   00000084   0x1C77             ADDS     R7,R6,#+1
   \   00000086   0x800F             STRH     R7,[R1, #+0]
   \   00000088   0x2601             MOVS     R6,#+1
   \   0000008A   0x708E             STRB     R6,[R1, #+2]
   \   0000008C   0x2603             MOVS     R6,#+3
   \   0000008E   0x4237             TST      R7,R6
   \   00000090   0xD1DB             BNE.N    ??emberAfFillTimeStructFromUtc_1
   \   00000092   0xB2BF             UXTH     R7,R7
   \   00000094   0xFB97 0xF6F3      SDIV     R6,R7,R3
   \   00000098   0xFB03 0x7616      MLS      R6,R3,R6,R7
   \   0000009C   0xB93E             CBNZ.N   R6,??emberAfFillTimeStructFromUtc_6
   \   0000009E   0xFB97 0xF6F0      SDIV     R6,R7,R0
   \   000000A2   0xFB00 0x7616      MLS      R6,R0,R6,R7
   \   000000A6   0x1E76             SUBS     R6,R6,#+1
   \   000000A8   0x41B6             SBCS     R6,R6,R6
   \   000000AA   0x0FF6             LSRS     R6,R6,#+31
   \   000000AC   0xE7CE             B.N      ??emberAfFillTimeStructFromUtc_2
   \                     ??emberAfFillTimeStructFromUtc_6:
   \   000000AE   0x2601             MOVS     R6,#+1
   \   000000B0   0xE7CC             B.N      ??emberAfFillTimeStructFromUtc_2
   1119              }
   1120            }
   1121          }
   \                     ??emberAfFillTimeStructFromUtc_3:
   \   000000B2   0xBDF0             POP      {R4-R7,PC}       ;; return
   1122          
   1123          // emberAfPrintTime expects to be passed a ZigBee time which is the number
   1124          // of seconds since the year 2000, it prints out a human readable time
   1125          // from that value.

   \                                 In section .text, align 2, keep-with-next
   1126          void emberAfPrintTime(int32u utcTime)
   1127          {
   \                     emberAfPrintTime:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0
   1128          #ifdef EMBER_AF_PRINT_ENABLE
   1129            EmberAfTimeStruct time;
   1130            emberAfFillTimeStructFromUtc(utcTime, &time);
   \   00000006   0xA905             ADD      R1,SP,#+20
   \   00000008   0x.... 0x....      BL       emberAfFillTimeStructFromUtc
   1131            emberAfPrintln(emberAfPrintActiveArea,
   1132                           "UTC time: %d/%d/%d %d:%d:%d (%4x)",
   1133                           time.month,
   1134                           time.day,
   1135                           time.year,
   1136                           time.hours,
   1137                           time.minutes,
   1138                           time.seconds,
   1139                           utcTime);
   \   0000000C   0x9404             STR      R4,[SP, #+16]
   \   0000000E   0xF89D 0x001A      LDRB     R0,[SP, #+26]
   \   00000012   0x9003             STR      R0,[SP, #+12]
   \   00000014   0xF89D 0x0019      LDRB     R0,[SP, #+25]
   \   00000018   0x9002             STR      R0,[SP, #+8]
   \   0000001A   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000001E   0x9001             STR      R0,[SP, #+4]
   \   00000020   0xF8BD 0x0014      LDRH     R0,[SP, #+20]
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0xF89D 0x3017      LDRB     R3,[SP, #+23]
   \   0000002A   0xF89D 0x2016      LDRB     R2,[SP, #+22]
   \   0000002E   0x.... 0x....      ADR.W    R1,`?<Constant "UTC time: %d/%d/%d %d...">`
   \   00000032   0x....             LDR.N    R0,??DataTable53_7
   \   00000034   0x8800             LDRH     R0,[R0, #+0]
   \   00000036   0x.... 0x....      BL       emberAfPrintln
   1140          #endif //EMBER_AF_PRINT_ENABLE
   1141          }
   \   0000003A   0xB008             ADD      SP,SP,#+32
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1142          
   1143          #if EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE == 0
   1144          int8u emberAfAddAddressTableEntry(EmberEUI64 longId, EmberNodeId shortId)
   1145          {
   1146            return EMBER_NULL_ADDRESS_TABLE_INDEX;
   1147          }
   1148          
   1149          EmberStatus emberAfSetAddressTableEntry(int8u index,
   1150                                                  EmberEUI64 longId,
   1151                                                  EmberNodeId shortId)
   1152          {
   1153            return EMBER_ADDRESS_TABLE_INDEX_OUT_OF_RANGE;
   1154          }
   1155          
   1156          EmberStatus emberAfRemoveAddressTableEntry(int8u index)
   1157          {
   1158            return EMBER_ADDRESS_TABLE_INDEX_OUT_OF_RANGE;
   1159          }
   1160          
   1161          #else
   1162          

   \                                 In section .text, align 2, keep-with-next
   1163          int8u emberAfAddAddressTableEntry(EmberEUI64 longId, EmberNodeId shortId)
   1164          {
   \                     emberAfAddAddressTableEntry:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   1165            int8u i, index = EMBER_NULL_ADDRESS_TABLE_INDEX;
   \   00000008   0x24FF             MOVS     R4,#+255
   1166            for (i = 0; i < EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE; i++) {
   \   0000000A   0x2700             MOVS     R7,#+0
   1167              if (emberGetAddressTableRemoteNodeId(i)
   1168                  != EMBER_TABLE_ENTRY_UNUSED_NODE_ID) {
   \                     ??emberAfAddAddressTableEntry_0:
   \   0000000C   0x4638             MOV      R0,R7
   \   0000000E   0x.... 0x....      BL       emberGetAddressTableRemoteNodeId
   \   00000012   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD00B             BEQ.N    ??emberAfAddAddressTableEntry_1
   1169                EmberEUI64 eui64;
   1170                emberGetAddressTableRemoteEui64(i, eui64);
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x4638             MOV      R0,R7
   \   0000001E   0x.... 0x....      BL       emberGetAddressTableRemoteEui64
   1171                if (MEMCOMPARE(longId, eui64, EUI64_SIZE) == 0) {
   \   00000022   0x2208             MOVS     R2,#+8
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       halCommonMemCompare
   \   0000002C   0xB920             CBNZ.N   R0,??emberAfAddAddressTableEntry_2
   1172                  index = i;
   \   0000002E   0x463C             MOV      R4,R7
   1173                  goto kickout;
   \   00000030   0xE00C             B.N      ??emberAfAddAddressTableEntry_3
   1174                }
   1175              } else if (index == EMBER_NULL_ADDRESS_TABLE_INDEX) {
   \                     ??emberAfAddAddressTableEntry_1:
   \   00000032   0x2CFF             CMP      R4,#+255
   \   00000034   0xBF08             IT       EQ 
   \   00000036   0x463C             MOVEQ    R4,R7
   1176                index = i;
   1177              }
   1178            }
   \                     ??emberAfAddAddressTableEntry_2:
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \   0000003A   0xB2FF             UXTB     R7,R7
   \   0000003C   0x2F02             CMP      R7,#+2
   \   0000003E   0xD3E5             BCC.N    ??emberAfAddAddressTableEntry_0
   1179            if (index != EMBER_NULL_ADDRESS_TABLE_INDEX) {
   \   00000040   0x2CFF             CMP      R4,#+255
   \   00000042   0xD00F             BEQ.N    ??emberAfAddAddressTableEntry_4
   1180              emberSetAddressTableRemoteEui64(index, longId);
   \   00000044   0x4629             MOV      R1,R5
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       emberSetAddressTableRemoteEui64
   1181          kickout:
   1182              if (shortId != EMBER_UNKNOWN_NODE_ID) {
   \                     ??emberAfAddAddressTableEntry_3:
   \   0000004C   0xF64F 0x70FD      MOVW     R0,#+65533
   \   00000050   0x4286             CMP      R6,R0
   \   00000052   0xD003             BEQ.N    ??emberAfAddAddressTableEntry_5
   1183                emberSetAddressTableRemoteNodeId(index, shortId);
   \   00000054   0x4631             MOV      R1,R6
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       emberSetAddressTableRemoteNodeId
   1184              }
   1185              addressTableReferenceCounts[index]++;
   \                     ??emberAfAddAddressTableEntry_5:
   \   0000005C   0x....             LDR.N    R0,??DataTable53_12
   \   0000005E   0x5C21             LDRB     R1,[R4, R0]
   \   00000060   0x1C49             ADDS     R1,R1,#+1
   \   00000062   0x5421             STRB     R1,[R4, R0]
   1186            }
   1187            return index;
   \                     ??emberAfAddAddressTableEntry_4:
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0xBDFE             POP      {R1-R7,PC}       ;; return
   1188          }
   1189          

   \                                 In section .text, align 2, keep-with-next
   1190          EmberStatus emberAfSetAddressTableEntry(int8u index,
   1191                                                  EmberEUI64 longId,
   1192                                                  EmberNodeId shortId)
   1193          {
   \                     emberAfSetAddressTableEntry:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
   1194            EmberStatus status = EMBER_ADDRESS_TABLE_INDEX_OUT_OF_RANGE;
   \   00000006   0x266A             MOVS     R6,#+106
   1195            if (index < EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE) {
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xD213             BCS.N    ??emberAfSetAddressTableEntry_0
   1196              if (addressTableReferenceCounts[index] == 0) {
   \   0000000C   0x....             LDR.N    R7,??DataTable53_12
   \   0000000E   0x5DE0             LDRB     R0,[R4, R7]
   \   00000010   0xB978             CBNZ.N   R0,??emberAfSetAddressTableEntry_1
   1197                status = emberSetAddressTableRemoteEui64(index, longId);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       emberSetAddressTableRemoteEui64
   \   00000018   0x0006             MOVS     R6,R0
   1198                if (status == EMBER_SUCCESS && shortId != EMBER_UNKNOWN_NODE_ID) {
   \   0000001A   0xD107             BNE.N    ??emberAfSetAddressTableEntry_2
   \   0000001C   0xF64F 0x70FD      MOVW     R0,#+65533
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD003             BEQ.N    ??emberAfSetAddressTableEntry_2
   1199                  emberSetAddressTableRemoteNodeId(index, shortId);
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       emberSetAddressTableRemoteNodeId
   1200                }
   1201                addressTableReferenceCounts[index] = 1;
   \                     ??emberAfSetAddressTableEntry_2:
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x55E0             STRB     R0,[R4, R7]
   \   00000030   0xE000             B.N      ??emberAfSetAddressTableEntry_0
   1202              } else {
   1203                status = EMBER_ADDRESS_TABLE_ENTRY_IS_ACTIVE;
   \                     ??emberAfSetAddressTableEntry_1:
   \   00000032   0x2676             MOVS     R6,#+118
   1204              }
   1205            }
   1206            return status;
   \                     ??emberAfSetAddressTableEntry_0:
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1207          }
   1208          

   \                                 In section .text, align 2, keep-with-next
   1209          EmberStatus emberAfRemoveAddressTableEntry(int8u index)
   1210          {
   \                     emberAfRemoveAddressTableEntry:
   \   00000000   0x4602             MOV      R2,R0
   1211            EmberStatus status = EMBER_ADDRESS_TABLE_INDEX_OUT_OF_RANGE;
   \   00000002   0x206A             MOVS     R0,#+106
   1212            if (index < EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE) {
   \   00000004   0x2A02             CMP      R2,#+2
   \   00000006   0xD300             BCC.N    ??emberAfRemoveAddressTableEntry_0
   1213              if (0 < addressTableReferenceCounts[index]) {
   \   00000008   0x4770             BX       LR
   \                     ??emberAfRemoveAddressTableEntry_0:
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x....             LDR.N    R1,??DataTable53_12
   \   00000010   0x5C43             LDRB     R3,[R0, R1]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xBF1F             ITTTT    NE 
   \   00000016   0x1E5B             SUBNE    R3,R3,#+1
   \   00000018   0x5443             STRBNE   R3,[R0, R1]
   \   0000001A   0xB2DB             UXTBNE   R3,R3
   \   0000001C   0x2B00             CMPNE    R3,#+0
   1214                addressTableReferenceCounts[index]--;
   1215              }
   1216              if (addressTableReferenceCounts[index] == 0) {
   \   0000001E   0xBF04             ITT      EQ 
   \   00000020   0xF64F 0x71FF      MOVWEQ   R1,#+65535
   \   00000024   0x.... 0x....      BLEQ     emberSetAddressTableRemoteNodeId
   1217                emberSetAddressTableRemoteNodeId(index,
   1218                                                 EMBER_TABLE_ENTRY_UNUSED_NODE_ID);
   1219              }
   1220              status = EMBER_SUCCESS;
   \   00000028   0x2000             MOVS     R0,#+0
   1221            }
   1222            return status;
   \   0000002A   0xBD02             POP      {R1,PC}          ;; return
   1223          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \   00000000   0x5D 0x00          DC8      "]",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \   00000000   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_1:
   \   00000000   0x5D 0x00          DC8      "]",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \   00000000   0x........         DC32     ??lastBlinkTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_1:
   \   00000000   0x........         DC32     afDeviceEnabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_2:
   \   00000000   0x........         DC32     emberAfResponseApsFrame

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_3:
   \   00000000   0x........         DC32     emberAfIncomingZclSequenceNumber

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_4:
   \   00000000   0x........         DC32     emberAfResponseDestination

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_5:
   \   00000000   0x........         DC32     appResponseLength

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_6:
   \   00000000   0x........         DC32     appResponseData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_7:
   \   00000000   0x........         DC32     emberAfPrintActiveArea

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_8:
   \   00000000   0x........         DC32     emberAfPrintReceivedMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_9:
   \   00000000   0x........         DC32     emAfEndpoints

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_10:
   \   00000000   0x........         DC32     emberAfSequenceNumber

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_11:
   \   00000000   0x00015180         DC32     0x15180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_12:
   \   00000000   0x........         DC32     addressTableReferenceCounts

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "(Unknown clus. [0x%2x])">`:
   \   00000000   0x28 0x55          DC8 "(Unknown clus. [0x%2x])"
   \              0x6E 0x6B    
   \              0x6E 0x6F    
   \              0x77 0x6E    
   \              0x20 0x63    
   \              0x6C 0x75    
   \              0x73 0x2E    
   \              0x20 0x5B    
   \              0x30 0x78    
   \              0x25 0x32    
   \              0x78 0x5D    
   \              0x29 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "(%p)">`:
   \   00000000   0x28 0x25          DC8 "(%p)"
   \              0x70 0x29    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Basic">`:
   \   00000000   0x42 0x61          DC8 "Basic"
   \              0x73 0x69    
   \              0x63 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Identify">`:
   \   00000000   0x49 0x64          DC8 "Identify"
   \              0x65 0x6E    
   \              0x74 0x69    
   \              0x66 0x79    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Over the Air Bootloading">`:
   \   00000000   0x4F 0x76          DC8 "Over the Air Bootloading"
   \              0x65 0x72    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x41    
   \              0x69 0x72    
   \              0x20 0x42    
   \              0x6F 0x6F    
   \              0x74 0x6C    
   \              0x6F 0x61    
   \              0x64 0x69    
   \              0x6E 0x67    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "IAS Zone">`:
   \   00000000   0x49 0x41          DC8 "IAS Zone"
   \              0x53 0x20    
   \              0x5A 0x6F    
   \              0x6E 0x65    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\nT%4x:">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012T%4x:"
   \              0x54 0x25    
   \              0x34 0x78    
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "RX len %d, ep %x, clu...">`:
   \   00000000   0x52 0x58          DC8 "RX len %d, ep %x, clus 0x%2x "
   \              0x20 0x6C    
   \              0x65 0x6E    
   \              0x20 0x25    
   \              0x64 0x2C    
   \              0x20 0x65    
   \              0x70 0x20    
   \              0x25 0x78    
   \              0x2C 0x20    
   \              0x63 0x6C    
   \              0x75 0x73    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x32 0x78    
   \              0x20 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " mfgId %2x">`:
   \   00000000   0x20 0x6D          DC8 " mfgId %2x"
   \              0x66 0x67    
   \              0x49 0x64    
   \              0x20 0x25    
   \              0x32 0x78    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " FC %x seq %x cmd %x ...">`:
   \   00000000   0x20 0x46          DC8 " FC %x seq %x cmd %x payload["
   \              0x43 0x20    
   \              0x25 0x78    
   \              0x20 0x73    
   \              0x65 0x71    
   \              0x20 0x25    
   \              0x78 0x20    
   \              0x63 0x6D    
   \              0x64 0x20    
   \              0x25 0x78    
   \              0x20 0x70    
   \              0x61 0x79    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x5B 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Drop cluster 0x%2x co...">`:
   \   00000000   0x44 0x72          DC8 "Drop cluster 0x%2x command 0x%x"
   \              0x6F 0x70    
   \              0x20 0x63    
   \              0x6C 0x75    
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x32 0x78    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x78 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " due to invalid endpo...">`:
   \   00000000   0x20 0x64          DC8 " due to invalid endpoint: "
   \              0x75 0x65    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x69 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x65 0x6E    
   \              0x64 0x70    
   \              0x6F 0x69    
   \              0x6E 0x74    
   \              0x3A 0x20    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "0x%x">`:
   \   00000000   0x30 0x78          DC8 "0x%x"
   \              0x25 0x78    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " for endpoint 0x%x du...">`:
   \   00000000   0x20 0x66          DC8 " for endpoint 0x%x due to wrong %p: "
   \              0x6F 0x72    
   \              0x20 0x65    
   \              0x6E 0x64    
   \              0x70 0x6F    
   \              0x69 0x6E    
   \              0x74 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x20 0x64    
   \              0x75 0x65    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x77 0x72    
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x25 0x70    
   \              0x3A 0x20    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "]">`:
   \   00000000   0x5D 0x00          DC8 "]"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%d">`:
   \   00000000   0x25 0x64          DC8 "%d"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   00000000   0x00               DC8 ""

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "network">`:
   \   00000000   0x6E 0x65          DC8 "network"
   \              0x74 0x77    
   \              0x6F 0x72    
   \              0x6B 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "profile">`:
   \   00000000   0x70 0x72          DC8 "profile"
   \              0x6F 0x66    
   \              0x69 0x6C    
   \              0x65 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "0x%2x">`:
   \   00000000   0x30 0x78          DC8 "0x%2x"
   \              0x25 0x32    
   \              0x78 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "group">`:
   \   00000000   0x67 0x72          DC8 "group"
   \              0x6F 0x75    
   \              0x70 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%pRX pkt too short!">`:
   \   00000000   0x25 0x70          DC8 "%pRX pkt too short!"
   \              0x52 0x58    
   \              0x20 0x70    
   \              0x6B 0x74    
   \              0x20 0x74    
   \              0x6F 0x6F    
   \              0x20 0x73    
   \              0x68 0x6F    
   \              0x72 0x74    
   \              0x21 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ERROR: ">`:
   \   00000000   0x45 0x52          DC8 "ERROR: "
   \              0x52 0x4F    
   \              0x52 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Drop clus %2x due to ...">`:
   \   00000000   0x44 0x72          DC8 "Drop clus %2x due to no aps security"
   \              0x6F 0x70    
   \              0x20 0x63    
   \              0x6C 0x75    
   \              0x73 0x20    
   \              0x25 0x32    
   \              0x78 0x20    
   \              0x64 0x75    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x6E    
   \              0x6F 0x20    
   \              0x61 0x70    
   \              0x73 0x20    
   \              0x73 0x65    
   \              0x63 0x75    
   \              0x72 0x69    
   \              0x74 0x79    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ZCL Util: no response...">`:
   \   00000000   0x5A 0x43          DC8 "ZCL Util: no response at user request"
   \              0x4C 0x20    
   \              0x55 0x74    
   \              0x69 0x6C    
   \              0x3A 0x20    
   \              0x6E 0x6F    
   \              0x20 0x72    
   \              0x65 0x73    
   \              0x70 0x6F    
   \              0x6E 0x73    
   \              0x65 0x20    
   \              0x61 0x74    
   \              0x20 0x75    
   \              0x73 0x65    
   \              0x72 0x20    
   \              0x72 0x65    
   \              0x71 0x75    
   \              0x65 0x73    
   \              0x74 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "T%4x:TX (%p) %ccast 0...">`:
   \   00000000   0x54 0x25          DC8 "T%4x:TX (%p) %ccast 0x%x%p"
   \              0x34 0x78    
   \              0x3A 0x54    
   \              0x58 0x20    
   \              0x28 0x25    
   \              0x70 0x29    
   \              0x20 0x25    
   \              0x63 0x63    
   \              0x61 0x73    
   \              0x74 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x25 0x70    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "resp">`:
   \   00000000   0x72 0x65          DC8 "resp"
   \              0x73 0x70    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " w/ link key">`:
   \   00000000   0x20 0x77          DC8 " w/ link key"
   \              0x2F 0x20    
   \              0x6C 0x69    
   \              0x6E 0x6B    
   \              0x20 0x6B    
   \              0x65 0x79    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TX buffer: [">`:
   \   00000000   0x54 0x58          DC8 "TX buffer: ["
   \              0x20 0x62    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x3A    
   \              0x20 0x5B    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "UTC time: %d/%d/%d %d...">`:
   \   00000000   0x55 0x54          DC8 "UTC time: %d/%d/%d %d:%d:%d (%4x)"
   \              0x43 0x20    
   \              0x74 0x69    
   \              0x6D 0x65    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x2F 0x25    
   \              0x64 0x2F    
   \              0x25 0x64    
   \              0x20 0x25    
   \              0x64 0x3A    
   \              0x25 0x64    
   \              0x3A 0x25    
   \              0x64 0x20    
   \              0x28 0x25    
   \              0x34 0x78    
   \              0x29 0x00    
   \   00000022   0x00 0x00          DC8 0, 0
   1224          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  dispatchZclMessage
             24 -> emAfProcessClusterSpecificCommand
              0 -> emAfProcessGlobalCommand
             24 -> emberAfGroupsClusterEndpointInGroupCallback
             24 -> emberAfIndexFromEndpoint
             24 -> emberAfPrint
             24 -> emberAfPrintln
       32  emberAfAddAddressTableEntry
             32 -> emberGetAddressTableRemoteEui64
             32 -> emberGetAddressTableRemoteNodeId
             32 -> emberSetAddressTableRemoteEui64
             32 -> emberSetAddressTableRemoteNodeId
             32 -> halCommonMemCompare
       24  emberAfCompareValues
        0  emberAfCopyInt16u
        0  emberAfCopyInt24u
        0  emberAfCopyInt32u
       16  emberAfCopyLongString
             16 -> emberAfLongStringLength
             16 -> halCommonMemCopy
       16  emberAfCopyString
             16 -> emberAfStringLength
             16 -> halCommonMemCopy
       16  emberAfDecodeAndPrintCluster
             16 -> emberAfFindClusterNameIndex
              0 -> emberAfFlush
             16 -> emberAfPrint
       16  emberAfDetermineIfLinkSecurityIsRequired
             16 -> emberAfClusterSecurityCustomCallback
        8  emberAfEndpointEventControlGetActive
              8 -> emberAfIndexFromEndpoint
        8  emberAfEndpointEventControlSetActive
              8 -> emEventControlSetActive
              8 -> emberAfIndexFromEndpoint
       16  emberAfEndpointEventControlSetDelay
              0 -> emberAfEventControlSetDelay
             16 -> emberAfIndexFromEndpoint
       16  emberAfEndpointEventControlSetDelayMS
             16 -> emEventControlSetDelayMS
             16 -> emberAfIndexFromEndpoint
       16  emberAfEndpointEventControlSetDelayMinutes
             16 -> emEventControlSetDelayMinutes
             16 -> emberAfIndexFromEndpoint
       16  emberAfEndpointEventControlSetDelayQS
             16 -> emEventControlSetDelayQS
             16 -> emberAfIndexFromEndpoint
        8  emberAfEndpointEventControlSetInactive
              8 -> emberAfIndexFromEndpoint
       20  emberAfFillTimeStructFromUtc
        8  emberAfFindClusterNameIndex
        0  emberAfGetAttributeAnalogOrDiscreteType
        0  emberAfGetCurrentTime
              0 -> emberAfGetCurrentTimeCallback
       12  emberAfGetDifference
        0  emberAfGetLastSequenceNumber
        8  emberAfInit
              0 -> emAfCallInits
              8 -> emAfInitEvents
              8 -> emberAfEndpointCount
              8 -> emberAfInitializeAttributes
              8 -> emberAfPluginAddressTableInitCallback
              8 -> emberAfPluginBatteryMonitorInitCallback
              8 -> emberAfPluginCountersInitCallback
              8 -> emberAfPluginEndDeviceSupportInitCallback
              8 -> emberAfPluginNetworkFindInitCallback
              8 -> emberAfPluginReportingInitCallback
              8 -> emberAfPluginSensorIfaceInitCallback
              8 -> emberAfPopNetworkIndex
              8 -> emberAfPushNetworkIndex
              8 -> emberAfSetExternalBuffer
              8 -> halCommonMemSet
        8  emberAfIsDeviceEnabled
              8 -> emberAfIndexFromEndpoint
       16  emberAfIsDeviceIdentifying
             16 -> emberAfReadServerAttribute
        0  emberAfIsTypeSigned
       16  emberAfMaximumApsPayloadLength
             16 -> emberAfGetSourceRouteOverheadCallback
             16 -> emberGetAddressTableRemoteNodeId
             16 -> emberGetBindingRemoteNodeId
        0  emberAfNextSequence
       40  emberAfPrintTime
             40 -> emberAfFillTimeStructFromUtc
             40 -> emberAfPrintln
       56  emberAfProcessMessage
             56 -> dispatchZclMessage
             56 -> emberAfClearResponseData
             56 -> emberAfDetermineIfLinkSecurityIsRequired
             56 -> emberAfEndpointCount
             56 -> emberAfEndpointFromIndex
             56 -> emberAfEndpointIndexIsEnabled
             56 -> emberAfGetInt16u
             56 -> emberAfPreCommandReceivedCallback
             56 -> emberAfPrintln
             56 -> emberAfSendDefaultResponse
             56 -> emberGetCurrentNetwork
             56 -> halCommonMemSet
             56 -> prepareForResponse
             56 -> printIncomingZclMessage
        8  emberAfRemoveAddressTableEntry
              8 -> emberSetAddressTableRemoteNodeId
        0  emberAfSendDefaultResponse
              0 -> emberAfSendDefaultResponseWithCallback
       16  emberAfSendDefaultResponseWithCallback
             16 -> emberAfPutInt16uInResp
             16 -> emberAfPutInt8uInResp
              0 -> emberAfSendResponseWithCallback
             16 -> prepareForResponse
        0  emberAfSendImmediateDefaultResponse
              0 -> emberAfSendImmediateDefaultResponseWithCallback
        0  emberAfSendImmediateDefaultResponseWithCallback
              0 -> emberAfSendDefaultResponseWithCallback
        0  emberAfSendResponse
              0 -> emberAfSendResponseWithCallback
       40  emberAfSendResponseWithCallback
             40 -> emberAfGetCurrentTimeCallback
             40 -> emberAfInterpanSendMessageCallback
             40 -> emberAfPrint
             40 -> emberAfPrintBuffer
             40 -> emberAfPrintln
             40 -> emberAfSendBroadcastWithCallback
             40 -> emberAfSendUnicastWithCallback
       24  emberAfSetAddressTableEntry
             24 -> emberSetAddressTableRemoteEui64
             24 -> emberSetAddressTableRemoteNodeId
        8  emberAfSetDeviceEnabled
              8 -> emberAfIndexFromEndpoint
        0  emberAfSetNoReplyForNextMessage
        0  emberAfSetTime
              0 -> emberAfSetTimeCallback
        8  emberAfStackDown
              8 -> emberAfClearReportTableCallback
              8 -> emberAfRegistrationAbortCallback
              0 -> emberAfTrustCenterKeepaliveAbortCallback
              8 -> emberNetworkState
              8 -> emberStackIsPerformingRejoin
       16  emberAfTick
             16 -- Indirect call
             16 -> emAfGetCryptoStatus
        8  platformTick
              8 -> emberAfCheckForSleepCallback
              8 -> emberAfSchedulePollEventCallback
              8 -> halCommonGetInt16uMillisecondTick
        8  prepareForResponse
              8 -> halCommonMemCopy
       16  printIncomingZclMessage
             16 -> emberAfDecodeAndPrintCluster
             16 -> emberAfGetCurrentTimeCallback
             16 -> emberAfPrint
             16 -> emberAfPrintBuffer
             16 -> emberAfPrintEnabled
              0 -> emberAfPrintln


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant " FC %x seq %x cmd %x ...">
      28  ?<Constant " due to invalid endpo...">
      40  ?<Constant " for endpoint 0x%x du...">
      12  ?<Constant " mfgId %2x">
      16  ?<Constant " w/ link key">
       1  ?<Constant "">
       4  ?<Constant "%d">
      20  ?<Constant "%pRX pkt too short!">
       8  ?<Constant "(%p)">
      24  ?<Constant "(Unknown clus. [0x%2x])">
       8  ?<Constant "0x%2x">
       8  ?<Constant "0x%x">
       8  ?<Constant "Basic">
      40  ?<Constant "Drop clus %2x due to ...">
      32  ?<Constant "Drop cluster 0x%2x co...">
       8  ?<Constant "ERROR: ">
      12  ?<Constant "IAS Zone">
      12  ?<Constant "Identify">
      28  ?<Constant "Over the Air Bootloading">
      32  ?<Constant "RX len %d, ep %x, clu...">
      28  ?<Constant "T%4x:TX (%p) %ccast 0...">
      16  ?<Constant "TX buffer: [">
      36  ?<Constant "UTC time: %d/%d/%d %d...">
      40  ?<Constant "ZCL Util: no response...">
       8  ?<Constant "\r\nT%4x:">
       2  ?<Constant "]">
       8  ?<Constant "group">
       8  ?<Constant "network">
       8  ?<Constant "profile">
       8  ?<Constant "resp">
       4  ??DataTable45
       4  ??DataTable46
       4  ??DataTable48
       4  ??DataTable48_1
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable53_10
       4  ??DataTable53_11
       4  ??DataTable53_12
       4  ??DataTable53_2
       4  ??DataTable53_3
       4  ??DataTable53_4
       4  ??DataTable53_5
       4  ??DataTable53_6
       4  ??DataTable53_7
       4  ??DataTable53_8
       4  ??DataTable53_9
      10  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine2
      12  ?Subroutine3
       8  ?Subroutine4
       2  addressTableReferenceCounts
       1  afDeviceEnabled
       1  afNoSecurityForDefaultResponse
     210  dispatchZclMessage
       1  emAfApsSecurityOff
       1  emAfDeviceIsPerformingKeyEstablishment
     104  emberAfAddAddressTableEntry
      20  emberAfAnalogDiscreteThresholds
     154  emberAfCompareValues
      10  emberAfCopyInt16u
      14  emberAfCopyInt24u
      18  emberAfCopyInt32u
      48  emberAfCopyLongString
      42  emberAfCopyString
      12  emberAfDaysInMonth
      60  emberAfDecodeAndPrintCluster
      24  emberAfDetermineIfLinkSecurityIsRequired
      24  emberAfEndpointEventControlGetActive
      26  emberAfEndpointEventControlSetActive
      26  emberAfEndpointEventControlSetDelay
      26  emberAfEndpointEventControlSetDelayMS
      26  emberAfEndpointEventControlSetDelayMinutes
      26  emberAfEndpointEventControlSetDelayQS
      24  emberAfEndpointEventControlSetInactive
     180  emberAfFillTimeStructFromUtc
      38  emberAfFindClusterNameIndex
      24  emberAfGetAttributeAnalogOrDiscreteType
       4  emberAfGetCurrentTime
      48  emberAfGetDifference
      12  emberAfGetLastSequenceNumber
      32  emberAfIncomingZclSequenceNumber
          emberAfApsRetryOverride
          emberAfResponseType
          interpanResponseHeader
          emAfCurrentCommand
      92  emberAfInit
      24  emberAfIsDeviceEnabled
      36  emberAfIsDeviceIdentifying
      14  emberAfIsTypeSigned
      90  emberAfMaximumApsPayloadLength
      16  emberAfNextSequence
      62  emberAfPrintTime
     396  emberAfProcessMessage
      44  emberAfRemoveAddressTableEntry
       4  emberAfSendDefaultResponse
     124  emberAfSendDefaultResponseWithCallback
       4  emberAfSendImmediateDefaultResponse
      12  emberAfSendImmediateDefaultResponseWithCallback
       4  emberAfSendResponse
     240  emberAfSendResponseWithCallback
       1  emberAfSequenceNumber
      56  emberAfSetAddressTableEntry
      22  emberAfSetDeviceEnabled
      22  emberAfSetNoReplyForNextMessage
       4  emberAfSetTime
      30  emberAfStackDown
      34  emberAfTick
      12  internalTickFunctions
       2  lastBlinkTime
      32  platformTick
      94  prepareForResponse
     138  printIncomingZclMessage
      40  zclClusterNames

 
     8 bytes in section .bss
    33 bytes in section .data
    67 bytes in section .rodata
 3 432 bytes in section .text
 
 3 432 bytes of CODE  memory
    67 bytes of CONST memory
    41 bytes of DATA  memory

Errors: none
Warnings: none
