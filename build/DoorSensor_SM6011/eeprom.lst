###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     04/Feb/2015  16:37:29 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ee #
#                    prom\eeprom.c                                            #
#    Command line =  C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ee #
#                    prom\eeprom.c -D "GENERATED_TOKEN_HEADER=\"app/builder/D #
#                    oorSensor_SM6011/DoorSensor_SM6011_tokens.h\"" -D        #
#                    "ZA_GENERATED_HEADER=\"app/builder/DoorSensor_SM6011/Doo #
#                    rSensor_SM6011.h\"" -D LOCAL_STORAGE_BTL -D              #
#                    "BOARD_HEADER=\"app\builder\DoorSensor_SM6011\DoorSensor #
#                    _SM6011_board.h\"" -D "PLATFORM_HEADER=\"hal/micro/corte #
#                    xm3/compiler/iar.h\"" -D CORTEXM3 -D                     #
#                    CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3585 -D PHY_EM3XX -D  #
#                    "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\ #
#                    "" -D "CONFIGURATION_HEADER=\"app/framework/util/config. #
#                    h\"" -D "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/D #
#                    oorSensor_SM6011/DoorSensor_SM6011_endpoint_config.h\""  #
#                    -D "__SOURCEFILE__=\"eeprom.c\"" -lC                     #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \ --diag_suppress Pa050 -o C:\Ember\EmberZNet5.3.0-GA\em #
#                    35x\build\DoorSensor_SM6011\ --debug --endian=little     #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ee #
#                    prom\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\Do #
#                    orSensor_SM6011\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app #
#                    \builder\DoorSensor_SM6011\..\..\..\ -I                  #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\app\framework\include\ -I                #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app #
#                    \builder\DoorSensor_SM6011\..\..\..\stack\ -I            #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\hal\ -I C:\Ember\EmberZNet5.3.0-GA\em35x #
#                    \app\builder\DoorSensor_SM6011\..\..\..\hal\..\ -Ohz     #
#                    --use_c++_inline                                         #
#    List file    =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \eeprom.lst                                              #
#    Object file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \eeprom.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Ember\EmberZNet5.3.0-GA\em35x\app\framework\plugin\eeprom\eeprom.c
      1          // *****************************************************************************
      2          // * eeprom.c
      3          // *
      4          // * Code for manipulating the EEPROM from the Application Framework
      5          // * In particular, sleepies that use the EEPROM will require re-initialization
      6          // * of the driver code after they wake up from sleep.  This code helps
      7          // * manage the state of the driver. 
      8          // *
      9          // * Copyright 2012 Silicon Laboratories, Inc.                              *80*
     10          // *****************************************************************************
     11          
     12          #include PLATFORM_HEADER     // Micro and compiler specific typedefs and macros
     13          
     14          #include "app/framework/include/af.h"
     15          #include "app/framework/plugin/eeprom/eeprom.h"
     16          
     17          //------------------------------------------------------------------------------
     18          // Globals
     19          

   \                                 In section .data, align 4
     20          static boolean eepromInitialized = FALSE;
     21          
     22          // NOTE:
     23          // In EmberZNet 4.3 we required the code required that the 
     24          // underlying EEPROM driver MUST have support for arbitrary page writes
     25          // (i.e. writes that cross page boundaries and or are smaller than the page size)
     26          // Specifically the OTA Storage EEPROM Driver plugin code for storing OTA images
     27          // requires this.
     28          
     29          // This is no longer a requirement due to the fact that we have formal page-erase
     30          // support built into the OTA code.  However for systems using a read-modify-write
     31          // driver we have support here.
     32          
     33          // The App. Bootloader for the 35x SOC prior to 4.3 did NOT have read-modify-write support.
     34          // Therefore the shared app. bootloader EEPROM routines CANNOT be used; a copy
     35          // of the EEPROM driver must be included with the application to support the OTA
     36          // cluster.  
     37          // The 4.3 App. bootloader for the 35x does have arbitrary page-write support
     38          // and thus the shared EEPROM routines may be used on the 35x SOC.
     39          
     40          // The 250 has no shared bootloader EEPROM routines and so the application
     41          // must include a copy of the EEPROM driver.  The Host co-processor based models
     42          // must also include an EEPROM driver in their application that has arbitrary 
     43          // page-write support.
     44          
     45          #if defined(EZSP_HOST) \
     46           || defined(EMBER_AF_PLUGIN_OTA_STORAGE_SIMPLE_EEPROM_ENABLE_SOC_APP_BOOTLOADER_COMPATIBILITY_MODE)
     47            #define eepromInit() halEepromInit()
     48            #define eepromWrite(address, data, len) \
     49              halEepromWrite((address), (data), (len))
     50            #define eepromRead(address, data, len) \
     51              halEepromRead((address), (data), (len))
     52            #define eepromErase(address,len) \
     53              halEepromErase((address), (len))
     54            #define eepromBusy() \
     55              halEepromBusy()
     56            #define eepromInfo() \
     57              halEepromInfo()
     58            #define eepromShutdown() \
     59              halEepromShutdown()
     60          
     61          #else // EM35x SOC with 4.3 bootloader or later
     62            #define eepromInit() halAppBootloaderInit()
     63            #define eepromWrite(address, data, len) \
     64              halAppBootloaderWriteRawStorage((address), (data), (len))
     65            #define eepromRead(address, data, len) \
     66              halAppBootloaderReadRawStorage((address), (data), (len))
     67            #define eepromErase(address, len) \
     68              halAppBootloaderEraseRawStorage((address), (len))
     69            #define eepromBusy()                            \
     70              halAppBootloaderStorageBusy()
     71            #define eepromInfo() \
     72              halAppBootloaderInfo()
     73            #define eepromShutdown() \
     74              halAppBootloaderShutdown() 
     75          #endif
     76          
     77          
     78          EmAfPartialWriteStruct emAfEepromSavedPartialWrites[EMBER_AF_PLUGIN_EEPROM_PARTIAL_WORD_STORAGE_COUNT];
   \                     emAfEepromSavedPartialWrites:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000010   0x00               DC8 0
     79          
     80          // We cache the word size because determining the size requires calling into the
     81          // bootloader and potentially reading it from the part itself.  Several pieces
     82          // of code reference the word size quite often and therefore this will reduce
     83          // the performance hit of the code.
     84          #define UNKNOWN_WORD_SIZE 0
     85          
     86          typedef enum {
     87            PAGE_ERASE_NOT_NEEDED = 0,
     88            PAGE_ERASE_REQUIRED   = 1,
     89            PAGE_ERASE_UNKNOWN    = 0xFF,
     90          } PageEraseStatus;
     91          
     92          PageEraseStatus pageEraseStatus = PAGE_ERASE_UNKNOWN;
   \                     pageEraseStatus:
   \   00000011   0xFF               DC8 255
     93          
     94          #define pageEraseRequired() (pageEraseStatus == PAGE_ERASE_REQUIRED)
     95          
     96          #define INVALID_INDEX 0xFF
     97          #define INVALID_ADDRESS 0xFFFFFFFF
     98          
     99          //#define EEPROM_DEBUG TRUE
    100          #if defined(EEPROM_DEBUG)
    101            #define eepromDebugPrintln(...) emberAfCorePrintln(__VA_ARGS__)
    102          #else
    103            #define eepromDebugPrintln(...)
    104          #endif
    105          
    106          //------------------------------------------------------------------------------
    107          
    108          // Sleepies will need a re-initialization of the driver after sleep,
    109          // so this code helps manage that state and automatically re-init the driver
    110          // if it is needed.
    111          

   \                                 In section .text, align 2, keep-with-next
    112          boolean emAfIsEepromInitialized(void)
    113          {
    114            return eepromInitialized;
   \                     emAfIsEepromInitialized:
   \   00000000   0x....             LDR.N    R0,??DataTable11
   \   00000002   0x7C00             LDRB     R0,[R0, #+16]
   \   00000004   0x4770             BX       LR               ;; return
    115          }
    116          

   \                                 In section .text, align 2, keep-with-next
    117          int8u emberAfPluginEepromGetWordSize(void)
    118          {
   \                     emberAfPluginEepromGetWordSize:
   \   00000000   0xB510             PUSH     {R4,LR}
    119            static int8u wordSize = UNKNOWN_WORD_SIZE;
    120            if (wordSize == UNKNOWN_WORD_SIZE) {
   \   00000002   0x....             LDR.N    R4,??DataTable11_1
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xB960             CBNZ.N   R0,??emberAfPluginEepromGetWordSize_0
    121              const HalEepromInformationType* part = emberAfPluginEepromInfo();  
   \   00000008   0x.... 0x....      BL       emberAfPluginEepromInit
   \   0000000C   0x.... 0x....      BL       halAppBootloaderInfo
    122              wordSize = 1;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7021             STRB     R1,[R4, #+0]
    123           
    124              // The word size in the part was added much later in the driver
    125              // support.  Therefore we assume the word size is 1 for those devices
    126              // that don't support the parameter because in prior releases
    127              // we only released drivers that supported that word size.
    128              if (part != NULL &&
    129                  part->version >= EEPROM_INFO_MIN_VERSION_WITH_WORD_SIZE_SUPPORT) {
   \   00000014   0xB128             CBZ.N    R0,??emberAfPluginEepromGetWordSize_0
   \   00000016   0x8801             LDRH     R1,[R0, #+0]
   \   00000018   0xF5B1 0x7F81      CMP      R1,#+258
   \   0000001C   0xBF24             ITT      CS 
   \   0000001E   0x7D00             LDRBCS   R0,[R0, #+20]
   \   00000020   0x7020             STRBCS   R0,[R4, #+0]
    130                wordSize = part->wordSizeBytes;
    131              }
    132            }
    133            return wordSize;
   \                     ??emberAfPluginEepromGetWordSize_0:
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    134          }

   \                                 In section .bss, align 1
   \                     ??wordSize:
   \   00000000                      DS8 1
    135          

   \                                 In section .text, align 2, keep-with-next
    136          void emberAfPluginEepromNoteInitializedState(boolean state)
    137          {
    138            eepromInitialized = state;
   \                     emberAfPluginEepromNoteInitializedState:
   \   00000000   0x....             B.N      ?Subroutine0
    139          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x....             LDR.N    R1,??DataTable11
   \   00000002   0x7408             STRB     R0,[R1, #+16]
   \   00000004   0x4770             BX       LR               ;; return
    140          
    141          static void eepromFirstTimeInit(void)
    142          {
    143            if (PAGE_ERASE_UNKNOWN == pageEraseStatus) {
    144              const HalEepromInformationType* eepromInfo = eepromInfo();
    145              if(eepromInfo != NULL) {
    146                pageEraseStatus = ((eepromInfo->capabilitiesMask
    147                                    & EEPROM_CAPABILITIES_PAGE_ERASE_REQD)
    148                                    ? PAGE_ERASE_REQUIRED
    149                                    : PAGE_ERASE_NOT_NEEDED);
    150          
    151                MEMSET(emAfEepromSavedPartialWrites, 
    152                       0xFF,
    153                       sizeof(EmAfPartialWriteStruct)
    154                       * EMBER_AF_PLUGIN_EEPROM_PARTIAL_WORD_STORAGE_COUNT);
    155          
    156                // We can't do partial writes with a word size above 2.
    157                if (pageEraseRequired()) {
    158                  assert(emberAfPluginEepromGetWordSize() <= EM_AF_EEPROM_MAX_WORD_SIZE);
    159                }
    160              } else {
    161                // Legacy drivers without EEPROM info structs were all read-modify write,
    162                // so we know definitively that page erase is needed.
    163                pageEraseStatus = PAGE_ERASE_NOT_NEEDED;
    164              }
    165            }
    166          }
    167          

   \                                 In section .text, align 2, keep-with-next
    168          void emberAfPluginEepromInit(void)
    169          {
   \                     emberAfPluginEepromInit:
   \   00000000   0xB510             PUSH     {R4,LR}
    170            if (emAfIsEepromInitialized()) {
   \   00000002   0x....             LDR.N    R4,??DataTable11
   \   00000004   0x7C20             LDRB     R0,[R4, #+16]
   \   00000006   0xBB18             CBNZ.N   R0,??emberAfPluginEepromInit_0
    171              return;
    172            }
    173          
    174            eepromInit();
   \   00000008   0x.... 0x....      BL       halAppBootloaderInit
    175            emberAfPluginEepromNoteInitializedState(TRUE);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x7420             STRB     R0,[R4, #+16]
    176          
    177            eepromFirstTimeInit();
   \   00000010   0x7C60             LDRB     R0,[R4, #+17]
   \   00000012   0x28FF             CMP      R0,#+255
   \   00000014   0xD11C             BNE.N    ??emberAfPluginEepromInit_0
   \   00000016   0x.... 0x....      BL       halAppBootloaderInfo
   \   0000001A   0xB1C0             CBZ.N    R0,??emberAfPluginEepromInit_1
   \   0000001C   0x8840             LDRH     R0,[R0, #+2]
   \   0000001E   0x0600             LSLS     R0,R0,#+24
   \   00000020   0x0E40             LSRS     R0,R0,#+25
   \   00000022   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000026   0x7460             STRB     R0,[R4, #+17]
   \   00000028   0x2210             MOVS     R2,#+16
   \   0000002A   0x21FF             MOVS     R1,#+255
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       halCommonMemSet
   \   00000032   0x7C60             LDRB     R0,[R4, #+17]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD10B             BNE.N    ??emberAfPluginEepromInit_0
   \   00000038   0x.... 0x....      BL       emberAfPluginEepromGetWordSize
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD307             BCC.N    ??emberAfPluginEepromInit_0
   \   00000040   0x219E             MOVS     R1,#+158
   \   00000042   0x.... 0x....      ADR.W    R0,`?<Constant "eeprom.c">`
   \   00000046   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004A   0x.... 0x....      B.W      halInternalAssertFailed
   \                     ??emberAfPluginEepromInit_1:
   \   0000004E   0x7460             STRB     R0,[R4, #+17]
   \                     ??emberAfPluginEepromInit_0:
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    178          }
    179          

   \                                 In section .text, align 2, keep-with-next
    180          const HalEepromInformationType* emberAfPluginEepromInfo(void)
    181          {
   \                     emberAfPluginEepromInfo:
   \   00000000   0xB580             PUSH     {R7,LR}
    182            emberAfPluginEepromInit();
   \   00000002   0x.... 0x....      BL       emberAfPluginEepromInit
    183            return eepromInfo();
   \   00000006   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000A   0x.... 0x....      B.W      halAppBootloaderInfo
    184          }
    185          

   \                                 In section .text, align 2, keep-with-next
    186          static void clearPartialWrite(int8u index)
    187          {
    188            MEMSET(&(emAfEepromSavedPartialWrites[index]), 0xFF, sizeof(EmAfPartialWriteStruct));
   \                     clearPartialWrite:
   \   00000000   0x2208             MOVS     R2,#+8
   \   00000002   0x21FF             MOVS     R1,#+255
   \   00000004   0x....             LDR.N    R3,??DataTable11
   \   00000006   0xEB03 0x00C0      ADD      R0,R3,R0, LSL #+3
   \   0000000A   0x.... 0x....      B.W      halCommonMemSet
    189          }
    190          
    191          static int8u checkForPreceedingPartialWrite(int32u address)
    192          {
    193            int8u i;
    194            eepromDebugPrintln("checkForPreceedingPartialWrite() address: 0x%4X", address);
    195            for (i = 0; i < EMBER_AF_PLUGIN_EEPROM_PARTIAL_WORD_STORAGE_COUNT; i++) {
    196              eepromDebugPrintln("%d, address 0x%4X", i, emAfEepromSavedPartialWrites[i].address);
    197              if (emAfEepromSavedPartialWrites[i].address != INVALID_ADDRESS
    198                  && (emAfEepromSavedPartialWrites[i].address + 1 == address)) {
    199                return i;
    200              }
    201            }
    202            return INVALID_INDEX;
    203          }
    204          
    205          static int8u addPartialWrite(const EmAfPartialWriteStruct* newPartialWrite)
    206          {
    207            int8u i;
    208            for (i = 0; i < EMBER_AF_PLUGIN_EEPROM_PARTIAL_WORD_STORAGE_COUNT; i++) {
    209              if (emAfEepromSavedPartialWrites[i].address == INVALID_ADDRESS) {
    210                MEMCOPY(&(emAfEepromSavedPartialWrites[i]), newPartialWrite, sizeof(EmAfPartialWriteStruct));
    211                eepromDebugPrintln("Stored partial write at index %d", i);
    212                return EEPROM_SUCCESS;
    213              }
    214            }
    215            return EEPROM_ERR;
    216          }
    217          
    218          #if defined(EMBER_TEST)
    219          void emAfPluginEepromFakeEepromCallback(void)
    220          {
    221            // The fake (simulated) EEPROM gets initialized at a funny time,
    222            // after emberAfPluginEepromInit().  We must reinitialize the known
    223            // parameters of the EEPROM by this plugin in case it has chnaged.
    224            emberAfEepromNoteInitializedStateCallback(FALSE);
    225            emberAfPluginEepromInit();
    226          }
    227          #endif
    228          

   \                                 In section .text, align 2, keep-with-next
    229          int8u emberAfPluginEepromWrite(int32u address, const int8u *data, int16u totalLength)
    230          {
   \                     emberAfPluginEepromWrite:
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4616             MOV      R6,R2
    231            int8u status;
    232            EmAfPartialWriteStruct tempPartialWrite = { INVALID_ADDRESS, 0xFF };
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant {4294967295, 255}>`
   \   0000000E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000012   0xE9CD 0x2301      STRD     R2,R3,[SP, #+4]
    233            emberAfPluginEepromInit();
   \   00000016   0x.... 0x....      BL       emberAfPluginEepromInit
    234          
    235            if (pageEraseRequired() && emberAfPluginEepromGetWordSize() > 1) {
   \   0000001A   0x....             LDR.N    R7,??DataTable11
   \   0000001C   0x7C78             LDRB     R0,[R7, #+17]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD122             BNE.N    ??emberAfPluginEepromWrite_0
   \   00000022   0x.... 0x....      BL       emberAfPluginEepromGetWordSize
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD31E             BCC.N    ??emberAfPluginEepromWrite_0
    236              int8u partialWriteData[EM_AF_EEPROM_MAX_WORD_SIZE];
    237              int8u index = checkForPreceedingPartialWrite(address);
   \   0000002A   0x2500             MOVS     R5,#+0
   \                     ??emberAfPluginEepromWrite_1:
   \   0000002C   0xF857 0x0035      LDR      R0,[R7, R5, LSL #+3]
   \   00000030   0xF110 0x0F01      CMN      R0,#+1
   \   00000034   0xD043             BEQ.N    ??emberAfPluginEepromWrite_2
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0x42A0             CMP      R0,R4
   \   0000003A   0xD140             BNE.N    ??emberAfPluginEepromWrite_2
    238              if (index != INVALID_INDEX) {
   \   0000003C   0xB2ED             UXTB     R5,R5
   \   0000003E   0x2DFF             CMP      R5,#+255
   \   00000040   0xD012             BEQ.N    ??emberAfPluginEepromWrite_0
    239                eepromDebugPrintln("Previous partial word detected at 0x%4X", address);
    240                partialWriteData[1] = data[0];
   \   00000042   0xF818 0x0B01      LDRB     R0,[R8], #+1
   \   00000046   0xF88D 0x0001      STRB     R0,[SP, #+1]
    241                totalLength--;
   \   0000004A   0x1E76             SUBS     R6,R6,#+1
    242                partialWriteData[0] = emAfEepromSavedPartialWrites[index].data;
   \   0000004C   0xEB07 0x00C5      ADD      R0,R7,R5, LSL #+3
   \   00000050   0x.... 0x....      BL       ?Subroutine1
    243                eepromDebugPrintln("eepromWrite() Address: 0x%4X, len: 2",
    244                                   address - 1);
    245                status = eepromWrite(address - 1,
    246                                     partialWriteData, 
    247                                     2);  // assume max of 2 byte word size 
   \                     ??CrossCallReturnLabel_0:
   \   00000054   0x1E60             SUBS     R0,R4,#+1
   \   00000056   0x.... 0x....      BL       halAppBootloaderWriteRawStorage
   \   0000005A   0xEA5F 0x0900      MOVS     R9,R0
    248                EMBER_TEST_ASSERT(status == EEPROM_SUCCESS);
    249                if (status != 0) {
   \   0000005E   0xD138             BNE.N    ??emberAfPluginEepromWrite_3
    250                  return status;
    251                }
    252                data++;
    253                clearPartialWrite(index);
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       clearPartialWrite
    254                address++;
   \   00000066   0x1C64             ADDS     R4,R4,#+1
    255              }
    256            }
    257          
    258            if (pageEraseRequired() 
    259                && ((totalLength % emberAfPluginEepromGetWordSize()) != 0)) {
   \                     ??emberAfPluginEepromWrite_0:
   \   00000068   0x7C78             LDRB     R0,[R7, #+17]
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xD10F             BNE.N    ??emberAfPluginEepromWrite_4
   \   0000006E   0x.... 0x....      BL       emberAfPluginEepromGetWordSize
   \   00000072   0xB2B6             UXTH     R6,R6
   \   00000074   0xFB96 0xF1F0      SDIV     R1,R6,R0
   \   00000078   0xFB00 0x6011      MLS      R0,R0,R1,R6
   \   0000007C   0xB138             CBZ.N    R0,??emberAfPluginEepromWrite_4
    260              // Assume 2 byte word size
    261              totalLength--;
   \   0000007E   0x1E76             SUBS     R6,R6,#+1
    262              tempPartialWrite.address = address + totalLength;
   \   00000080   0xB2B6             UXTH     R6,R6
   \   00000082   0x1930             ADDS     R0,R6,R4
   \   00000084   0x9001             STR      R0,[SP, #+4]
    263              tempPartialWrite.data = data[totalLength];
   \   00000086   0xF816 0x0008      LDRB     R0,[R6, R8]
   \   0000008A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    264            }
    265          
    266            eepromDebugPrintln("eepromWrite() Address: 0x%4X, len: %l", address, totalLength);
    267            status = eepromWrite(address, data, totalLength);
   \                     ??emberAfPluginEepromWrite_4:
   \   0000008E   0xB2B2             UXTH     R2,R6
   \   00000090   0x4641             MOV      R1,R8
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       halAppBootloaderWriteRawStorage
   \   00000098   0xEA5F 0x0900      MOVS     R9,R0
    268          
    269            EMBER_TEST_ASSERT(status == EEPROM_SUCCESS);
    270          
    271            if (status == 0
    272                && tempPartialWrite.address != INVALID_ADDRESS) {
   \   0000009C   0xD119             BNE.N    ??emberAfPluginEepromWrite_3
   \   0000009E   0x9801             LDR      R0,[SP, #+4]
   \   000000A0   0xF110 0x0F01      CMN      R0,#+1
   \   000000A4   0xD015             BEQ.N    ??emberAfPluginEepromWrite_3
    273              eepromDebugPrintln("Caching partial word write at address 0x%4X",
    274                                 tempPartialWrite.address);
    275              status = addPartialWrite(&tempPartialWrite);
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x6839             LDR      R1,[R7, #+0]
   \   000000AA   0xF111 0x0F01      CMN      R1,#+1
   \   000000AE   0xD10A             BNE.N    ??emberAfPluginEepromWrite_5
   \                     ??emberAfPluginEepromWrite_6:
   \   000000B0   0x2208             MOVS     R2,#+8
   \   000000B2   0xA901             ADD      R1,SP,#+4
   \   000000B4   0xEB07 0x00C0      ADD      R0,R7,R0, LSL #+3
   \   000000B8   0x.... 0x....      BL       halCommonMemCopy
   \   000000BC   0xE009             B.N      ??emberAfPluginEepromWrite_3
   \                     ??emberAfPluginEepromWrite_2:
   \   000000BE   0x1C6D             ADDS     R5,R5,#+1
   \   000000C0   0x2D02             CMP      R5,#+2
   \   000000C2   0xDBB3             BLT.N    ??emberAfPluginEepromWrite_1
   \   000000C4   0xE7D0             B.N      ??emberAfPluginEepromWrite_0
    276              EMBER_TEST_ASSERT(status == EEPROM_SUCCESS);
    277            }
   \                     ??emberAfPluginEepromWrite_5:
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x68B9             LDR      R1,[R7, #+8]
   \   000000CA   0xF111 0x0F01      CMN      R1,#+1
   \   000000CE   0xD0EF             BEQ.N    ??emberAfPluginEepromWrite_6
   \   000000D0   0x4681             MOV      R9,R0
    278          
    279            return status;
   \                     ??emberAfPluginEepromWrite_3:
   \   000000D2   0x4648             MOV      R0,R9
   \   000000D4   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    280          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x7900             LDRB     R0,[R0, #+4]
   \   00000002   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000006   0x2202             MOVS     R2,#+2
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x4770             BX       LR
    281          

   \                                 In section .text, align 2, keep-with-next
    282          int8u emberAfPluginEepromFlushSavedPartialWrites(void)
    283          {
   \                     emberAfPluginEepromFlushSavedPartialWrites:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    284            int8u i;
    285            if (!pageEraseRequired()) {
   \   00000004   0x....             LDR.N    R4,??DataTable11
   \   00000006   0x7C60             LDRB     R0,[R4, #+17]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD118             BNE.N    ??emberAfPluginEepromFlushSavedPartialWrites_0
    286              return EEPROM_SUCCESS;
    287            }
    288            emberAfPluginEepromInit();
   \   0000000C   0x.... 0x....      BL       emberAfPluginEepromInit
    289            for (i = 0; i < EMBER_AF_PLUGIN_EEPROM_PARTIAL_WORD_STORAGE_COUNT; i++) {
   \   00000010   0x2500             MOVS     R5,#+0
   \   00000012   0x.... 0x....      ADR.W    R6,`?<Constant {255, 255}>`
    290              int8u partialWrite[] = { 0xFF, 0xFF };
   \                     ??emberAfPluginEepromFlushSavedPartialWrites_1:
   \   00000016   0x8830             LDRH     R0,[R6, #+0]
   \   00000018   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    291              if (emAfEepromSavedPartialWrites[i].address != INVALID_ADDRESS) {
   \   0000001C   0xF854 0x0035      LDR      R0,[R4, R5, LSL #+3]
   \   00000020   0xF110 0x0F01      CMN      R0,#+1
   \   00000024   0xD008             BEQ.N    ??emberAfPluginEepromFlushSavedPartialWrites_2
    292                int8u status;
    293                partialWrite[0] = emAfEepromSavedPartialWrites[i].data;
   \   00000026   0xEB04 0x00C5      ADD      R0,R4,R5, LSL #+3
   \   0000002A   0x.... 0x....      BL       ?Subroutine1
    294                status = eepromWrite(emAfEepromSavedPartialWrites[i].address,
    295                                     partialWrite,
    296                                     2);
   \                     ??CrossCallReturnLabel_1:
   \   0000002E   0xF854 0x0035      LDR      R0,[R4, R5, LSL #+3]
   \   00000032   0x.... 0x....      BL       halAppBootloaderWriteRawStorage
    297                EMBER_TEST_ASSERT(status == EEPROM_SUCCESS);
    298                if (status != EEPROM_SUCCESS) {
   \   00000036   0xB918             CBNZ.N   R0,??emberAfPluginEepromFlushSavedPartialWrites_3
    299                  return status;
    300                }
    301              }
    302            }
   \                     ??emberAfPluginEepromFlushSavedPartialWrites_2:
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \   0000003A   0x2D02             CMP      R5,#+2
   \   0000003C   0xDBEB             BLT.N    ??emberAfPluginEepromFlushSavedPartialWrites_1
    303            return EEPROM_SUCCESS;
   \                     ??emberAfPluginEepromFlushSavedPartialWrites_0:
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??emberAfPluginEepromFlushSavedPartialWrites_3:
   \   00000040   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    304          }
    305          

   \                                 In section .text, align 2, keep-with-next
    306          int8u emberAfPluginEepromRead(int32u address, int8u *data, int16u totalLength)
    307          {
   \                     emberAfPluginEepromRead:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    308            int8u status;
    309            emberAfPluginEepromInit();
   \   00000008   0x.... 0x....      BL       emberAfPluginEepromInit
    310            status = eepromRead(address, data, totalLength);
    311          
    312            EMBER_TEST_ASSERT(status == EEPROM_SUCCESS);
    313          
    314            return status;
   \   0000000C   0x4632             MOV      R2,R6
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000016   0x.... 0x....      B.W      halAppBootloaderReadRawStorage
    315          }
    316          

   \                                 In section .text, align 2, keep-with-next
    317          int8u emberAfPluginEepromErase(int32u address, int32u totalLength)
    318          {
   \                     emberAfPluginEepromErase:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    319            int8u i;
    320            int8u status;
    321            emberAfPluginEepromInit();
   \   00000008   0x.... 0x....      BL       emberAfPluginEepromInit
    322            status = eepromErase(address, totalLength);
   \   0000000C   0x4629             MOV      R1,R5
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       halAppBootloaderEraseRawStorage
   \   00000014   0x4606             MOV      R6,R0
    323          
    324            EMBER_TEST_ASSERT(status == EEPROM_SUCCESS);
    325          
    326            for (i = 0; i < EMBER_AF_PLUGIN_EEPROM_PARTIAL_WORD_STORAGE_COUNT; i++) {
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0x.... 0x....      LDR.W    R8,??DataTable11
    327              if (emAfEepromSavedPartialWrites[i].address != INVALID_ADDRESS
    328                  && (emAfEepromSavedPartialWrites[i].address >= address
    329                  &&  emAfEepromSavedPartialWrites[i].address < (address + totalLength))) {
   \                     ??emberAfPluginEepromErase_0:
   \   0000001C   0xF858 0x0037      LDR      R0,[R8, R7, LSL #+3]
   \   00000020   0xF110 0x0F01      CMN      R0,#+1
   \   00000024   0xD007             BEQ.N    ??emberAfPluginEepromErase_1
   \   00000026   0x42A0             CMP      R0,R4
   \   00000028   0xD305             BCC.N    ??emberAfPluginEepromErase_1
   \   0000002A   0x1929             ADDS     R1,R5,R4
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xBF3C             ITT      CC 
   \   00000030   0xB2F8             UXTBCC   R0,R7
   \   00000032   0x.... 0x....      BLCC     clearPartialWrite
    330                clearPartialWrite(i);
    331              }
    332            }
   \                     ??emberAfPluginEepromErase_1:
   \   00000036   0x1C7F             ADDS     R7,R7,#+1
   \   00000038   0x2F02             CMP      R7,#+2
   \   0000003A   0xDBEF             BLT.N    ??emberAfPluginEepromErase_0
    333          
    334            return status;
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    335          }
    336          

   \                                 In section .text, align 2, keep-with-next
    337          boolean emberAfPluginEepromBusy(void)
    338          {
   \                     emberAfPluginEepromBusy:
   \   00000000   0xB580             PUSH     {R7,LR}
    339            emberAfPluginEepromInit();
   \   00000002   0x.... 0x....      BL       emberAfPluginEepromInit
    340            return eepromBusy();
   \   00000006   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000A   0x.... 0x....      B.W      halAppBootloaderStorageBusy
    341          }
    342          
    343          // Returns TRUE if shutdown was done, returns FALSE if shutdown was not
    344          // necessary.

   \                                 In section .text, align 2, keep-with-next
    345          boolean emberAfPluginEepromShutdown(void)
    346          {
   \                     emberAfPluginEepromShutdown:
   \   00000000   0xB510             PUSH     {R4,LR}
    347            if (!emAfIsEepromInitialized()) {
   \   00000002   0x....             LDR.N    R4,??DataTable11
   \   00000004   0x7C20             LDRB     R0,[R4, #+16]
   \   00000006   0xB120             CBZ.N    R0,??emberAfPluginEepromShutdown_0
    348              return FALSE;
    349            }
    350          
    351            eepromShutdown();
   \   00000008   0x.... 0x....      BL       halAppBootloaderShutdown
    352            emberAfPluginEepromNoteInitializedState(FALSE);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x7420             STRB     R0,[R4, #+16]
    353            return TRUE;
   \   00000010   0x2001             MOVS     R0,#+1
   \                     ??emberAfPluginEepromShutdown_0:
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    354          }
    355          
    356          //------------------------------------------------------------------------------
    357          // These callbacks are defined so that other parts of the system can make
    358          // these calls regardless of whether the EEPROM is actually used.  A
    359          // user generated callback will be created if they don't use
    360          // the plugin.

   \                                 In section .text, align 2, keep-with-next
    361          void emberAfEepromInitCallback(void)
    362          {
    363            emberAfPluginEepromInit();
   \                     emberAfEepromInitCallback:
   \   00000000   0x....             B.N      emberAfPluginEepromInit
    364          }
    365          

   \                                 In section .text, align 2, keep-with-next
    366          void emberAfEepromNoteInitializedStateCallback(boolean state)
   \                     emberAfEepromNoteInitializedStateCallback:
   \   00000000   0xBF00             Nop      
    367          {
    368            emberAfPluginEepromNoteInitializedState(state);
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    369          }
    370          

   \                                 In section .text, align 2, keep-with-next
    371          void emberAfEepromShutdownCallback(void)
    372          {
    373            emberAfPluginEepromShutdown();
   \                     emberAfEepromShutdownCallback:
   \   00000000   0x....             B.N      emberAfPluginEepromShutdown
    374          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     emAfEepromSavedPartialWrites

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     ??wordSize

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "eeprom.c">`:
   \   00000000   0x65 0x65          DC8 "eeprom.c"
   \              0x70 0x72    
   \              0x6F 0x6D    
   \              0x2E 0x63    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {4294967295, 255}>`:
   \   00000000   0xFFFFFFFF         DC32 4294967295
   \   00000004   0xFF 0x00          DC8 255, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {255, 255}>`:
   \   00000000   0xFF 0xFF          DC8 255, 255

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  clearPartialWrite
              0 -> halCommonMemSet
        0  emAfIsEepromInitialized
        0  emberAfEepromInitCallback
              0 -> emberAfPluginEepromInit
        0  emberAfEepromNoteInitializedStateCallback
        0  emberAfEepromShutdownCallback
              0 -> emberAfPluginEepromShutdown
        8  emberAfPluginEepromBusy
              8 -> emberAfPluginEepromInit
              0 -> halAppBootloaderStorageBusy
       24  emberAfPluginEepromErase
             24 -> clearPartialWrite
             24 -> emberAfPluginEepromInit
             24 -> halAppBootloaderEraseRawStorage
       24  emberAfPluginEepromFlushSavedPartialWrites
             24 -> emberAfPluginEepromInit
             24 -> halAppBootloaderWriteRawStorage
        8  emberAfPluginEepromGetWordSize
              8 -> emberAfPluginEepromInit
              8 -> halAppBootloaderInfo
        8  emberAfPluginEepromInfo
              8 -> emberAfPluginEepromInit
              0 -> halAppBootloaderInfo
        8  emberAfPluginEepromInit
              8 -> emberAfPluginEepromGetWordSize
              8 -> halAppBootloaderInfo
              8 -> halAppBootloaderInit
              8 -> halCommonMemSet
              0 -> halInternalAssertFailed
        0  emberAfPluginEepromNoteInitializedState
       16  emberAfPluginEepromRead
             16 -> emberAfPluginEepromInit
              0 -> halAppBootloaderReadRawStorage
        8  emberAfPluginEepromShutdown
              8 -> halAppBootloaderShutdown
       40  emberAfPluginEepromWrite
             40 -> clearPartialWrite
             40 -> emberAfPluginEepromGetWordSize
             40 -> emberAfPluginEepromInit
             40 -> halAppBootloaderWriteRawStorage
             40 -> halCommonMemCopy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "eeprom.c">
       2  ?<Constant {255, 255}>
       8  ?<Constant {4294967295, 255}>
       4  ??DataTable11
       4  ??DataTable11_1
       6  ?Subroutine0
      12  ?Subroutine1
      14  clearPartialWrite
      18  emAfEepromSavedPartialWrites
          eepromInitialized
          pageEraseStatus
       6  emAfIsEepromInitialized
       2  emberAfEepromInitCallback
       2  emberAfEepromNoteInitializedStateCallback
       2  emberAfEepromShutdownCallback
      14  emberAfPluginEepromBusy
      66  emberAfPluginEepromErase
      66  emberAfPluginEepromFlushSavedPartialWrites
      38  emberAfPluginEepromGetWordSize
      14  emberAfPluginEepromInfo
      82  emberAfPluginEepromInit
       2  emberAfPluginEepromNoteInitializedState
      26  emberAfPluginEepromRead
      20  emberAfPluginEepromShutdown
     216  emberAfPluginEepromWrite
       1  wordSize

 
   1 byte  in section .bss
  18 bytes in section .data
 618 bytes in section .text
 
 618 bytes of CODE memory
  19 bytes of DATA memory

Errors: none
Warnings: none
