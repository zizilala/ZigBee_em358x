###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     06/Feb/2015  13:53:59 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\hal\micro\cortexm3\uart #
#                    .c                                                       #
#    Command line =  C:\Ember\EmberZNet5.3.0-GA\em35x\hal\micro\cortexm3\uart #
#                    .c -D "GENERATED_TOKEN_HEADER=\"app/builder/DoorSensor_S #
#                    M6011/DoorSensor_SM6011_tokens.h\"" -D                   #
#                    "ZA_GENERATED_HEADER=\"app/builder/DoorSensor_SM6011/Doo #
#                    rSensor_SM6011.h\"" -D LOCAL_STORAGE_BTL -D              #
#                    "BOARD_HEADER=\"app\builder\DoorSensor_SM6011\DoorSensor #
#                    _SM6011_board.h\"" -D "PLATFORM_HEADER=\"hal/micro/corte #
#                    xm3/compiler/iar.h\"" -D CORTEXM3 -D                     #
#                    CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3585 -D PHY_EM3XX -D  #
#                    "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\ #
#                    "" -D "CONFIGURATION_HEADER=\"app/framework/util/config. #
#                    h\"" -D "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/D #
#                    oorSensor_SM6011/DoorSensor_SM6011_endpoint_config.h\""  #
#                    -D "__SOURCEFILE__=\"uart.c\"" -lC                       #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \ --diag_suppress Pa050 -o C:\Ember\EmberZNet5.3.0-GA\em #
#                    35x\build\DoorSensor_SM6011\ --debug --endian=little     #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\hal\micro\cortexm3\ -I  #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\ #
#                    DoorSensor_SM6011\..\..\..\ -I                           #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\app\framework\include\ -I                #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\ -I C:\Ember\EmberZNet5.3.0-GA\em35x\app #
#                    \builder\DoorSensor_SM6011\..\..\..\stack\ -I            #
#                    C:\Ember\EmberZNet5.3.0-GA\em35x\app\builder\DoorSensor_ #
#                    SM6011\..\..\..\hal\ -I C:\Ember\EmberZNet5.3.0-GA\em35x #
#                    \app\builder\DoorSensor_SM6011\..\..\..\hal\..\ -Ohz     #
#                    --use_c++_inline                                         #
#    List file    =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \uart.lst                                                #
#    Object file  =  C:\Ember\EmberZNet5.3.0-GA\em35x\build\DoorSensor_SM6011 #
#                    \uart.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Ember\EmberZNet5.3.0-GA\em35x\hal\micro\cortexm3\uart.c
      1          /** @file hal/micro/cortexm3/uart.c
      2           *  @brief EM3XX UART Library.
      3           *
      4           * <!-- Copyright 2014 Silicon Laboratories, Inc.                        *80*-->
      5           */
      6          
      7          #include PLATFORM_HEADER
      8          #include "stack/include/ember.h"
      9          #include "stack/include/error.h"
     10          #include "hal/hal.h"
     11          #include "hal/micro/micro-types.h"
     12          
     13          #if (! defined(EMBER_STACK_IP))
     14          #include "stack/include/packet-buffer.h"
     15          #endif
     16          
     17          #include "app/util/serial/serial.h"
     18          
     19          // Allow some code to be disabled (and flash saved) if
     20          //  a port is unused or in low-level driver mode
     21          // port 0 is VUART
     22          #if (EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED)
     23            #define EM_SERIAL0_ENABLED 0
     24            #define EM_SER0_PORT_EN(port) (FALSE)
     25          #else
     26            #define EM_SERIAL0_ENABLED 1
     27            #define EM_SER0_PORT_EN(port) ((port) == 0)
     28          #endif
     29          #if (EMBER_SERIAL0_MODE == EMBER_SERIAL_LOWLEVEL)
     30            #error Serial 0 (Virtual Uart) does not support LOWLEVEL mode
     31          #endif
     32          
     33          // port 1 is SC1
     34          #if !defined(EMBER_MICRO_HAS_SC1) \
     35              || (EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED) \
     36              || (EMBER_SERIAL1_MODE == EMBER_SERIAL_LOWLEVEL)
     37            #define EM_SERIAL1_ENABLED 0
     38            #define EM_SER1_PORT_EN(port)     (FALSE)
     39            #define EM_SER1_PORT_FIFO(port)   (FALSE)
     40            #define EM_SER1_PORT_BUFFER(port) (FALSE)
     41          #else
     42            #define EM_SERIAL1_ENABLED 1
     43            #define EM_SER1_PORT_EN(port) ((port) == 1)
     44            #if     (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
     45              #define EM_SER1_PORT_FIFO(port)   EM_SER1_PORT_EN(port)
     46              #define EM_SER1_PORT_BUFFER(port) (FALSE)
     47            #else//Must be EMBER_SERIAL_BUFFER
     48              #define EM_SER1_PORT_FIFO(port)   (FALSE)
     49              #define EM_SER1_PORT_BUFFER(port) EM_SER1_PORT_EN(port)
     50            #endif
     51            #ifndef SOFTUART
     52              #define EM_PHYSICAL_UART
     53            #endif
     54          #endif
     55          
     56          // port 2 is SC3
     57          #if !defined(EMBER_MICRO_HAS_SC3) \
     58              || (EMBER_SERIAL2_MODE == EMBER_SERIAL_UNUSED) \
     59              || (EMBER_SERIAL2_MODE == EMBER_SERIAL_LOWLEVEL)
     60            #define EM_SERIAL2_ENABLED 0
     61            #define EM_SER2_PORT_EN(port)     (FALSE)
     62            #define EM_SER2_PORT_FIFO(port)   (FALSE)
     63            #define EM_SER2_PORT_BUFFER(port) (FALSE)
     64          #else
     65            #define EM_SERIAL2_ENABLED 1
     66            #define EM_SER2_PORT_EN(port) ((port) == 2)
     67            #if     (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
     68              #define EM_SER2_PORT_FIFO(port)   EM_SER2_PORT_EN(port)
     69              #define EM_SER2_PORT_BUFFER(port) (FALSE)
     70            #else//Must be EMBER_SERIAL_BUFFER
     71              #define EM_SER2_PORT_FIFO(port)   (FALSE)
     72              #define EM_SER2_PORT_BUFFER(port) EM_SER2_PORT_EN(port)
     73            #endif
     74            #define EM_PHYSICAL_UART
     75          #endif
     76          
     77          // port 3 is USB
     78          #if !defined(CORTEXM3_EM35X_USB) \
     79              || (EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED)
     80            #define EM_SERIAL3_ENABLED 0
     81            #define EM_SER3_PORT_EN(port) (FALSE)
     82          #else
     83            #define EM_SERIAL3_ENABLED 1
     84            #define EM_SER3_PORT_EN(port) ((port) == 3)
     85          
     86            #include "hal/micro/cortexm3/usb/em_usb.h"
     87            #include "hal/micro/cortexm3/usb/cdc/usbconfig.h"
     88            #include "hal/micro/cortexm3/usb/cdc/descriptors.h"
     89            sernum iSerialNumber =
     90            {
     91              .len  = 32,
     92              .type = USB_STRING_DESCRIPTOR,
     93              .name = {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
     94              .name[ 16 ] = '\0'
     95            };
     96          #endif
     97          
     98          
     99          
    100          
    101          #if defined(EM_ENABLE_SERIAL_FIFO) && defined(EM_ENABLE_SERIAL_BUFFER)
    102            #define EM_SER_MULTI(expr) (expr)
    103          #else // None/Single/Same UARTs -- no need to runtime check their mode at all
    104            #define EM_SER_MULTI(expr) (TRUE)
    105          #endif
    106          
    107          // TODO
    108          #if EM_SERIAL1_ENABLED && (defined(EMBER_SERIAL1_RTSCTS) || defined(EMBER_SERIAL1_XONXOFF)) && EM_SERIAL2_ENABLED
    109            #error Flow control is not currently supported when using both physical UARTs
    110          #endif
    111          
    112          //State information for RX DMA Buffer operation
    113          typedef struct EmSerialBufferState {
    114            const int16u fifoSize;
    115            const int16u rxStartIndexB;
    116            int16u prevCountA;
    117            int16u prevCountB;
    118            boolean waitingForTailA;
    119            boolean waitingForTailB;
    120            boolean waitingForInputToB;
    121            EmberMessageBuffer holdBuf[2];
    122          } EmSerialBufferState;
    123          
    124          // to save flash and speed, if there is only one UART in use, make SCx_REG
    125          // and friends decay into a simple register access
    126          #if !EM_SERIAL1_ENABLED || !EM_SERIAL2_ENABLED
    127            #if EM_SERIAL1_ENABLED
    128              #define SCx_REG(port, reg) SC1_##reg
    129              #define INT_SCxCFG(port) INT_SC1CFG
    130              #define INT_SCxFLAG(port) INT_SC1FLAG
    131              #define INT_SCx(port) INT_SC1
    132            #else
    133              #define SCx_REG(port, reg) SC3_##reg
    134              #define INT_SCxCFG(port) INT_SC3CFG
    135              #define INT_SCxFLAG(port) INT_SC3FLAG
    136              #define INT_SCx(port) INT_SC3
    137            #endif
    138          #else
    139            const int32u serialControllerBlockAddresses[] = { SC1_RXBEGA_ADDR, SC3_RXBEGA_ADDR };
    140            // index into the above array.
    141            // keep in mind port 1 is SC1 and port 2 is SC3 (this is the tricky one)
    142            #define SCx_REG(port, reg) (*((volatile int32u *)(                          \
    143                                        (SC1_##reg##_ADDR - SC1_RXBEGA_ADDR)            \
    144                                        + serialControllerBlockAddresses[(port) - 1])))
    145          
    146            const int32u serialControllerIntCfgAddresses[] = { INT_SC1CFG_ADDR, INT_SC3CFG_ADDR };
    147            #define INT_SCxCFG(port) (*((volatile int32u *)serialControllerIntCfgAddresses[(port) - 1]))
    148          
    149            const int32u serialControllerIntFlagAddresses[]  = { INT_SC1FLAG_ADDR, INT_SC3FLAG_ADDR };
    150            #define INT_SCxFLAG(port) (*((volatile int32u *)serialControllerIntFlagAddresses[(port) - 1]))
    151          
    152            const int32u serialControllerNvecIntValues[] = { INT_SC1, INT_SC3 };
    153            #define INT_SCx(port) serialControllerNvecIntValues[(port) - 1]
    154          #endif
    155          
    156          #if defined(EZSP_UART) && \
    157              !defined(EMBER_SERIAL1_RTSCTS) && \
    158              !defined(EMBER_SERIAL1_XONXOFF)
    159            #error EZSP-UART requires either RTS/CTS or XON/XOFF flow control!
    160          #endif
    161          
    162          #ifdef EMBER_SERIAL1_RTSCTS
    163            #if EMBER_SERIAL1_MODE != EMBER_SERIAL_BUFFER
    164            #error "Illegal serial port 1 configuration"
    165            #endif
    166          #endif
    167          
    168          #ifdef EMBER_SERIAL2_RTSCTS
    169            #if EMBER_SERIAL2_MODE != EMBER_SERIAL_BUFFER
    170            #error "Illegal serial port 2 configuration"
    171            #endif
    172          #endif
    173          
    174          #ifdef EMBER_SERIAL1_XONXOFF
    175            #if EMBER_SERIAL1_MODE != EMBER_SERIAL_FIFO
    176            #error "Illegal serial port 1 configuration"
    177            #endif
    178          
    179            static void halInternalUart1ForceXon(void); // forward declaration
    180          
    181            static int8s xcmdCount;     // num XONs sent to host, written only by tx isr
    182                                        //-1 means an XOFF was sent last
    183                                        // 0 means ready to rx, but no XON has been sent
    184                                        // n>0 means ready to rx, and n XONs have been sent
    185            static int8u xonXoffTxByte; // if non-zero, an XON or XOFF byte to send ahead
    186                                        // of tx queue - cleared when byte is sent
    187            static int8u xonTimer;      // time when last data rx'ed from host, or when
    188                                        // an XON was sent (in 1/4 ticks)
    189          
    190            #define ASCII_XON         0x11  // requests host to pause sending
    191            #define ASCII_XOFF        0x13  // requests host to resume sending
    192            #define XON_REFRESH_TIME  8     // delay between repeat XONs (1/4 sec units)
    193            #define XON_REFRESH_COUNT 3     // max number of repeat XONs to send after 1st
    194          
    195            // Define thresholds for XON/XOFF flow control in terms of queue used values
    196            // Take into account the 4 byte transmit FIFO
    197            #if (EMBER_SERIAL1_RX_QUEUE_SIZE == 128)
    198              #define XON_LIMIT       16    // send an XON
    199              #define XOFF_LIMIT      96    // send an XOFF
    200            #elif (EMBER_SERIAL1_RX_QUEUE_SIZE == 64)
    201              #define XON_LIMIT       8
    202              #define XOFF_LIMIT      36
    203            #elif (EMBER_SERIAL1_RX_QUEUE_SIZE == 32)
    204              #define XON_LIMIT       2
    205              #define XOFF_LIMIT      8
    206            #elif (EMBER_SERIAL1_RX_QUEUE_SIZE > 32)
    207              #define XON_LIMIT       (EMBER_SERIAL1_RX_QUEUE_SIZE/8)
    208              #define XOFF_LIMIT      (EMBER_SERIAL1_RX_QUEUE_SIZE*3/4)
    209            #else
    210              #error "Serial port 1 receive buffer too small!"
    211            #endif
    212          #endif  // EMBER_SERIAL1_XONXOFF
    213          
    214          #ifdef EMBER_SERIAL2_XONXOFF
    215            #error "XON/XOFF is not supported on port 2"
    216          #endif
    217          
    218          #ifdef EMBER_SERIAL3_XONXOFF
    219            #error "XON/XOFF is not supported on port 3"
    220          #endif
    221          
    222          ////////////////////// SOFTUART Pin and Speed definitions //////////////////////
    223          //use a logic analyzer and trial and error to determine these values if
    224          //the SysTick time changes or you want to try a different baud
    225          //These were found using EMU 0x50
    226          #define FULL_BIT_TIME_SCLK  0x9C0UL  //9600 baud with FLKC @ SCLK(24MHz)
    227          #define START_BIT_TIME_SCLK 0x138UL  //9600 baud with FLKC @ SCLK(24MHz)
    228          //USE PB6 (GPIO22) for TXD
    229          #define CONFIG_SOFT_UART_TX_BIT() \
    230            GPIO_PCCFGH = (GPIO_PCCFGH&(~PC6_CFG_MASK)) | (1 << PC6_CFG_BIT)
    231          #define SOFT_UART_TX_BIT(bit)  GPIO_PCOUT = (GPIO_PCOUT&(~PC6_MASK))|((bit)<<PC6_BIT)
    232          //USE PB7 (GPIO23) for RXD
    233          #define CONFIG_SOFT_UART_RX_BIT() \
    234            GPIO_PCCFGH = (GPIO_PCCFGH&(~PC7_CFG_MASK)) | (4 << PC7_CFG_BIT)
    235          #define SOFT_UART_RX_BIT  ((GPIO_PCIN&PC7)>>PC7_BIT)
    236          ////////////////////// SOFTUART Pin and Speed definitions //////////////////////
    237          
    238          #if defined(EMBER_SERIAL1_RTSCTS) || defined(EMBER_SERIAL2_RTSCTS)
    239            void halInternalUartRxCheckRts(int8u port);
    240          #else
    241            #define halInternalUartRxCheckRts(x) do {} while(0)
    242          #endif
    243          
    244          #if defined(EMBER_SERIAL1_RTSCTS)
    245            // define this for backwards compatibility
    246            void halInternalUart1RxCheckRts( void )
    247            {
    248              halInternalUartRxCheckRts(1);
    249            }
    250          #endif
    251          
    252          // Save flash if ports are undefined
    253          #if defined(EM_PHYSICAL_UART)
    254          

   \                                 In section .text, align 4, keep-with-next
    255            const int8u baudSettings[] = {
   \                     baudSettings:
   \   00000000   0x30 0x60          DC8 48, 96, 144, 192, 193, 194, 195, 148, 196, 149, 197, 92, 150, 198
   \              0x90 0xC0    
   \              0xC1 0xC2    
   \              0xC3 0x94    
   \              0xC4 0x95    
   \              0xC5 0x5C    
   \              0x96 0xC6    
   \   0000000E   0xAC 0x97          DC8 172, 151, 152, 153, 13, 0
   \              0x98 0x99    
   \              0x0D 0x00    
    256              // This table is indexed by the supported BAUD_xxx enum from serial.h.
    257              // The actual baud rate is encoded in a byte and converted algorithmically
    258              // into the needed SCx register values based on system clock frequency
    259              // Here each byte is divided into two 4-bit nibbles 0x<mul><exp> where:
    260              // baud = <mul> * 100 * 2^<exp> when <exp> is <=10
    261              //  and = <mul> * 100 * 10^(<exp>-10) when <exp> is >10
    262              // This allows all supported baud rates (and many others) to be represented.
    263              0x30, //  0 - BAUD_300    =  3 * 100 * 2^0
    264              0x60, //  1 - BAUD_600    =  6 * 100 * 2^0
    265              0x90, //  2 - BAUD_900    =  9 * 100 * 2^0
    266              0xC0, //  3 - BAUD_1200   = 12 * 100 * 2^0
    267              0xC1, //  4 - BAUD_2400   = 12 * 100 * 2^1
    268              0xC2, //  5 - BAUD_4800   = 12 * 100 * 2^2
    269              0xC3, //  6 - BAUD_9600   = 12 * 100 * 2^3
    270              0x94, //  7 - BAUD_14400  =  9 * 100 * 2^4
    271              0xC4, //  8 - BAUD_19200  = 12 * 100 * 2^4
    272              0x95, //  9 - BAUD_28800  =  9 * 100 * 2^5
    273              0xC5, // 10 - BAUD_38400  = 12 * 100 * 2^5
    274              0x5C, // 11 - BAUD_50000  =  5 * 100 * 10^2
    275              0x96, // 12 - BAUD_57600  =  9 * 100 * 2^6
    276              0xC6, // 13 - BAUD_76800  = 12 * 100 * 2^6
    277              0xAC, // 14 - BAUD_100000 = 10 * 100 * 10^2
    278              0x97, // 15 - BAUD_115200 =  9 * 100 * 2^7
    279              0x98, // 16 - BAUD_230400 =  9 * 100 * 2^8
    280              0x99, // 17 - BAUD_460800 =  9 * 100 * 2^9
    281             #ifdef EMBER_SERIAL_BAUD_CUSTOM
    282              EMBER_SERIAL_BAUD_CUSTOM, //Hook for custom baud rate, see BOARD_HEADER
    283             #else
    284              0x9A, // 18 - BAUD_921600 =  9 * 100 * 2^10
    285             #endif
    286            };
    287          
    288          #endif // defined(EM_PHYSICAL_UART)
    289          
    290          #if EM_SERIAL1_ENABLED
    291            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    292            #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    293          
    294            #if    SLEEPY_IP_MODEM_UART
    295              //This macro is used to manipulate TxD to avoid glitching it across sleep
    296              //which can lead to spurrious data or framing errors seen by peer
    297              #define SC1_TXD_GPIO(gpioCfg, state) do {                                   \
    298                GPIO_PBCFGL = (GPIO_PBCFGL & ~PB1_CFG_MASK) | ((gpioCfg) << PB1_CFG_BIT); \
    299                (state) ? (GPIO_PBSET = PB1) : (GPIO_PBCLR = PB1);                        \
    300              } while (0)
    301            #else//!SLEEPY_IP_MODEM_UART
    302              #define SC1_TXD_GPIO(gpioCfg, state) do { } while (0)
    303            #endif//SLEEPY_IP_MODEM_UART
    304          #endif // EM_SERIAL1_ENABLED
    305          
    306          // figure out how many buffer state structs we need
    307          #if (EM_SERIAL1_ENABLED                                                        \
    308              && EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)                              \
    309              && (EM_SERIAL2_ENABLED                                                     \
    310              && EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER)
    311            static EmSerialBufferState serialBufferStates[] = {
    312              { EMBER_SERIAL1_RX_QUEUE_SIZE,
    313                (EMBER_SERIAL1_RX_QUEUE_SIZE/2),
    314                0,
    315                0,
    316                FALSE,
    317                FALSE,
    318                FALSE,
    319                { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    320              },
    321              { EMBER_SERIAL2_RX_QUEUE_SIZE,
    322                (EMBER_SERIAL2_RX_QUEUE_SIZE/2),
    323                0,
    324                0,
    325                FALSE,
    326                FALSE,
    327                FALSE,
    328                { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    329              }
    330            };
    331          
    332            #define BUFSTATE(port) (serialBufferStates + (port) - 1)
    333          #elif (EM_SERIAL1_ENABLED                                          \
    334                 && EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    335            static EmSerialBufferState serialBufferState = {
    336              EMBER_SERIAL1_RX_QUEUE_SIZE,
    337              (EMBER_SERIAL1_RX_QUEUE_SIZE/2),
    338              0,
    339              0,
    340              FALSE,
    341              FALSE,
    342              FALSE,
    343              { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    344            };
    345          
    346            #define BUFSTATE(port) (&serialBufferState)
    347          #elif (EM_SERIAL2_ENABLED                                          \
    348                 && EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER)
    349            static EmSerialBufferState serialBufferState = {
    350              EMBER_SERIAL2_RX_QUEUE_SIZE,
    351              (EMBER_SERIAL2_RX_QUEUE_SIZE/2),
    352              0,
    353              0,
    354              FALSE,
    355              FALSE,
    356              FALSE,
    357              { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    358            };
    359          
    360            #define BUFSTATE(port) (&serialBufferState)
    361          #endif
    362          
    363          // prototypes
    364          static void halInternalUartTxIsr(int8u port);
    365          static void uartErrorMark(int8u port, int8u errors);
    366          static void halInternalRestartUartDma(int8u port);
                             ^
Warning[Pe177]: function "halInternalRestartUartDma" was declared but never
          referenced
    367          
    368          // init function for soft uart
    369          #ifdef SOFTUART
    370          static EmberStatus halInternalInitSoftUart()
    371          {
    372            //make sure the TX bit starts at idle high
    373            SOFT_UART_TX_BIT(1);
    374            CONFIG_SOFT_UART_TX_BIT();
    375            CONFIG_SOFT_UART_RX_BIT();
    376          
    377            return EMBER_SUCCESS;
    378          }
    379          #endif
    380          
    381          #ifdef EM_PHYSICAL_UART
    382          static void halInternalInitUartInterrupts(int8u port)
    383          {
    384            #if defined(EM_ENABLE_SERIAL_FIFO)
    385              if (EM_SER_MULTI(EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port))) {
    386                // Make the RX Valid interrupt level sensitive (instead of edge)
    387                // SC1_INTMODE = SC_SPIRXVALMODE;
    388                // Enable just RX interrupts; TX interrupts are controlled separately
    389                INT_SCxCFG(port) |= (INT_SCRXVAL   |
    390                                     INT_SCRXOVF   |
    391                                     INT_SC1FRMERR |
    392                                     INT_SC1PARERR);
    393                INT_SCxFLAG(port) = 0xFFFF; // Clear any stale interrupts
    394                INT_CFGSET = INT_SCx(port);
    395              }
    396            #endif
    397            #if defined(EM_ENABLE_SERIAL_BUFFER)
    398              if (EM_SER_MULTI(EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port))) {
    399                halInternalRestartUartDma(port);
    400          
    401                // don't do this for port 1 if it's being used for EZSP
    402                #ifdef EZSP_UART
    403                  if (port != 1) {
    404                #endif
    405                    INT_SCxCFG(port) |= (INT_SCRXOVF   |
    406                                         INT_SC1FRMERR |
    407                                         INT_SC1PARERR);
    408                #ifdef EZSP_UART
    409                  }
    410                #endif
    411          
    412                // The receive side of buffer mode does not require any interrupts.
    413                // The transmit side of buffer mode requires interrupts, which
    414                // will be configured on demand in halInternalStartUartTx(), so just
    415                // enable the top level interrupt for the transmit side.
    416                INT_SCxFLAG(port) = 0xFFFF; // Clear any stale interrupts
    417                INT_CFGSET = INT_SCx(port); // Enable top-level interrupt
    418          
    419                #ifdef EMBER_SERIAL1_RTSCTS
    420                  // TODO refactor this into a variable that can be queried at runtime
    421                  if (EM_SER1_PORT_EN(port)) {
    422                    // Software-based RTS/CTS needs interrupts on DMA buffer unloading.
    423                    INT_SCxCFG(port) |= (INT_SCRXULDA | INT_SCRXULDB);
    424                    SCx_REG(port, UARTCFG) |= (SC_UARTFLOW | SC_UARTRTS);
    425                  }
    426                #endif
    427                #ifdef EMBER_SERIAL2_RTSCTS
    428                  if (EM_SER2_PORT_EN(port)) {
    429                    // Software-based RTS/CTS needs interrupts on DMA buffer unloading.
    430                    INT_SCxCFG(port) |= (INT_SCRXULDA | INT_SCRXULDB);
    431                    SCx_REG(port, UARTCFG) |= (SC_UARTFLOW | SC_UARTRTS);
    432                  }
    433                #endif
    434              }
    435            #endif
    436          }
    437          
    438          // init function for physical UART
    439          static EmberStatus halInternalInitPhysicalUart(int8u port,
    440                                                         SerialBaudRate rate,
    441                                                         SerialParity parity,
    442                                                         int8u stopBits)
    443          {
    444            int32u tempcfg;
    445          
    446            // set baud rate
    447            // If rate is one of the BAUD_ settings from serial.h then use
    448            // its baudSetting[] value from above, otherwise interpret it
    449            // as a custom baudSetting[] encoded value.
    450            if (rate < sizeof(baudSettings)/sizeof(*baudSettings)) {
    451              rate = baudSettings[rate];
    452            }
    453            // Convert encoded rate into baud by extracting the <mul> and <exp>
    454            // nibbles.  <mul> is always multiplied by 100.  For <exp> <= 10,
    455            // that result is multipled by 2^<exp>; for <exp> > 10 that result
    456            // is multipled by 10^(<exp>-10).
    457            tempcfg = (int32u)(rate >> 4) * 100; // multiplier
    458            rate &= 0x0F; // exponent
    459            if (rate <= 10) {
    460              tempcfg <<= rate;
    461            } else {
    462              while (rate-- > 10) {
    463                tempcfg *= 10;
    464              }
    465            }
    466            EmberStatus status = halInternalUartSetBaudRate(port, tempcfg);
    467            if (status != EMBER_SUCCESS) {
    468              return status;
    469            }
    470          
    471            // Default is always 8 data bits irrespective of parity setting,
    472            // according to Lee, but hack overloads high-order nibble of stopBits to
    473            // allow user to specify desired number of data bits:  7 or 8 (default).
    474            if (((stopBits & 0xF0) >> 4) == 7) {
    475              tempcfg = 0;
    476            } else {
    477              tempcfg = SC_UART8BIT;
    478            }
    479          
    480            // parity bits
    481            if (parity == PARITY_ODD) {
    482              tempcfg |= SC_UARTPAR | SC_UARTODD;
    483            } else if( parity == PARITY_EVEN ) {
    484              tempcfg |= SC_UARTPAR;
    485            }
    486          
    487            // stop bits
    488            if ((stopBits & 0x0F) >= 2) {
    489              tempcfg |= SC_UART2STP;
    490            }
    491          
    492            // set all of the above into the config register
    493            SCx_REG(port, UARTCFG) = tempcfg;
    494          
    495            // put the peripheral into UART mode
    496            SCx_REG(port, MODE) = SC1_MODE_UART;
    497          
    498            if (EM_SER1_PORT_EN(port)) { // port 1 special glitch-free case 
    499              SC1_TXD_GPIO(GPIOCFG_OUT_ALT, 1); // Can Assign TxD glitch-free to UART now
    500            }
    501          
    502            halInternalInitUartInterrupts(port);
    503          
    504            #ifdef EMBER_SERIAL1_XONXOFF
    505              if (EM_SER1_PORT_EN(port)) { // port 1 XON/XOFF special case
    506                halInternalUart1ForceXon();
    507              }
    508            #endif
    509          
    510            return EMBER_SUCCESS;
    511          }
    512          #endif // EM_PHYSICAL_UART
    513          
    514          // initialize USB Virtual COM Port
    515          #if EM_SERIAL3_ENABLED
    516          static EmberStatus halInternalInitUsbVcp(void)
    517          {
    518            #if defined(CORTEXM3_EM35X_USB)
    519              halResetWatchdog();
    520          
    521              tokTypeMfgEui64 tokEui64;
    522              halCommonGetMfgToken((void *)&tokEui64, TOKEN_MFG_EUI_64);
    523          
    524              int8u i = 0;
    525              int8u j = 0;
    526              for(j = 0; j<8; j++) {
    527                iSerialNumber.name[i++] = nibble2Ascii((tokEui64[j]>>4)&0xF);
    528                iSerialNumber.name[i++] = nibble2Ascii((tokEui64[j]>>0)&0xF);
    529              }
    530          
    531              USBD_Init(&initstruct);
    532          
    533              // USBD_Read(EP_OUT, receiveBuffer, 50, dataReceivedCallback);
    534          
    535              //It is necessary to wait for the COM port on the host to become
    536              //active before serial port3 can be used.
    537              int16u startTime = halCommonGetInt16uMillisecondTick();
    538              while(USBD_GetUsbState()!=USBD_STATE_CONFIGURED) {
    539                //Give ourselves a healthy 1 second for a COM port to open.
    540                if(elapsedTimeInt16u(startTime,
    541                                     halCommonGetInt16uMillisecondTick()) > 1000) {
    542                  return EMBER_SERIAL_INVALID_PORT;
    543                }
    544              }
    545          
    546              return EMBER_SUCCESS;
    547            #endif
    548          }
    549          #endif
    550          
    551          #if (EM_SERIAL0_ENABLED ||\
    552               EM_SERIAL1_ENABLED ||\
    553               EM_SERIAL2_ENABLED ||\
    554               EM_SERIAL3_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    555          EmberStatus halInternalUartInit(int8u port,
    556                                          SerialBaudRate rate,
    557                                          SerialParity parity,
    558                                          int8u stopBits)
    559          {
   \                     halInternalUartInit:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4614             MOV      R4,R2
   \   00000004   0x461D             MOV      R5,R3
    560            #if EM_SERIAL0_ENABLED
    561              if (EM_SER0_PORT_EN(port)) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD043             BEQ.N    ??halInternalUartInit_0
    562                // Nothing special to do since the debug channel handles this
    563                return EMBER_SUCCESS;
    564              }
    565            #endif
    566          
    567            #ifdef SOFTUART
    568              if (EM_SER1_PORT_EN(port)) {
    569                return halInternalInitSoftUart();
    570              }
    571            #endif
    572          
    573            #ifdef EM_PHYSICAL_UART
    574              if (EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) {
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD140             BNE.N    ??halInternalUartInit_1
    575                return halInternalInitPhysicalUart(port, rate, parity, stopBits);
   \   0000000E   0x2913             CMP      R1,#+19
   \   00000010   0xBF3C             ITT      CC 
   \   00000012   0x.... 0x....      ADRCC.W  R0,baudSettings
   \   00000016   0x5C09             LDRBCC   R1,[R1, R0]
   \   00000018   0x0908             LSRS     R0,R1,#+4
   \   0000001A   0x2264             MOVS     R2,#+100
   \   0000001C   0x4350             MULS     R0,R2,R0
   \   0000001E   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000022   0x290B             CMP      R1,#+11
   \   00000024   0xD203             BCS.N    ??halInternalUartInit_2
   \   00000026   0x4088             LSLS     R0,R0,R1
   \   00000028   0xE006             B.N      ??halInternalUartInit_3
   \                     ??halInternalUartInit_4:
   \   0000002A   0x220A             MOVS     R2,#+10
   \   0000002C   0x4350             MULS     R0,R2,R0
   \                     ??halInternalUartInit_2:
   \   0000002E   0x460A             MOV      R2,R1
   \   00000030   0x1E51             SUBS     R1,R2,#+1
   \   00000032   0xB2D2             UXTB     R2,R2
   \   00000034   0x2A0B             CMP      R2,#+11
   \   00000036   0xD2F8             BCS.N    ??halInternalUartInit_4
   \                     ??halInternalUartInit_3:
   \   00000038   0x4601             MOV      R1,R0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       halInternalUartSetBaudRate
   \   00000040   0xBB38             CBNZ.N   R0,??halInternalUartInit_0
   \   00000042   0x0928             LSRS     R0,R5,#+4
   \   00000044   0x2807             CMP      R0,#+7
   \   00000046   0xBF0C             ITE      EQ 
   \   00000048   0x2000             MOVEQ    R0,#+0
   \   0000004A   0x2002             MOVNE    R0,#+2
   \   0000004C   0x2C01             CMP      R4,#+1
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0xF040 0x0018      ORREQ    R0,R0,#0x18
   \   00000054   0xD003             BEQ.N    ??halInternalUartInit_5
   \   00000056   0x2C02             CMP      R4,#+2
   \   00000058   0xBF08             IT       EQ 
   \   0000005A   0xF040 0x0008      ORREQ    R0,R0,#0x8
   \                     ??halInternalUartInit_5:
   \   0000005E   0xF005 0x010F      AND      R1,R5,#0xF
   \   00000062   0x2902             CMP      R1,#+2
   \   00000064   0xBFA8             IT       GE 
   \   00000066   0xF040 0x0004      ORRGE    R0,R0,#0x4
   \   0000006A   0x....             LDR.N    R1,??DataTable15  ;; 0x4000c854
   \   0000006C   0x6088             STR      R0,[R1, #+8]
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x6008             STR      R0,[R1, #+0]
   \   00000072   0x....             LDR.N    R0,??DataTable15_1  ;; 0x4000a808
   \   00000074   0x6C01             LDR      R1,[R0, #+64]
   \   00000076   0xF441 0x41C0      ORR      R1,R1,#0x6000
   \   0000007A   0xF041 0x0109      ORR      R1,R1,#0x9
   \   0000007E   0x6401             STR      R1,[R0, #+64]
   \   00000080   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000084   0x6001             STR      R1,[R0, #+0]
   \   00000086   0x....             LDR.N    R0,??DataTable15_2  ;; 0xe000e100
   \   00000088   0x2120             MOVS     R1,#+32
   \   0000008A   0x6001             STR      R1,[R0, #+0]
   \   0000008C   0x2000             MOVS     R0,#+0
    576              }
   \   0000008E   0xBD32             POP      {R1,R4,R5,PC}
    577            #endif
    578          
    579            #if EM_SERIAL3_ENABLED && defined(CORTEXM3_EM35X_USB)
    580              if (EM_SER3_PORT_EN(port)) {
    581                return halInternalInitUsbVcp();
    582              }
    583            #endif
    584          
    585            return EMBER_SERIAL_INVALID_PORT;
   \                     ??halInternalUartInit_1:
   \   00000090   0x2021             MOVS     R0,#+33
   \                     ??halInternalUartInit_0:
   \   00000092   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    586          }
    587          #endif//(!defined(EM_SERIAL0_DISABLED) || !defined(EM_SERIAL1_DISABLED))
    588          
    589          #ifdef SOFTUART
    590          //this requires use of the SysTick counter and will destroy interrupt latency!
    591          static void softwareUartTxByte(int8u byte)
    592          {
    593            int8u i;
    594            // BIT_TIMEs were determined based on 24 MHz MCU clock.
    595            // Scale 'em for the actual MCU clock in effect, with rounding.
    596            // (Because the FCLK might not evenly divide by 1000 or even 500, use quad
    597            // arithmetic dividing it by 250.)
    598            int16u fullBitTime = (int16u)(((FULL_BIT_TIME_SCLK
    599                                         * ((int32u)halMcuClockKHz() / 250)) + 48) / 96);
    600          
    601            ATOMIC(
    602              ST_RVR = fullBitTime; //set the SysTick reload value register
    603              //enable core clock reference and the counter itself
    604              ST_CSR = (ST_CSR_CLKSOURCE | ST_CSR_ENABLE);
    605              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    606          
    607              //go low for start bit
    608              SOFT_UART_TX_BIT(0); //go low for start bit
    609              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    610          
    611              //loop over all 8 data bits transmitting each
    612              for (i=0;i<8;i++) {
    613                SOFT_UART_TX_BIT(byte&0x1); //data bit
    614                while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    615                byte = (byte>>1);
    616              }
    617          
    618              SOFT_UART_TX_BIT(1); //stop bit
    619              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    620          
    621              //disable SysTick
    622              ST_CSR = 0;
    623            )
    624          }
    625          #endif //SOFTUART
    626          

   \                                 In section .text, align 2, keep-with-next
    627          void halInternalStartUartTx(int8u port)
    628          {
   \                     halInternalStartUartTx:
   \   00000000   0xB510             PUSH     {R4,LR}
    629            #if EM_SERIAL0_ENABLED
    630              if (EM_SER0_PORT_EN(port)) {
   \   00000002   0xB990             CBNZ.N   R0,??halInternalStartUartTx_0
    631                #if EMBER_SERIAL0_MODE == EMBER_SERIAL_FIFO
    632                  EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[0];
   \   00000004   0x....             LDR.N    R0,??DataTable15_3
   \   00000006   0x6804             LDR      R4,[R0, #+0]
    633                  assert(q->tail == 0);
   \   00000008   0x8860             LDRH     R0,[R4, #+2]
   \   0000000A   0xB128             CBZ.N    R0,??halInternalStartUartTx_1
   \   0000000C   0xF240 0x2179      MOVW     R1,#+633
   \   00000010   0x.... 0x....      ADR.W    R0,`?<Constant "uart.c">`
   \   00000014   0x.... 0x....      BL       halInternalAssertFailed
    634                  emDebugSendVuartMessage(q->fifo, q->used);
   \                     ??halInternalStartUartTx_1:
   \   00000018   0x88A1             LDRH     R1,[R4, #+4]
   \   0000001A   0xB2C9             UXTB     R1,R1
   \   0000001C   0x1DA0             ADDS     R0,R4,#+6
   \   0000001E   0x.... 0x....      BL       emDebugSendVuartMessage
    635                  q->used = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x80A0             STRH     R0,[R4, #+4]
    636                  q->head = 0;
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    637                  return;
   \   00000028   0xBD10             POP      {R4,PC}
    638                #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_BUFFER
    639                  EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[0];
    640                  assert(q->nextByte == NULL);
    641                  emSerialBufferNextMessageIsr(q);
    642                  while (q->nextByte != NULL) {
    643                    emDebugSendVuartMessage(q->nextByte, (q->lastByte-q->nextByte)+1);
    644                    emSerialBufferNextBlockIsr(q,0);
    645                  }
    646                  return;
    647                #endif
    648              }
    649            #endif//!defined(EM_SERIAL0_DISABLED)
    650          
    651            #if EM_SERIAL1_ENABLED && defined(SOFTUART)
    652              if (EM_SER1_PORT_EN(port)) {
    653                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[1];
    654                // Always configure the bit because other operations might have
    655                // tried to compromise it
    656                SOFT_UART_TX_BIT(1);
    657                CONFIG_SOFT_UART_TX_BIT();
    658                while (q->used > 0) {
    659                  int8u byte = FIFO_DEQUEUE(q, emSerialTxQueueWraps[1]);
    660                  softwareUartTxByte(byte);
    661                }
    662                return;
    663              }
    664            #endif
    665          
    666            #if defined(EM_PHYSICAL_UART)
    667              // If the port is configured, go ahead and start transmit
    668              #if defined(EM_ENABLE_SERIAL_FIFO)
    669                if ((EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port)) &&
    670                    (SCx_REG(port, MODE) == SC1_MODE_UART)) {
   \                     ??halInternalStartUartTx_0:
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xBF02             ITTT     EQ 
   \   0000002E   0x....             LDREQ.N  R0,??DataTable15  ;; 0x4000c854
   \   00000030   0x6800             LDREQ    R0,[R0, #+0]
   \   00000032   0x2801             CMPEQ    R0,#+1
   \   00000034   0xD10F             BNE.N    ??halInternalStartUartTx_2
    671                  // Ensure UART TX interrupts are enabled,
    672                  // and call the ISR to send any pending output
    673                  ATOMIC(
    674                    // Enable TX interrupts
    675                    INT_SCxCFG(port) |= (INT_SCTXFREE | INT_SCTXIDLE);
    676                    // Pretend we got a tx interrupt
    677                    halInternalUartTxIsr(port);
    678                  )
   \   00000036   0x.... 0x....      BL       _disableBasePri
   \   0000003A   0x4604             MOV      R4,R0
   \   0000003C   0x....             LDR.N    R0,??DataTable15_4  ;; 0x4000a848
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xF041 0x0106      ORR      R1,R1,#0x6
   \   00000044   0x6001             STR      R1,[R0, #+0]
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       halInternalUartTxIsr
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000052   0x.... 0x....      B.W      _writeBasePri
    679                  return;
    680                }
   \                     ??halInternalStartUartTx_2:
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    681              #endif // defined(EM_ENABLE_SERIAL_FIFO)
    682              #if defined(EM_ENABLE_SERIAL_BUFFER)
    683                if ((EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) &&
    684                    (SCx_REG(port, MODE) == SC1_MODE_UART)) {
    685                  // Ensure UART TX interrupts are enabled,
    686                  // and call the ISR to send any pending output
    687                  ATOMIC(
    688                    INT_SCxCFG(port) |= (INT_SCTXULDA | INT_SCTXULDB | INT_SCTXIDLE);
    689                    // Pretend we got a tx interrupt
    690                    halInternalUartTxIsr(port);
    691                  )
    692                  return;
    693                }
    694              #endif // defined(EM_ENABLE_SERIAL_BUFFER)
    695            #endif // EM_PHYSICAL_UART
    696          
    697            // why not buffered mode? --RDM
    698            #if EM_SERIAL3_ENABLED && EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO
    699              if (EM_SER3_PORT_EN(port)) {
    700                #if defined(CORTEXM3_EM35X_USB)
    701                  //Call into the usb.c driver which will operate on serial
    702                  //port 3's Q to transmit data.
    703                  usbTxData();
    704                  return;
    705                #endif
    706              }
    707            #endif // EM_SERIAL3_ENABLED && EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO
    708          }
    709          

   \                                 In section .text, align 2, keep-with-next
    710          void halInternalStopUartTx(int8u port)
    711          {
    712            // Nothing for port 0 (virtual uart)
    713          
    714            #if defined(EM_PHYSICAL_UART)
    715              #if defined(EM_ENABLE_SERIAL_FIFO)
    716                if (EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port)) {
   \                     halInternalStopUartTx:
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD104             BNE.N    ??halInternalStopUartTx_0
    717                  // Disable TX Interrupts
    718                  INT_SCxCFG(port) &= ~(INT_SCTXFREE | INT_SCTXIDLE);
   \   00000004   0x....             LDR.N    R0,??DataTable15_4  ;; 0x4000a848
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF021 0x0106      BIC      R1,R1,#0x6
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    719                }
    720              #endif // defined(EM_ENABLE_SERIAL_FIFO)
    721              #if defined(EM_ENABLE_SERIAL_BUFFER)
    722                if (EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) {
    723                  // Ensure DMA operations are complete before shutting off interrupts,
    724                  // otherwise we might miss an important interrupt and cause a
    725                  // packet buffer leak, e.g.
    726                  while (SCx_REG(port, DMACTRL) & (SC_TXLODA | SC_TXLODB)) {}
    727                  while ( !(SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE) ) {}
    728                  // Disable TX Interrupts
    729                  INT_SCxCFG(port) &= ~(INT_SCTXULDA | INT_SCTXULDB | INT_SCTXIDLE);
    730                }
    731              #endif // defined(EM_ENABLE_SERIAL_BUFFER)
    732            #endif // defined(EM_PHYSICAL_UART)
    733          }
   \                     ??halInternalStopUartTx_0:
   \   0000000E   0x4770             BX       LR               ;; return
    734          
    735          
    736          //full blocking, no queue overflow issues, can be used in or out of int context
    737          //does not return until character is transmitted.

   \                                 In section .text, align 2, keep-with-next
    738          EmberStatus halInternalForceWriteUartData(int8u port, int8u *data, int8u length)
    739          {
   \                     halInternalForceWriteUartData:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x460B             MOV      R3,R1
   \   00000004   0x4611             MOV      R1,R2
    740            #if EM_SERIAL0_ENABLED
    741              if (EM_SER0_PORT_EN(port)) {
   \   00000006   0xB920             CBNZ.N   R0,??halInternalForceWriteUartData_0
    742                emDebugSendVuartMessage(data, length);
   \   00000008   0x4618             MOV      R0,R3
   \   0000000A   0x.... 0x....      BL       emDebugSendVuartMessage
    743                return EMBER_SUCCESS;
   \                     ??halInternalForceWriteUartData_1:
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD02             POP      {R1,PC}
    744              }
    745            #endif
    746          
    747            #ifdef SOFTUART
    748              if (EM_SER1_PORT_EN(port)) {
    749                //always configure the bit because other operations might have
    750                //tried to compromise it
    751                SOFT_UART_TX_BIT(1);
    752                CONFIG_SOFT_UART_TX_BIT();
    753                while (length--) {
    754                  SC1_DATA = *data; // why is the soft UART using the physical UART? --RDM
    755                  softwareUartTxByte(*data);
    756                  data++;
    757                }
    758                return EMBER_SUCCESS;
    759              }
    760            #endif
    761          
    762            #if defined(EM_PHYSICAL_UART)
    763              //if the port is configured, go ahead and transmit
    764              if ((EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) &&
    765                  (SCx_REG(port, MODE) == SC1_MODE_UART)) {
   \                     ??halInternalForceWriteUartData_0:
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x....             LDREQ.N  R0,??DataTable15_5  ;; 0x4000c83c
   \   00000018   0x6982             LDREQ    R2,[R0, #+24]
   \   0000001A   0x2A01             CMPEQ    R2,#+1
   \   0000001C   0xD007             BEQ.N    ??halInternalForceWriteUartData_2
    766                while (length--) {
    767                  //spin until data register has room for more data
    768                  while (!(SCx_REG(port, UARTSTAT) & SC_UARTTXFREE)) {}
    769                  SCx_REG(port, DATA) = *data;
    770                  data++;
    771                }
    772          
    773                //spin until TX complete (TX is idle)
    774                while (!(SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE)) {}
    775          
    776                return EMBER_SUCCESS;
    777              }
    778            #endif // defined(EM_PHYSICAL_UART)
    779          
    780            #if EM_SERIAL3_ENABLED
    781              if (EM_SER3_PORT_EN(port)) {
    782                #if defined(CORTEXM3_EM35X_USB)
    783                  //This function will block until done sending all the data.
    784                  usbForceTxData(data, length);
    785                  return EMBER_SUCCESS;
    786                #endif
    787              }
    788            #endif // EM_SERIAL3_ENABLED
    789          
    790            return EMBER_SERIAL_INVALID_PORT;
   \   0000001E   0x2021             MOVS     R0,#+33
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
   \                     ??halInternalForceWriteUartData_3:
   \   00000022   0x68C2             LDR      R2,[R0, #+12]
   \   00000024   0x0752             LSLS     R2,R2,#+29
   \   00000026   0xD5FC             BPL.N    ??halInternalForceWriteUartData_3
   \   00000028   0xF813 0x2B01      LDRB     R2,[R3], #+1
   \   0000002C   0x6002             STR      R2,[R0, #+0]
   \                     ??halInternalForceWriteUartData_2:
   \   0000002E   0x460A             MOV      R2,R1
   \   00000030   0x1E51             SUBS     R1,R2,#+1
   \   00000032   0xB2D2             UXTB     R2,R2
   \   00000034   0x2A00             CMP      R2,#+0
   \   00000036   0xD1F4             BNE.N    ??halInternalForceWriteUartData_3
   \                     ??halInternalForceWriteUartData_4:
   \   00000038   0x68C1             LDR      R1,[R0, #+12]
   \   0000003A   0x0649             LSLS     R1,R1,#+25
   \   0000003C   0xD5FC             BPL.N    ??halInternalForceWriteUartData_4
   \   0000003E   0xE7E6             B.N      ??halInternalForceWriteUartData_1
    791          }
    792          
    793          // Useful for waiting on serial port characters before interrupts have been
    794          // turned on.

   \                                 In section .text, align 2, keep-with-next
    795          EmberStatus halInternalForceReadUartByte(int8u port, int8u* dataByte)
    796          {
   \                     halInternalForceReadUartByte:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
    797            EmberStatus err = EMBER_SUCCESS;
   \   00000004   0x2400             MOVS     R4,#+0
    798          
    799            #if EM_SERIAL0_ENABLED
    800              if (EM_SER0_PORT_EN(port)) {
   \   00000006   0xB9F8             CBNZ.N   R0,??halInternalForceReadUartByte_0
    801                EmSerialFifoQueue *q = emSerialRxQueues[0];
   \   00000008   0x....             LDR.N    R0,??DataTable15_6
   \   0000000A   0x6806             LDR      R6,[R0, #+0]
    802                ATOMIC(
    803                  if (q->used == 0) {
    804                    WAKE_CORE = WAKE_CORE_FIELD;
    805                  }
    806                  if (q->used > 0) {
    807                    *dataByte = FIFO_DEQUEUE(q, emSerialRxQueueWraps[0]);
    808                  } else {
    809                    err = EMBER_SERIAL_RX_EMPTY;
    810                  }
    811                )
   \   0000000C   0x.... 0x....      BL       _disableBasePri
   \   00000010   0x88B1             LDRH     R1,[R6, #+4]
   \   00000012   0xB911             CBNZ.N   R1,??halInternalForceReadUartByte_1
   \   00000014   0x....             LDR.N    R1,??DataTable15_7  ;; 0x40000024
   \   00000016   0x2220             MOVS     R2,#+32
   \   00000018   0x600A             STR      R2,[R1, #+0]
   \                     ??halInternalForceReadUartByte_1:
   \   0000001A   0x88B1             LDRH     R1,[R6, #+4]
   \   0000001C   0xB181             CBZ.N    R1,??halInternalForceReadUartByte_2
   \   0000001E   0x8871             LDRH     R1,[R6, #+2]
   \   00000020   0x1989             ADDS     R1,R1,R6
   \   00000022   0x7989             LDRB     R1,[R1, #+6]
   \   00000024   0x7029             STRB     R1,[R5, #+0]
   \   00000026   0x8871             LDRH     R1,[R6, #+2]
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x....             LDR.N    R2,??DataTable15_8
   \   0000002C   0x8812             LDRH     R2,[R2, #+0]
   \   0000002E   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   00000032   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   00000036   0x8071             STRH     R1,[R6, #+2]
   \   00000038   0x88B1             LDRH     R1,[R6, #+4]
   \   0000003A   0x1E49             SUBS     R1,R1,#+1
   \   0000003C   0x80B1             STRH     R1,[R6, #+4]
   \   0000003E   0xE000             B.N      ??halInternalForceReadUartByte_3
   \                     ??halInternalForceReadUartByte_2:
   \   00000040   0x2426             MOVS     R4,#+38
   \                     ??halInternalForceReadUartByte_3:
   \   00000042   0x.... 0x....      BL       _writeBasePri
   \   00000046   0xE008             B.N      ??halInternalForceReadUartByte_4
    812              }
    813            #endif // EM_SERIAL0_ENABLED
    814          
    815            #if defined(EM_PHYSICAL_UART)
    816              #if defined(EM_ENABLE_SERIAL_FIFO)
    817                if (EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port)) {
   \                     ??halInternalForceReadUartByte_0:
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD106             BNE.N    ??halInternalForceReadUartByte_4
    818                  if (SCx_REG(port, UARTSTAT) & SC_UARTRXVAL) {
   \   0000004C   0x....             LDR.N    R0,??DataTable15_5  ;; 0x4000c83c
   \   0000004E   0x68C1             LDR      R1,[R0, #+12]
   \   00000050   0x0789             LSLS     R1,R1,#+30
   \   00000052   0xBF46             ITTE     MI 
   \   00000054   0x6800             LDRMI    R0,[R0, #+0]
   \   00000056   0x7028             STRBMI   R0,[R5, #+0]
   \   00000058   0x2426             MOVPL    R4,#+38
    819                    *dataByte = (int8u) SCx_REG(port, DATA);
    820                  } else {
    821                    err = EMBER_SERIAL_RX_EMPTY;
    822                  }
    823                }
    824              #endif
    825              #if defined(EM_ENABLE_SERIAL_BUFFER)
    826                if (EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) {
    827                  //When in buffer mode, the DMA channel is active and the RXVALID bit (as
    828                  //used above in FIFO mode) will never get set.  To maintain the DMA/Buffer
    829                  //model of operation, we need to break the conceptual model in this function
    830                  //and make a function call upwards away from the hardware.  The ReadByte
    831                  //function calls back down into halInternalUartRxPump and forces the
    832                  //sequencing of the serial queues and the DMA buffer, resulting in a forced
    833                  //read byte being returned if it is there.
    834                  if (emberSerialReadByte(port, dataByte) != EMBER_SUCCESS) {
    835                    err = EMBER_SERIAL_RX_EMPTY;
    836                  }
    837                }
    838              #endif // defined(EM_ENABLE_SERIAL_BUFFER)
    839            #endif // defined(EM_PHYSICAL_UART)
    840          
    841            return err;
   \                     ??halInternalForceReadUartByte_4:
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    842          }
    843          
    844          // blocks until the text actually goes out

   \                                 In section .text, align 2, keep-with-next
    845          void halInternalWaitUartTxComplete(int8u port)
    846          {
   \                     halInternalWaitUartTxComplete:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    847            halResetWatchdog();
   \   00000004   0x.... 0x....      BL       halInternalResetWatchDog
    848          
    849            // Nothing to do for port 0 (virtual uart)
    850          
    851            #if defined(EM_PHYSICAL_UART)
    852            if (EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) {
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD103             BNE.N    ??halInternalWaitUartTxComplete_0
    853                while ( !(SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE) ) {}
   \                     ??halInternalWaitUartTxComplete_1:
   \   0000000C   0x....             LDR.N    R0,??DataTable15_9  ;; 0x4000c848
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0640             LSLS     R0,R0,#+25
   \   00000012   0xD5FB             BPL.N    ??halInternalWaitUartTxComplete_1
   \                     ??halInternalWaitUartTxComplete_0:
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    854                return;
    855              }
    856            #endif // defined(EM_PHYSICAL_UART)
    857          }
    858          
    859          // Debug Channel calls this ISR to push up data it has received

   \                                 In section .text, align 2, keep-with-next
    860          void halStackReceiveVuartMessage(int8u *data, int8u length)
    861          {
   \                     halStackReceiveVuartMessage:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    862            #if EM_SERIAL0_ENABLED
    863              EmSerialFifoQueue *q = emSerialRxQueues[0];
   \   00000002   0x....             LDR.N    R2,??DataTable15_6
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x....             LDR.N    R3,??DataTable15_8
   \   00000008   0xE00F             B.N      ??halStackReceiveVuartMessage_0
    864          
    865              while (length--) {
    866                //Use (emSerialRxQueueSizes - 1) so that the FIFO never completely fills
    867                //and the head never wraps around to the tail
    868                if ((q->used < (emSerialRxQueueSizes[0] - 1))) {
    869                  FIFO_ENQUEUE(q,*data++,emSerialRxQueueWraps[0]);
   \                     ??halStackReceiveVuartMessage_1:
   \   0000000A   0x8814             LDRH     R4,[R2, #+0]
   \   0000000C   0x18A4             ADDS     R4,R4,R2
   \   0000000E   0xF810 0x5B01      LDRB     R5,[R0], #+1
   \   00000012   0x71A5             STRB     R5,[R4, #+6]
   \   00000014   0x8814             LDRH     R4,[R2, #+0]
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \   00000018   0x881D             LDRH     R5,[R3, #+0]
   \   0000001A   0xFB94 0xF6F5      SDIV     R6,R4,R5
   \   0000001E   0xFB05 0x4416      MLS      R4,R5,R6,R4
   \   00000022   0x8014             STRH     R4,[R2, #+0]
   \   00000024   0x8894             LDRH     R4,[R2, #+4]
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0x8094             STRH     R4,[R2, #+4]
    870                } else {
   \                     ??halStackReceiveVuartMessage_0:
   \   0000002A   0x460C             MOV      R4,R1
   \   0000002C   0x1E61             SUBS     R1,R4,#+1
   \   0000002E   0xB2E4             UXTB     R4,R4
   \   00000030   0xB154             CBZ.N    R4,??halStackReceiveVuartMessage_2
   \   00000032   0x8894             LDRH     R4,[R2, #+4]
   \   00000034   0x....             LDR.N    R5,??DataTable15_10
   \   00000036   0x882D             LDRH     R5,[R5, #+0]
   \   00000038   0x1E6D             SUBS     R5,R5,#+1
   \   0000003A   0x42AC             CMP      R4,R5
   \   0000003C   0xDBE5             BLT.N    ??halStackReceiveVuartMessage_1
    871                  uartErrorMark(0, EMBER_SERIAL_RX_OVERFLOW);
   \   0000003E   0x2123             MOVS     R1,#+35
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000046   0x....             B.N      uartErrorMark
    872                  return;  // no sense in trying to enqueue the rest
    873                }
    874              }
   \                     ??halStackReceiveVuartMessage_2:
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    875            #endif // EM_SERIAL0_ENABLED
    876          }
    877          
    878          #if defined(EM_ENABLE_SERIAL_BUFFER)
    879          static void halInternalRestartUartDma(int8u port)
    880          {
    881            //Reset the DMA software and restart it.
    882            EmSerialFifoQueue *q = emSerialRxQueues[port];
    883            int32u startAddress = (int32u)q->fifo;
    884            int8u head;
    885            int8u tail;
    886            int8u loadA = 0;
    887            int8u loadB = 0;
    888            BUFSTATE(port)->prevCountA = 0;
    889            BUFSTATE(port)->prevCountB = 0;
    890            BUFSTATE(port)->waitingForTailA = FALSE;
    891            BUFSTATE(port)->waitingForTailB = FALSE;
    892            BUFSTATE(port)->waitingForInputToB = FALSE;
    893            //reload all defaults addresses - they will be adjusted below if needed
    894            SCx_REG(port, DMACTRL) = SC_RXDMARST;
    895            SCx_REG(port, RXBEGA) =  startAddress;
    896            SCx_REG(port, RXENDA) = (startAddress + BUFSTATE(port)->fifoSize/2 - 1);
    897            SCx_REG(port, RXBEGB) =  (startAddress + BUFSTATE(port)->fifoSize/2);
    898            SCx_REG(port, RXENDB) = (startAddress + BUFSTATE(port)->fifoSize - 1);
    899          
    900            //adjust buffer addresses as needed and reload available buffers
    901            if ( q->used != BUFSTATE(port)->fifoSize ) {
    902              //we can only reload if the FIFO isn't full!
    903              //the FIFO is not empty or full, figure out what to do:
    904              //at this point we know we always have to adjust ST_ADDR to the head
    905              //we need to know which buffer the head is in, and always load that buff
    906              if ((q->head) < BUFSTATE(port)->rxStartIndexB) {
    907                SCx_REG(port, RXBEGA) = startAddress + (q->head);
    908                loadA++;
    909              } else {
    910                SCx_REG(port, RXBEGB) = startAddress + (q->head);
    911                loadB++;
    912              }
    913              //check to see if the head and the tail are not in the same buffer
    914              if((q->tail)/(BUFSTATE(port)->rxStartIndexB)) {
    915                tail = TRUE;  //Tail in B buffer
    916              } else {
    917                tail = FALSE; //Tail in A buffer
    918              }
    919          
    920              if((q->head)/(BUFSTATE(port)->rxStartIndexB)) {
    921                head = TRUE;  //Head in B buffer
    922              } else {
    923                head = FALSE; //Head in A buffer
    924              }
    925          
    926              if ( tail != head ) {
    927                //the head and the tail are in different buffers
    928                //we need to flag the buffer the tail is in so the Pump function does
    929                //not try to reenable it until it has been drained like normal.
    930                if ((q->tail)<BUFSTATE(port)->rxStartIndexB) {
    931                  BUFSTATE(port)->waitingForTailA = TRUE;
    932                } else {
    933                  BUFSTATE(port)->waitingForTailB = TRUE;
    934                }
    935              } else {
    936                //the head and the tail are in the same buffers
    937                if (q->used <= BUFSTATE(port)->rxStartIndexB) {
    938                  //The serial FIFO is less no more than half full!
    939                  if (!loadB) {
    940                    //the head is in B, and we're capable of loading A
    941                    //BUT: we can't activate A because the DMA defaults to A first,
    942                    //  and it needs to start using B first to fill from the head
    943                    //  SO, only load A if B hasn't been marked yet for loading.
    944                    loadA++;
    945                  } else {
    946                    //B is loaded and waiting for data, A is being supressed until
    947                    //B receives at least one byte so A doesn't prematurely load and
    948                    //steal bytes meant for B first.
    949                    BUFSTATE(port)->waitingForTailA = TRUE;
    950                    BUFSTATE(port)->waitingForInputToB = TRUE;
    951                  }
    952                  //We can always loadB at this point thanks to our waiting* flags.
    953                  loadB++;
    954                } else {
    955                  //The serial FIFO is more than half full!
    956                  //Since this case requires moving an end address of a buffer, which
    957                  //severely breaks DMA'ing into a FIFO, we cannot do anything.
    958                  //Doing nothing is ok because we are more than half full anyways,
    959                  //and under normal operation we would only load a buffer when our
    960                  //used count is less than half full.
    961                  //Configure so the Pump function takes over when the serial FIFO drains
    962                  SCx_REG(port, RXBEGA) =  startAddress;
    963                  SCx_REG(port, RXBEGB) =  (startAddress + BUFSTATE(port)->fifoSize/2);
    964                  loadA = 0;
    965                  loadB = 0;
    966                  BUFSTATE(port)->waitingForTailA = TRUE;
    967                  BUFSTATE(port)->waitingForTailB = TRUE;
    968                }
    969              }
    970          
    971              //Address are set, flags are set, DMA is ready, so now we load buffers
    972              if (loadA) {
    973                SCx_REG(port, DMACTRL) = SC_RXLODA;
    974              }
    975              if (loadB) {
    976                SCx_REG(port, DMACTRL) = SC_RXLODB;
    977              }
    978            } else {
    979              //we're full!!  doh!  have to wait for the FIFO to drain
    980              BUFSTATE(port)->waitingForTailA = TRUE;
    981              BUFSTATE(port)->waitingForTailB = TRUE;
    982            }
    983          }
    984          #endif // defined(EM_ENABLE_SERIAL_BUFFER)
    985          
    986          #ifdef EM_PHYSICAL_UART

   \                                 In section .text, align 2, keep-with-next
    987          void halInternalUartRxIsr(int8u port, int16u causes)
    988          {
   \                     halInternalUartRxIsr:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    989            #if defined(EM_ENABLE_SERIAL_FIFO)
    990              if (EM_SER_MULTI(EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port))) {
    991                EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000006   0x4625             MOV      R5,R4
   \   00000008   0x....             LDR.N    R0,??DataTable15_6
   \   0000000A   0xF850 0x6025      LDR      R6,[R0, R5, LSL #+2]
   \   0000000E   0x.... 0x....      LDR.W    R9,??DataTable15_8
   \   00000012   0x.... 0x....      LDR.W    R8,??DataTable15_10
   \   00000016   0x....             LDR.N    R7,??DataTable15_5  ;; 0x4000c83c
   \   00000018   0xE014             B.N      ??halInternalUartRxIsr_0
    992          
    993                // At present we really don't care which interrupt(s)
    994                // occurred, just that one did.  Loop reading RXVALID
    995                // data (loop is necessary for bursty data otherwise
    996                // we could leave with RXVALID and not get another
    997                // RXVALID interrupt), processing any errors noted
    998                // along the way.
    999                while ( SCx_REG(port, UARTSTAT) & SC_UARTRXVAL ) {
   1000                  int8u errors = SCx_REG(port, UARTSTAT) & (SC_UARTFRMERR |
   1001                                                 SC_UARTRXOVF  |
   1002                                                 SC_UARTPARERR );
   1003                  int8u incoming = (int8u) SCx_REG(port, DATA);
   1004          
   1005                  if ( (errors == 0) && (q->used < (emSerialRxQueueSizes[port]-1)) ) {
   \                     ??halInternalUartRxIsr_1:
   \   0000001A   0x88B1             LDRH     R1,[R6, #+4]
   \   0000001C   0xF838 0x2015      LDRH     R2,[R8, R5, LSL #+1]
   \   00000020   0x1E52             SUBS     R2,R2,#+1
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xDA1C             BGE.N    ??halInternalUartRxIsr_2
   1006          #ifdef EMBER_SERIAL1_XONXOFF
   1007                    if (EM_SER1_PORT_FIFO(port)) {
   1008                      // Discard any XON or XOFF bytes received
   1009                      if ( (incoming != ASCII_XON) && (incoming != ASCII_XOFF) ) {
   1010                        FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[port]);
   1011                      }
   1012                    } else {
   1013                      FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[port]);
   1014                    }
   1015          #else
   1016                    FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[port]);
   \   00000026   0x8831             LDRH     R1,[R6, #+0]
   \   00000028   0x1989             ADDS     R1,R1,R6
   \   0000002A   0x7188             STRB     R0,[R1, #+6]
   \   0000002C   0x8830             LDRH     R0,[R6, #+0]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0xF839 0x1015      LDRH     R1,[R9, R5, LSL #+1]
   \   00000034   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000038   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   0000003C   0x8030             STRH     R0,[R6, #+0]
   \   0000003E   0x88B0             LDRH     R0,[R6, #+4]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x80B0             STRH     R0,[R6, #+4]
   1017          #endif
   1018                  } else {
   \                     ??halInternalUartRxIsr_0:
   \   00000044   0x68F8             LDR      R0,[R7, #+12]
   \   00000046   0x0780             LSLS     R0,R0,#+30
   \   00000048   0xD516             BPL.N    ??halInternalUartRxIsr_3
   \   0000004A   0x68F8             LDR      R0,[R7, #+12]
   \   0000004C   0xF010 0x0138      ANDS     R1,R0,#0x38
   \   00000050   0x6838             LDR      R0,[R7, #+0]
   \   00000052   0xD0E2             BEQ.N    ??halInternalUartRxIsr_1
   1019                    // Translate error code
   1020                    if ( errors == 0 ) {
   1021                      errors = EMBER_SERIAL_RX_OVERFLOW;
   1022                      HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERFLOW_ERROR);
   1023                    } else if ( errors & SC_UARTRXOVF ) {
   \   00000054   0x0708             LSLS     R0,R1,#+28
   \   00000056   0xD405             BMI.N    ??halInternalUartRxIsr_4
   1024                      errors = EMBER_SERIAL_RX_OVERRUN_ERROR;
   1025                      HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERRUN_ERROR);
   1026                    } else if ( errors & SC_UARTFRMERR ) {
   \   00000058   0x06C8             LSLS     R0,R1,#+27
   \   0000005A   0xD505             BPL.N    ??halInternalUartRxIsr_5
   1027                      errors = EMBER_SERIAL_RX_FRAME_ERROR;
   \   0000005C   0x2124             MOVS     R1,#+36
   \   0000005E   0xE007             B.N      ??halInternalUartRxIsr_6
   1028                      HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_FRAMING_ERROR);
   1029                    } else if ( errors & SC_UARTPARERR ) {
   \                     ??halInternalUartRxIsr_2:
   \   00000060   0x2123             MOVS     R1,#+35
   \   00000062   0xE005             B.N      ??halInternalUartRxIsr_6
   \                     ??halInternalUartRxIsr_4:
   \   00000064   0x2127             MOVS     R1,#+39
   \   00000066   0xE003             B.N      ??halInternalUartRxIsr_6
   \                     ??halInternalUartRxIsr_5:
   \   00000068   0x0688             LSLS     R0,R1,#+26
   \   0000006A   0xBF4C             ITE      MI 
   \   0000006C   0x2125             MOVMI    R1,#+37
   \   0000006E   0x2101             MOVPL    R1,#+1
   1030                      errors = EMBER_SERIAL_RX_PARITY_ERROR;
   1031                    } else { // unknown
   1032                      errors = EMBER_ERR_FATAL;
   1033                    }
   1034                    uartErrorMark(port, errors);
   \                     ??halInternalUartRxIsr_6:
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       uartErrorMark
   \   00000076   0xE7E5             B.N      ??halInternalUartRxIsr_0
   1035                  }
   1036          #ifdef EMBER_SERIAL1_XONXOFF
   1037                  if (EM_SER1_PORT_FIFO(port) &&
   1038                      (q->used >= XOFF_LIMIT) && (xcmdCount >= 0))  {
   1039                    xonXoffTxByte = ASCII_XOFF;
   1040                    halInternalStartUartTx(1);
   1041                  }
   1042          #endif
   1043                } // end of while ( SC1_UARTSTAT & SC1_UARTRXVAL )
   1044              }
   1045            #endif
   1046          
   1047            #if defined(EM_ENABLE_SERIAL_BUFFER)
   1048              if (EM_SER_MULTI(EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port))) {
   1049              #ifdef EMBER_SERIAL1_RTSCTS
   1050                // TODO this flow control will fail if port 2 is active
   1051                // If RTS is controlled by sw, this ISR is called when a buffer unloads.
   1052                if (causes & (INT_SCRXULDA | INT_SCRXULDB)) {
   1053                  // Deassert RTS if the rx queue tail is not in an active DMA buffer:
   1054                  // if it is, then there's at least one empty DMA buffer
   1055                  if ( !( (emSerialRxQueues[port]->tail < emSerialRxQueueSizes[port]/2) &&
   1056                         (SCx_REG(port, DMASTAT) & SC_RXACTA) ) &&
   1057                       !( (emSerialRxQueues[port]->tail >= emSerialRxQueueSizes[port]/2)
   1058                          && (SCx_REG(port, DMASTAT) & SC_RXACTB) ) ) {
   1059                    SCx_REG(port, UARTCFG) &= ~SC_UARTRTS;        // deassert RTS
   1060                  }
   1061                #ifdef EZSP_UART
   1062                  // TODO fix EZSP_UART
   1063                  if ( ( (causes & INT_SCRXULDA) && (SC1_DMASTAT & SC_RXOVFA) ) ||
   1064                       ( (causes & INT_SCRXULDB) && (SC1_DMASTAT & SC_RXOVFB) ) ) {
   1065                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERFLOW_ERROR);
   1066                  }
   1067                  if ( ( (causes & INT_SCRXULDA) && (SC1_DMASTAT & SC_RXFRMA) ) ||
   1068                       ( (causes & INT_SCRXULDB) && (SC1_DMASTAT & SC_RXFRMB) ) ) {
   1069                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_FRAMING_ERROR);
   1070                  }
   1071                #else//!EZSP_UART
   1072                  causes &= ~(INT_SCRXULDA | INT_SCRXULDB);
   1073                  if (causes == 0) { // if no errors in addition, all done
   1074                    return;
   1075                  }
   1076                #endif//EZSP_UART
   1077                }
   1078              #endif  //#ifdef EMBER_SERIAL1_RTSCTS
   1079              #ifndef EZSP_UART
   1080              //Load all of the hardware status, then immediately reset so we can process
   1081              //what happened without worrying about new data changing these values.
   1082              //We're in an error condition anyways, so it is ok to have the DMA disabled
   1083              //for a while (less than 80us, while 4 bytes @ 115.2kbps is 350us)
   1084              {
   1085                EmSerialFifoQueue *q = emSerialRxQueues[port];
   1086                int16u status  = SCx_REG(port, DMASTAT);
   1087                int16u errCntA = SCx_REG(port, RXERRA);
   1088                int16u errCntB = SCx_REG(port, RXERRB);
   1089                int32u errorIdx = emSerialRxQueueSizes[port]*2;
   1090                int32u tempIdx;
   1091                int32u startAddress = (int32u)q->fifo;
   1092          
   1093                //interrupts acknowledged at the start of the master SC1 ISR
   1094                int16u intSrc  = causes;
   1095                int8u errorType = EMBER_SUCCESS;
   1096          
   1097                SCx_REG(port, DMACTRL) = SC_RXDMARST;  //to clear error
   1098                //state fully captured, DMA reset, now we process error and restart
   1099          
   1100                if ( intSrc & INT_SCRXOVF ) {
   1101                  //Read the data register four times to clear
   1102                  //the RXOVERRUN condition and empty the FIFO, giving us 4 bytes
   1103                  //worth of time (from this point) to reenable the DMA.
   1104                  (void) SCx_REG(port, DATA);
   1105                  (void) SCx_REG(port, DATA);
   1106                  (void) SCx_REG(port, DATA);
   1107                  (void) SCx_REG(port, DATA);
   1108          
   1109                  if ( status & ( SC_RXFRMA
   1110                               | SC_RXFRMB
   1111                               | SC_RXPARA
   1112                               | SC_RXPARB ) ) {
   1113                    //We just emptied hardware FIFO so the overrun condition is cleared.
   1114                    //Byte errors require special handling to roll back the serial FIFO.
   1115                    goto dealWithByteError;
   1116                  }
   1117          
   1118                //record the error type
   1119                emSerialRxError[port] = EMBER_SERIAL_RX_OVERRUN_ERROR;
   1120          
   1121                //check for a retriggering of the Rx overflow, don't advance FIFO if so
   1122                if ( !(BUFSTATE(port)->waitingForTailA && BUFSTATE(port)->waitingForTailB) ) {
   1123                  //first, move head to end of buffer head is in
   1124                  //second, move head to end of other buffer if tail is not in other buffer
   1125                  if ((q->head)<BUFSTATE(port)->rxStartIndexB) {
   1126                    //head inside A
   1127                    q->used += (BUFSTATE(port)->rxStartIndexB - q->head);
   1128                    q->head = (BUFSTATE(port)->rxStartIndexB);
   1129                    if ((q->tail)<BUFSTATE(port)->rxStartIndexB) {
   1130                      //tail not inside of B
   1131                      q->used += BUFSTATE(port)->rxStartIndexB;
   1132                      q->head = 0;
   1133                    }
   1134                  } else {
   1135                    //head inside B
   1136                    q->used += (BUFSTATE(port)->fifoSize - q->head);
   1137                    q->head = 0;
   1138                    if ((q->tail)>=BUFSTATE(port)->rxStartIndexB) {
   1139                      //tail is not inside of A
   1140                      q->used += BUFSTATE(port)->rxStartIndexB;
   1141                      q->head = BUFSTATE(port)->rxStartIndexB;
   1142                    }
   1143                  }
   1144                }
   1145          
   1146                //Record the error position in the serial FIFO
   1147                if (q->used != BUFSTATE(port)->fifoSize) {
   1148                  //mark the byte at q->head as the error
   1149                  emSerialRxErrorIndex[port] = q->head;
   1150                } else {
   1151                  //Since the FIFO is full, the error index needs special handling
   1152                  //so there is no conflict between the head and tail looking at the same
   1153                  //index which needs to be marked as an error.
   1154                  emSerialRxErrorIndex[port] = RX_FIFO_FULL;
   1155                }
   1156          
   1157                //By now the error is accounted for and the DMA hardware is reset.
   1158                //By definition, the overrun error means we have no room left, therefore
   1159                //we can't reenable the DMA.  Reset the previous counter states, and set
   1160                //the waitingForTail flags to TRUE - this tells the Pump function we have
   1161                //data to process.  The Pump function will reenable the buffers as they
   1162                //become available, just like normal.
   1163                BUFSTATE(port)->prevCountA = 0;
   1164                BUFSTATE(port)->prevCountB = 0;
   1165                BUFSTATE(port)->waitingForInputToB = FALSE;
   1166                BUFSTATE(port)->waitingForTailA = TRUE;
   1167                BUFSTATE(port)->waitingForTailB = TRUE;
   1168                //from this point we fall through to the end of the Isr and return.
   1169          
   1170                } else {
   1171                dealWithByteError:
   1172                  //We have a byte error to deal with and possibly more than one byte error,
   1173                  //of different types in different DMA buffers, so check each error flag.
   1174                  //All four error checks translate the DMA buffer's error position to their
   1175                  //position in the serial FIFO, and compares the error locations to find
   1176                  //the first error to occur after the head of the FIFO.  This error is the
   1177                  //error condition that is stored and operated on.
   1178                  if ( status & SC_RXFRMA ) {
   1179                    tempIdx = errCntA;
   1180                    if (tempIdx < q->head) {
   1181                      tempIdx += BUFSTATE(port)->fifoSize;
   1182                    }
   1183                    if (tempIdx<errorIdx) {
   1184                      errorIdx = tempIdx;
   1185                    }
   1186                    errorType = EMBER_SERIAL_RX_FRAME_ERROR;
   1187                  }
   1188                  if ( status & SC_RXFRMB ) {
   1189                    tempIdx = (errCntB + SCx_REG(port, RXBEGB)) - startAddress;
   1190                    if (tempIdx < q->head) {
   1191                      tempIdx += BUFSTATE(port)->fifoSize;
   1192                    }
   1193                    if (tempIdx<errorIdx) {
   1194                      errorIdx = tempIdx;
   1195                    }
   1196                    errorType = EMBER_SERIAL_RX_FRAME_ERROR;
   1197                  }
   1198                  if ( status & SC_RXPARA ) {
   1199                    tempIdx = errCntA;
   1200                    if (tempIdx < q->head) {
   1201                      tempIdx += BUFSTATE(port)->fifoSize;
   1202                    }
   1203                    if (tempIdx<errorIdx) {
   1204                      errorIdx = tempIdx;
   1205                    }
   1206                    errorType = EMBER_SERIAL_RX_PARITY_ERROR;
   1207                  }
   1208                  if ( status & SC_RXPARB ) {
   1209                    tempIdx = (errCntB + SCx_REG(port, RXBEGB)) - startAddress;
   1210                    if (tempIdx < q->head) {
   1211                      tempIdx += BUFSTATE(port)->fifoSize;
   1212                    }
   1213                    if (tempIdx<errorIdx) {
   1214                      errorIdx = tempIdx;
   1215                    }
   1216                    errorType = EMBER_SERIAL_RX_PARITY_ERROR;
   1217                  }
   1218          
   1219                  //We now know the type and location of the first error.
   1220                  //Move up to the error location and increase the used count.
   1221                  q->head = (errorIdx % BUFSTATE(port)->fifoSize);
   1222                  if (q->head < q->tail) {
   1223                    q->used = ((q->head + BUFSTATE(port)->fifoSize) - q->tail);
   1224                  } else {
   1225                    q->used = (q->head - q->tail);
   1226                  }
   1227          
   1228                  //Mark the byte at q->head as the error
   1229                  emSerialRxError[port] = errorType;
   1230                  if (q->used != BUFSTATE(port)->fifoSize) {
   1231                    //mark the byte at q->head as the error
   1232                    emSerialRxErrorIndex[port] = q->head;
   1233                  } else {
   1234                    //Since the FIFO is full, the error index needs special handling
   1235                    //so there is no conflict between the head and tail looking at the same
   1236                    //index which needs to be marked as an error.
   1237                    emSerialRxErrorIndex[port] = RX_FIFO_FULL;
   1238                  }
   1239          
   1240                  //By now the error is accounted for and the DMA hardware is reset.
   1241                  halInternalRestartUartDma(port);
   1242                }
   1243              }
   1244              #endif // #ifndef EZSP_UART
   1245              }
   1246            #endif //(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1247          }
   \                     ??halInternalUartRxIsr_3:
   \   00000078   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1248          #endif//!defined(EM_SERIAL1_DISABLED)
   1249          
   1250          
   1251          #if EM_SERIAL3_ENABLED
   1252            void halInternalUart3RxIsr(int8u *rxData, int8u length)
   1253            {
   1254              EmSerialFifoQueue *q = emSerialRxQueues[3];
   1255          
   1256              while(length--) {
   1257                if(q->used < (EMBER_SERIAL3_RX_QUEUE_SIZE-1)) {
   1258                  FIFO_ENQUEUE(q, *rxData, emSerialRxQueueWraps[3]);
   1259                  rxData++;
   1260                } else {
   1261                  uartErrorMark(3, EMBER_SERIAL_RX_OVERFLOW);
   1262                  return;
   1263                }
   1264              }
   1265            }
   1266          #endif
   1267          
   1268          
   1269          #ifdef SOFTUART
   1270          //this requires use of the SysTick counter and will destroy interrupt latency!
   1271          static int8u softwareUartRxByte(void)
   1272          {
   1273            int8u i;
   1274            int8u bit;
   1275            int8u byte = 0;
   1276            // BIT_TIMEs were determined based on 24 MHz MCU clock.
   1277            // Scale 'em for the actual MCU clock in effect, with rounding.
   1278            // (Because the FCLK might not evenly divide by 1000 or even 500, use quad
   1279            // arithmetic dividing it by 250.)
   1280            int16u fullBitTime  = (int16u)((( FULL_BIT_TIME_SCLK
   1281                                                * (halMcuClockKHz() / 250)) + 48) / 96);
   1282            int16u startBitTime = (int16u)(((START_BIT_TIME_SCLK
   1283                                                * (halMcuClockKHz() / 250)) + 48) / 96);
   1284            ATOMIC(
   1285              INTERRUPTS_ON();
   1286              //we can only begin receiveing if the input is idle high
   1287              while (SOFT_UART_RX_BIT != 1) {}
   1288              //now wait for our start bit
   1289              while (SOFT_UART_RX_BIT != 0) {}
   1290              INTERRUPTS_OFF();
   1291          
   1292              //set reload value such that move to the center of an incoming bit
   1293              ST_RVR = startBitTime;
   1294              ST_CVR = 0; //writing the current value will cause it to reset to zero
   1295              //enable core clock reference and the counter itself
   1296              ST_CSR = (ST_CSR_CLKSOURCE | ST_CSR_ENABLE);
   1297              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 0.5bit time
   1298              //set reload value such that move 1bit time
   1299              ST_RVR = fullBitTime;
   1300              ST_CVR = 0; //writing the current value will cause it to reset to zero
   1301          
   1302              //loop 8 times recieving all 8 bits and building up the byte
   1303              for (i=0;i<8;i++) {
   1304                while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
   1305                bit = SOFT_UART_RX_BIT; //get the data bit
   1306                bit = ((bit&0x1)<<7);
   1307                byte = (byte>>1)|(bit);
   1308              }
   1309          
   1310              //disable SysTick
   1311              ST_CSR = 0;
   1312            )
   1313            return byte;
   1314          }
   1315          #endif //SOFTUART
   1316          

   \                                 In section .text, align 2, keep-with-next
   1317          void halInternalUartRxPump(int8u port)
   1318          {
   1319            #ifdef SOFTUART
   1320              if (EM_SER1_PORT_EN(port)) {
   1321                EmSerialFifoQueue *q = emSerialRxQueues[1];
   1322                int8u errors;
   1323                int8u byte;
   1324          
   1325                //always configure the bit because other operations might have
   1326                //tried to compromise it
   1327                CONFIG_SOFT_UART_RX_BIT();
   1328          
   1329                //this will block waiting for a start bit!
   1330                byte = softwareUartRxByte();
   1331          
   1332                if (q->used < (EMBER_SERIAL1_RX_QUEUE_SIZE-1)) {
   1333                    FIFO_ENQUEUE(q, byte, emSerialRxQueueWraps[1]);
   1334                } else {
   1335                  errors = EMBER_SERIAL_RX_OVERFLOW;
   1336                  uartErrorMark(1, errors);
   1337                }
   1338                return;
   1339              }
   1340            #endif
   1341          
   1342            #ifdef EM_ENABLE_SERIAL_BUFFER
   1343              if (EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) {
   1344                EmSerialFifoQueue *q = emSerialRxQueues[port];
   1345                int8u tail,head;
   1346                int16u count=0;
   1347                int8u loadA;
   1348                int8u loadB;
   1349                //Load all of the hardware status, so we can process what happened
   1350                //without worrying about new data changing these values.
   1351                int8u dmaStatus = SCx_REG(port, DMACTRL);
   1352                int16u currCountA = SCx_REG(port, RXCNTA);
   1353                int16u currCountB = SCx_REG(port, RXCNTB);
   1354          
   1355                //Normal check to see if A has any data
   1356                if (BUFSTATE(port)->prevCountA != currCountA) {
   1357                  //Update the counters and head location for the new data
   1358                  count = (currCountA - BUFSTATE(port)->prevCountA);
   1359                  q->used += count;
   1360                  q->head = (q->head + count) % emSerialRxQueueSizes[port];
   1361                  BUFSTATE(port)->prevCountA = currCountA;
   1362                  BUFSTATE(port)->waitingForTailA = TRUE;
   1363                }
   1364                //Normal check to see if B has any data at all
   1365                if (BUFSTATE(port)->prevCountB != currCountB) {
   1366                  //Update the counters and head location for the new data
   1367                  count = (currCountB - BUFSTATE(port)->prevCountB);
   1368                  q->used += count;
   1369                  q->head = (q->head + count) % emSerialRxQueueSizes[port];
   1370                  BUFSTATE(port)->prevCountB = currCountB;
   1371                  BUFSTATE(port)->waitingForTailB = TRUE;
   1372                  BUFSTATE(port)->waitingForInputToB = FALSE;
   1373                }
   1374          
   1375          
   1376                //if the used count is greater than half the buffer size, nothing can be done
   1377                if (q->used > BUFSTATE(port)->rxStartIndexB) {
   1378                  return;
   1379                }
   1380                //if nothing is in the FIFO, we can reload both if needed
   1381                if (q->used == 0) {
   1382                  loadA = TRUE;
   1383                  loadB = TRUE;
   1384                  goto reloadBuffers;
   1385                }
   1386                //0 < used < bufferSize, so figure out where tail and head are
   1387                if((q->tail)/(BUFSTATE(port)->rxStartIndexB)) {
   1388                  tail = TRUE;  //Tail in B buffer
   1389                } else {
   1390                  tail = FALSE; //Tail in A buffer
   1391                }
   1392          
   1393                if(((int16u)(q->head - 1))/(BUFSTATE(port)->rxStartIndexB)) {
   1394                  head = TRUE;  //Head in B buffer
   1395                } else {
   1396                  head = FALSE; //Head in A buffer
   1397                }
   1398          
   1399                //To load, the tail must be in the same buffer as the head so we don't
   1400                //overwrite any bytes that haven't drained from the serial FIFO yet.
   1401                if (tail!=head) {
   1402                  halInternalUartRxCheckRts(port);
   1403                  return;
   1404                }
   1405                // Recall tail TRUE means data is inside B
   1406                loadA = tail;
   1407                loadB = !tail;
   1408            reloadBuffers:
   1409                //check if the buffers need to be reloaded
   1410                if ( (loadA) && (!BUFSTATE(port)->waitingForInputToB) ) {
   1411                  if ( (dmaStatus&SC_RXLODA)
   1412                      != SC_RXLODA) {
   1413                    //An error interrupt can move the addresses of the buffer
   1414                    //during the flush/reset/reload operation.  At this point the
   1415                    //buffer is clear of any usage, so we can reset the addresses
   1416                    SCx_REG(port, RXBEGA) = (int32u)q->fifo;
   1417                    SCx_REG(port, RXENDA) = (int32u)(q->fifo + BUFSTATE(port)->fifoSize/2 - 1);
   1418                    BUFSTATE(port)->prevCountA = 0;
   1419                    BUFSTATE(port)->waitingForTailA = FALSE;
   1420                    SCx_REG(port, DMACTRL) = SC_RXLODA;
   1421                  }
   1422                }
   1423                if (loadB) {
   1424                  if ( (dmaStatus&SC_RXLODB)
   1425                      != SC_RXLODB) {
   1426                    //An error interrupt can move the addresses of the buffer
   1427                    //during the flush/reset/reload operation.  At this point the
   1428                    //buffer is clear of any usage, so we can reset the addresses
   1429                    SCx_REG(port, RXBEGB) = (int32u)(q->fifo + BUFSTATE(port)->fifoSize/2);
   1430                    SCx_REG(port, RXENDB) = (int32u)(q->fifo + BUFSTATE(port)->fifoSize - 1);
   1431                    BUFSTATE(port)->prevCountB = 0;
   1432                    BUFSTATE(port)->waitingForTailB = FALSE;
   1433                    SCx_REG(port, DMACTRL) = SC_RXLODB;
   1434                  }
   1435                }
   1436                halInternalUartRxCheckRts(port);
   1437              }
   1438            #endif // EM_ENABLE_SERIAL_BUFFER
   1439          }
   \                     halInternalUartRxPump:
   \   00000000   0x4770             BX       LR               ;; return
   1440          
   1441          #if defined(EMBER_SERIAL1_RTSCTS) || defined(EMBER_SERIAL2_RTSCTS)
   1442          void halInternalUartRxCheckRts(int8u port)
   1443          {
   1444            // Verify RTS is controlled by SW (not AUTO mode), and isn't already asserted.
   1445            // (The logic to deassert RTS is in halInternalUart1RxIsr().)
   1446            if ((SCx_REG(port, UARTCFG) & (SC_UARTFLOW | SC_UARTAUTO | SC_UARTRTS)) == SC_UARTFLOW) {
   1447              // Assert RTS if the rx queue tail is in an active (or pending) DMA buffer,
   1448              // because this means the other DMA buffer is empty.
   1449              ATOMIC (
   1450                if ( ( (emSerialRxQueues[port]->tail < emSerialRxQueueSizes[port]/2) &&
   1451                       (SCx_REG(port, DMACTRL) & SC_RXLODA) ) ||
   1452                     ( (emSerialRxQueues[port]->tail >= emSerialRxQueueSizes[port]/2)
   1453                        && (SCx_REG(port, DMACTRL) & SC_RXLODB) ) ) {
   1454                    SCx_REG(port, UARTCFG) |= SC_UARTRTS;          // assert RTS
   1455                }
   1456              )
   1457            }
   1458          }
   1459          #endif
   1460          
   1461          #ifdef EMBER_SERIAL1_RTSCTS
   1462          boolean halInternalUartFlowControlRxIsEnabled(int8u port)
   1463          {
   1464            return ( (SCx_REG(port, UARTCFG) & (SC_UARTFLOW | SC_UARTAUTO | SC_UARTRTS)) ==
   1465                     (SC_UARTFLOW | SC_UARTRTS) );
   1466          }
   1467          #endif
   1468          #ifdef EMBER_SERIAL1_XONXOFF
   1469          boolean halInternalUartFlowControlRxIsEnabled(int8u port)
   1470          {
   1471            xonTimer = halCommonGetInt16uQuarterSecondTick(); //FIXME move into new func?
   1472            return ( (xonXoffTxByte == 0) && (xcmdCount > 0) );
   1473          }
   1474          
   1475          boolean halInternalUartXonRefreshDone(int8u port)
   1476          {
   1477            return (xcmdCount == XON_REFRESH_COUNT);
   1478          }
   1479          #endif
   1480          

   \                                 In section .text, align 2, keep-with-next
   1481          boolean halInternalUartTxIsIdle(int8u port)
   1482          {
   1483            // TODO how do we determine idle for the VUART or USB?
   1484            #if defined(EM_PHYSICAL_UART)
   1485              if (EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) {
   \                     halInternalUartTxIsIdle:
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD10A             BNE.N    ??halInternalUartTxIsIdle_0
   1486                return ( (SCx_REG(port, MODE) == SC1_MODE_UART) &&
   1487                         ((SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE) != 0) );
   \   00000004   0x....             LDR.N    R0,??DataTable15_9  ;; 0x4000c848
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD104             BNE.N    ??halInternalUartTxIsIdle_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0980             LSRS     R0,R0,#+6
   \   00000010   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000014   0x4770             BX       LR
   \                     ??halInternalUartTxIsIdle_1:
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR
   1488              }
   1489            #endif
   1490          
   1491            return TRUE;
   \                     ??halInternalUartTxIsIdle_0:
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR               ;; return
   1492          }
   1493          
   1494          #if defined(EM_PHYSICAL_UART)
   1495          // If called outside of an ISR, it should be from within an ATOMIC block.

   \                                 In section .text, align 2, keep-with-next
   1496          static void halInternalUartTxIsr(int8u port)
   1497          {
   \                     halInternalUartTxIsr:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1498            #if defined(EM_ENABLE_SERIAL_FIFO)
   1499              if (EM_SER_MULTI(EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port))) {
   1500                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000002   0x....             LDR.N    R1,??DataTable15_3
   \   00000004   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000008   0x....             LDR.N    R2,??DataTable15_11
   \   0000000A   0x....             LDR.N    R3,??DataTable15_5  ;; 0x4000c83c
   \   0000000C   0xE00F             B.N      ??halInternalUartTxIsr_0
   1501          
   1502                // At present we really don't care which interrupt(s)
   1503                // occurred, just that one did.  Loop while there is
   1504                // room to send more data and we've got more data to
   1505                // send.  For UART there is no error detection.
   1506          
   1507          #ifdef EMBER_SERIAL1_XONXOFF
   1508                // Sending an XON or XOFF takes priority over data in the tx queue.
   1509                if (xonXoffTxByte && (SCx_REG(port, UARTSTAT) & SC_UARTTXFREE) ) {
   1510                  SCx_REG(port, DATA) = xonXoffTxByte;
   1511                  if (xonXoffTxByte == ASCII_XOFF) {
   1512                    xcmdCount = -1;
   1513                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_XOFF);
   1514                  } else {
   1515                    xcmdCount = (xcmdCount < 0) ? 1: xcmdCount + 1;
   1516                  }
   1517                  xonXoffTxByte = 0;    // clear to indicate XON/XOFF was sent
   1518                }
   1519          #endif
   1520                while ( (q->used > 0) && (SCx_REG(port, UARTSTAT) & SC_UARTTXFREE) ) {
   1521                  SCx_REG(port, DATA) = FIFO_DEQUEUE(q, emSerialTxQueueWraps[port]);
   \                     ??halInternalUartTxIsr_1:
   \   0000000E   0x884C             LDRH     R4,[R1, #+2]
   \   00000010   0x1864             ADDS     R4,R4,R1
   \   00000012   0x79A4             LDRB     R4,[R4, #+6]
   \   00000014   0x601C             STR      R4,[R3, #+0]
   \   00000016   0x884C             LDRH     R4,[R1, #+2]
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \   0000001A   0xF832 0x5010      LDRH     R5,[R2, R0, LSL #+1]
   \   0000001E   0xFB94 0xF6F5      SDIV     R6,R4,R5
   \   00000022   0xFB05 0x4416      MLS      R4,R5,R6,R4
   \   00000026   0x804C             STRH     R4,[R1, #+2]
   \   00000028   0x888C             LDRH     R4,[R1, #+4]
   \   0000002A   0x1E64             SUBS     R4,R4,#+1
   \   0000002C   0x808C             STRH     R4,[R1, #+4]
   1522                }
   \                     ??halInternalUartTxIsr_0:
   \   0000002E   0x888C             LDRH     R4,[R1, #+4]
   \   00000030   0xB114             CBZ.N    R4,??halInternalUartTxIsr_2
   \   00000032   0x68DC             LDR      R4,[R3, #+12]
   \   00000034   0x0764             LSLS     R4,R4,#+29
   \   00000036   0xD4EA             BMI.N    ??halInternalUartTxIsr_1
   1523              }
   1524            #endif
   1525            #if defined(EM_ENABLE_SERIAL_BUFFER)
   1526              if (EM_SER_MULTI(EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port))) {
   1527                EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1528          
   1529                // The only interrupts we care about here are UNLOAD's and IDLE.
   1530                // Our algorithm doesn't really care which interrupt occurred,
   1531                // or even if one really didn't.  If there is data to send and
   1532                // a DMA channel available to send it, then out it goes.
   1533          
   1534                assert( !((q->used == 0) && (q->nextByte != NULL)) );
   1535                while ( q->used > 0 ) {
   1536                  if ( q->nextByte == NULL ) {
   1537                    // new message pending, but nextByte not set up yet
   1538                    emSerialBufferNextMessageIsr(q);
   1539                  }
   1540          
   1541                  // Something to send: do we have a DMA channel to send it on?
   1542                  // Probe for an available channel by checking the channel's
   1543                  // SC1_DMACTRL.TX_LOAD   == 0 (channel unloaded) &&
   1544                  // SC1_DMASTAT.TX_ACTIVE == 0 (channel not active)
   1545                  // The latter check should be superfluous but is a safety mechanism.
   1546                  if ( !(SCx_REG(port, DMACTRL) & SC_TXLODA) &&
   1547                       !(SCx_REG(port, DMASTAT) & SC_TXACTA) ) {
   1548                    // Channel A is available
   1549                    SCx_REG(port, TXBEGA)  = (int32u)q->nextByte;
   1550                    SCx_REG(port, TXENDA) = (int32u)q->lastByte;
   1551                    INT_SCxFLAG(port) = INT_SCTXULDA; // Ack if pending
   1552                    SCx_REG(port, DMACTRL) = SC_TXLODA;
   1553                    // Release previously held buffer and hold the newly-loaded one
   1554                    // so we can safely use emSerialBufferNextBlockIsr() to check for
   1555                    // more data to send without the risk of reusing a buffer we're
   1556                    // in the process of DMA-ing.
   1557                    if (BUFSTATE(port)->holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER)
   1558                      emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[0]);
   1559                    BUFSTATE(port)->holdBuf[0] = q->currentBuffer;
   1560                    emberHoldMessageBuffer(BUFSTATE(port)->holdBuf[0]);
   1561                    emSerialBufferNextBlockIsr(q, port);
   1562                  } else
   1563                  if ( !(SCx_REG(port, DMACTRL) & SC_TXLODB) &&
   1564                       !(SCx_REG(port, DMASTAT) & SC_TXACTB) ) {
   1565                    // Channel B is available
   1566                    SCx_REG(port, TXBEGB)  = (int32u)q->nextByte;
   1567                    SCx_REG(port, TXENDB) = (int32u)q->lastByte;
   1568                    INT_SCxFLAG(port) = INT_SCTXULDB; // Ack if pending
   1569                    SCx_REG(port, DMACTRL) = SC_TXLODB;
   1570                    // Release previously held buffer and hold the newly-loaded one
   1571                    // so we can safely use emSerialBufferNextBlockIsr() to check for
   1572                    // more data to send without the risk of reusing a buffer we're
   1573                    // in the process of DMA-ing.
   1574                    if (BUFSTATE(port)->holdBuf[1] != EMBER_NULL_MESSAGE_BUFFER)
   1575                      emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[1]);
   1576                    BUFSTATE(port)->holdBuf[1] = q->currentBuffer;
   1577                    emberHoldMessageBuffer(BUFSTATE(port)->holdBuf[1]);
   1578                    emSerialBufferNextBlockIsr(q, port);
   1579                  } else {
   1580                    // No channels available; can't send anything now so break out of loop
   1581                    break;
   1582                  }
   1583          
   1584                } // while ( q->used > 0 )
   1585          
   1586                // Release previously-held buffer(s) from an earlier DMA operation
   1587                // if that channel is now free (i.e. it's completed the DMA and we
   1588                // didn't need to use that channel for more output in this call).
   1589                if ( (BUFSTATE(port)->holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER) &&
   1590                     !(SCx_REG(port, DMACTRL) & SC_TXLODA) &&
   1591                     !(SCx_REG(port, DMASTAT) & SC_TXACTA) ) {
   1592                  emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[0]);
   1593                  BUFSTATE(port)->holdBuf[0] = EMBER_NULL_MESSAGE_BUFFER;
   1594                }
   1595                if ( (BUFSTATE(port)->holdBuf[1] != EMBER_NULL_MESSAGE_BUFFER) &&
   1596                     !(SCx_REG(port, DMACTRL) & SC_TXLODB) &&
   1597                     !(SCx_REG(port, DMASTAT) & SC_TXACTB) ) {
   1598                  emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[1]);
   1599                  BUFSTATE(port)->holdBuf[1] = EMBER_NULL_MESSAGE_BUFFER;
   1600                }
   1601              }
   1602            #endif
   1603          }
   \                     ??halInternalUartTxIsr_2:
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   1604          #endif // defined(EM_PHYSICAL_UART)
   1605          
   1606          
   1607          #if EM_SERIAL1_ENABLED
   1608            //The following registers are the only SC1-UART registers that need to be
   1609            //saved across deep sleep cycles.  All other SC1-UART registers are
   1610            //reenabled or restarted using more complex init or restart algorithms.

   \                                 In section .bss, align 4
   1611            static int32u  SC1_UARTPER_SAVED;
   \                     SC1_UARTPER_SAVED:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   1612            static int32u  SC1_UARTFRAC_SAVED;
   1613            static int32u  SC1_UARTCFG_SAVED;
   1614          #endif // EM_SERIAL1_ENABLED
   1615          #if EM_SERIAL2_ENABLED
   1616            //The following registers are the only SC3-UART registers that need to be
   1617            //saved across deep sleep cycles.  All other SC3-UART registers are
   1618            //reenabled or restarted using more complex init or restart algorithms.
   1619            static int32u  SC3_UARTPER_SAVED;
   1620            static int32u  SC3_UARTFRAC_SAVED;
   1621            static int32u  SC3_UARTCFG_SAVED;
   1622          #endif // EM_SERIAL2_ENABLED
   1623          

   \                                 In section .text, align 2, keep-with-next
   1624          void halInternalPowerDownUart(void)
   1625          {
   1626            #if EM_SERIAL1_ENABLED
   1627              SC1_UARTPER_SAVED = SC1_UARTPER;
   \                     halInternalPowerDownUart:
   \   00000000   0x....             LDR.N    R0,??DataTable15_12  ;; 0x4000c85c
   \   00000002   0x....             LDR.N    R1,??DataTable15_13
   \   00000004   0x68C2             LDR      R2,[R0, #+12]
   \   00000006   0x600A             STR      R2,[R1, #+0]
   1628              SC1_UARTFRAC_SAVED = SC1_UARTFRAC;
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   1629              SC1_UARTCFG_SAVED = SC1_UARTCFG;
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6088             STR      R0,[R1, #+8]
   1630              SC1_TXD_GPIO(GPIOCFG_OUT, 1); // Avoid gitching TxD going down
   1631            #endif // EM_SERIAL1_ENABLED
   1632            #if EM_SERIAL2_ENABLED
   1633              SC3_UARTPER_SAVED = SC3_UARTPER;
   1634              SC3_UARTFRAC_SAVED = SC3_UARTFRAC;
   1635              SC3_UARTCFG_SAVED = SC3_UARTCFG;
   1636              // TODO SC3_TXD_GPIO(GPIOCFG_OUT, 1); // Avoid gitching TxD going down
   1637            #endif // EM_SERIAL1_ENABLED
   1638          }
   \   00000010   0x4770             BX       LR               ;; return
   1639          

   \                                 In section .text, align 2, keep-with-next
   1640          void halInternalPowerUpUart(void)
   1641          {
   1642            #if EM_SERIAL1_ENABLED
   1643              SC1_UARTPER = SC1_UARTPER_SAVED;
   \                     halInternalPowerUpUart:
   \   00000000   0x....             LDR.N    R0,??DataTable15  ;; 0x4000c854
   \   00000002   0x....             LDR.N    R1,??DataTable15_13
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x6142             STR      R2,[R0, #+20]
   1644              SC1_UARTFRAC = SC1_UARTFRAC_SAVED;
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x6182             STR      R2,[R0, #+24]
   1645              SC1_UARTCFG = SC1_UARTCFG_SAVED;
   \   0000000C   0x6889             LDR      R1,[R1, #+8]
   \   0000000E   0x6081             STR      R1,[R0, #+8]
   1646          
   1647              SC1_MODE = SC1_MODE_UART;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x6001             STR      R1,[R0, #+0]
   1648              SC1_TXD_GPIO(GPIOCFG_OUT_ALT, 1); // Can Assign TxD glitch-free to UART now
   1649          
   1650              halInternalInitUartInterrupts(1);
   \   00000014   0x....             LDR.N    R0,??DataTable15_1  ;; 0x4000a808
   \   00000016   0x6C01             LDR      R1,[R0, #+64]
   \   00000018   0xF441 0x41C0      ORR      R1,R1,#0x6000
   \   0000001C   0xF041 0x0109      ORR      R1,R1,#0x9
   \   00000020   0x6401             STR      R1,[R0, #+64]
   \   00000022   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000026   0x6001             STR      R1,[R0, #+0]
   \   00000028   0x....             LDR.N    R0,??DataTable15_2  ;; 0xe000e100
   \   0000002A   0x2120             MOVS     R1,#+32
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   1651            #endif
   1652          
   1653            #if EM_SERIAL2_ENABLED
   1654              SC3_UARTPER = SC3_UARTPER_SAVED;
   1655              SC3_UARTFRAC = SC3_UARTFRAC_SAVED;
   1656              SC3_UARTCFG = SC3_UARTCFG_SAVED;
   1657          
   1658              SC3_MODE = SC3_MODE_UART;
   1659              //SC3_TXD_GPIO(GPIOCFG_OUT_ALT, 1); // Can Assign TxD glitch-free to UART now
   1660          
   1661              halInternalInitUartInterrupts(2);
   1662            #endif
   1663          
   1664            #if EM_SERIAL3_ENABLED
   1665              //Remember, halInternalPowerUpUart does not return anything.  Powering
   1666              //up the USB requires going through its normal configuration and
   1667              //enumeration process.
   1668              #if defined(CORTEXM3_EM35X_USB)
   1669                USBD_Init(&initstruct);
   1670              #endif
   1671            #endif
   1672          }
   \   0000002E   0x4770             BX       LR               ;; return
   1673          
   1674          

   \                                 In section .text, align 2, keep-with-next
   1675          void halInternalRestartUart(void)
   1676          {
   1677            // This is no longer needed and should be removed as a dinosaur --DMM
   1678          }
   \                     halInternalRestartUart:
   \   00000000   0x4770             BX       LR               ;; return
   1679          
   1680          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO) && defined(EMBER_SERIAL1_XONXOFF)
   1681          // TODO XON/XOFF on port 2
   1682          void halInternalUartFlowControl(int8u port)
   1683          {
   1684            if (EM_SER1_PORT_EN(port)) {
   1685              int16u used = emSerialRxQueues[1]->used;
   1686              int8u time = halCommonGetInt16uQuarterSecondTick();
   1687          
   1688              if (used) {
   1689                xonTimer = time;
   1690              }
   1691              // Send an XON if the rx queue is below the XON threshold
   1692              // and an XOFF had been sent that needs to be reversed
   1693              ATOMIC(
   1694                if ( (xcmdCount == -1) && (used <= XON_LIMIT) ) {
   1695                  halInternalUart1ForceXon();
   1696                } else if ( (used == 0) &&
   1697                            ((int8u)(time - xonTimer) >= XON_REFRESH_TIME) &&
   1698                            (xcmdCount < XON_REFRESH_COUNT) ) {
   1699                  halInternalUart1ForceXon();
   1700                }
   1701              )
   1702            }
   1703          }
   1704          #endif
   1705          
   1706          #ifdef EMBER_SERIAL1_XONXOFF
   1707          // Must be called from within an ATOMIC block.
   1708          static void halInternalUart1ForceXon(void)
   1709          {
   1710            if (xonXoffTxByte == ASCII_XOFF) {  // if XOFF waiting to be sent, cancel it
   1711              xonXoffTxByte = 0;
   1712              xcmdCount = 0;
   1713            } else {                            // else, send XON and record the time
   1714              xonXoffTxByte = ASCII_XON;
   1715              halInternalStartUartTx(1);
   1716            }
   1717            xonTimer = halCommonGetInt16uQuarterSecondTick();
   1718          }
   1719          #endif
   1720          
   1721          #if EM_SERIAL1_ENABLED

   \                                 In section .text, align 2, keep-with-next
   1722          void halSc1Isr(void)
   1723          {
   \                     halSc1Isr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1724            int32u interrupt;
   1725          
   1726            //this read and mask is performed in two steps otherwise the compiler
   1727            //will complain about undefined order of volatile access
   1728            interrupt = INT_SC1FLAG;
   \   00000002   0x....             LDR.N    R4,??DataTable15_1  ;; 0x4000a808
   \   00000004   0xE00F             B.N      ??halSc1Isr_0
   1729            interrupt &= INT_SC1CFG;
   1730          
   1731            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1732              while (interrupt != 0) {
   1733            #endif // (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1734          
   1735                INT_SC1FLAG = interrupt; // acknowledge the interrupts early
   \                     ??halSc1Isr_1:
   \   00000006   0x6025             STR      R5,[R4, #+0]
   1736          
   1737                // RX events
   1738                if ( interrupt & (INT_SCRXVAL   | // RX has data
   1739                                  INT_SCRXOVF   | // RX Overrun error
   1740                                  INT_SCRXFIN   | // RX done [TWI]
   1741                                  INT_SCNAK     | // RX Nack [TWI]
   1742                                  INT_SCRXULDA  | // RX DMA A has data
   1743                                  INT_SCRXULDB  | // RX DMA B has data
   1744                                  INT_SC1FRMERR | // RX Frame error
   1745                                  INT_SC1PARERR ) // RX Parity error
   1746                   ) {
   \   00000008   0xF246 0x7029      MOVW     R0,#+26409
   \   0000000C   0x4205             TST      R5,R0
   \   0000000E   0xD003             BEQ.N    ??halSc1Isr_2
   1747                  halInternalUartRxIsr(1, interrupt);
   \   00000010   0xB2A9             UXTH     R1,R5
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       halInternalUartRxIsr
   1748                }
   1749          
   1750                // TX events
   1751                if ( interrupt & (INT_SCTXFREE | // TX has room
   1752                                  INT_SCTXIDLE | // TX idle (more room)
   1753                                  INT_SCTXUND  | // TX Underrun [SPI/TWI]
   1754                                  INT_SCTXFIN  | // TX complete [TWI]
   1755                                  INT_SCCMDFIN | // TX Start/Stop done [TWI]
   1756                                  INT_SCTXULDA | // TX DMA A has room
   1757                                  INT_SCTXULDB ) // TX DMA B has room
   1758                   ) {
   \                     ??halSc1Isr_2:
   \   00000018   0xF641 0x00D6      MOVW     R0,#+6358
   \   0000001C   0x4205             TST      R5,R0
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x2001             MOVNE    R0,#+1
   \   00000022   0x.... 0x....      BLNE     halInternalUartTxIsr
   1759                  halInternalUartTxIsr(1);
   1760                }
   1761          
   1762            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1763                interrupt = INT_SC1FLAG;
   \                     ??halSc1Isr_0:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   1764                interrupt &= INT_SC1CFG;
   \   00000028   0x6C21             LDR      R1,[R4, #+64]
   \   0000002A   0xEA11 0x0500      ANDS     R5,R1,R0
   1765              }
   \   0000002E   0xD1EA             BNE.N    ??halSc1Isr_1
   1766            #endif // (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1767          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1768          #endif // EM_SERIAL1_ENABLED
   1769          
   1770          #if EM_SERIAL2_ENABLED
   1771          void halSc3Isr(void)
   1772          {
   1773            int32u interrupt;
   1774          
   1775            //this read and mask is performed in two steps otherwise the compiler
   1776            //will complain about undefined order of volatile access
   1777            interrupt = INT_SC3FLAG;
   1778            interrupt &= INT_SC3CFG;
   1779          
   1780            #if (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1781              while (interrupt != 0) {
   1782            #endif // (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1783          
   1784                INT_SC3FLAG = interrupt; // acknowledge the interrupts early
   1785          
   1786                // RX events
   1787                if ( interrupt & (INT_SCRXVAL   | // RX has data
   1788                                  INT_SCRXOVF   | // RX Overrun error
   1789                                  INT_SCRXFIN   | // RX done [TWI]
   1790                                  INT_SCNAK     | // RX Nack [TWI]
   1791                                  INT_SCRXULDA  | // RX DMA A has data
   1792                                  INT_SCRXULDB  | // RX DMA B has data
   1793                                  INT_SC1FRMERR | // RX Frame error
   1794                                  INT_SC1PARERR ) // RX Parity error
   1795                   ) {
   1796                  halInternalUartRxIsr(2, interrupt);
   1797                }
   1798          
   1799                // TX events
   1800                if ( interrupt & (INT_SCTXFREE | // TX has room
   1801                                  INT_SCTXIDLE | // TX idle (more room)
   1802                                  INT_SCTXUND  | // TX Underrun [SPI/TWI]
   1803                                  INT_SCTXFIN  | // TX complete [TWI]
   1804                                  INT_SCCMDFIN | // TX Start/Stop done [TWI]
   1805                                  INT_SCTXULDA | // TX DMA A has room
   1806                                  INT_SCTXULDB ) // TX DMA B has room
   1807                   ) {
   1808                  halInternalUartTxIsr(2);
   1809                }
   1810          
   1811            #if (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1812                interrupt = INT_SC3FLAG;
   1813                interrupt &= INT_SC3CFG;
   1814              }
   1815            #endif // (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1816          }
   1817          #endif // EM_SERIAL2_ENABLED
   1818          

   \                                 In section .text, align 2, keep-with-next
   1819          static void uartErrorMark(int8u port, int8u errors)
   1820          {
   \                     uartErrorMark:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1821            EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000002   0x....             LDR.N    R2,??DataTable15_6
   \   00000004   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   1822          
   1823            // save error code & location in queue
   1824            if ( emSerialRxError[port] == EMBER_SUCCESS ) {
   \   00000008   0x....             LDR.N    R3,??DataTable15_14
   \   0000000A   0x....             LDR.N    R4,??DataTable15_15
   \   0000000C   0x5D05             LDRB     R5,[R0, R4]
   \   0000000E   0xB925             CBNZ.N   R5,??uartErrorMark_0
   1825              emSerialRxErrorIndex[port] = q->head;
   \   00000010   0x8812             LDRH     R2,[R2, #+0]
   \   00000012   0xF823 0x2010      STRH     R2,[R3, R0, LSL #+1]
   1826              emSerialRxError[port] = errors;
   \   00000016   0x5501             STRB     R1,[R0, R4]
   \   00000018   0xBD30             POP      {R4,R5,PC}
   1827            } else {
   1828              // Flush back to previous error location & update value
   1829              q->head = emSerialRxErrorIndex[port];
   \                     ??uartErrorMark_0:
   \   0000001A   0xF833 0x3010      LDRH     R3,[R3, R0, LSL #+1]
   \   0000001E   0x8013             STRH     R3,[R2, #+0]
   1830              emSerialRxError[port] = errors;
   \   00000020   0x5501             STRB     R1,[R0, R4]
   1831              if(q->head < q->tail) {
   \   00000022   0x8851             LDRH     R1,[R2, #+2]
   \   00000024   0x8813             LDRH     R3,[R2, #+0]
   \   00000026   0x428B             CMP      R3,R1
   \   00000028   0xD205             BCS.N    ??uartErrorMark_1
   1832                q->used = (emSerialRxQueueSizes[port] - q->tail) + q->head;
   \   0000002A   0x....             LDR.N    R4,??DataTable15_10
   \   0000002C   0xF834 0x0010      LDRH     R0,[R4, R0, LSL #+1]
   \   00000030   0x1A40             SUBS     R0,R0,R1
   \   00000032   0x1818             ADDS     R0,R3,R0
   \   00000034   0xE000             B.N      ??uartErrorMark_2
   1833              } else {
   1834                q->used = q->head - q->tail;
   \                     ??uartErrorMark_1:
   \   00000036   0x1A58             SUBS     R0,R3,R1
   \                     ??uartErrorMark_2:
   \   00000038   0x8090             STRH     R0,[R2, #+4]
   1835              }
   1836            }
   1837          }
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x4000C854         DC32     0x4000c854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x4000A808         DC32     0x4000a808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     emSerialTxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x4000A848         DC32     0x4000a848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x4000C83C         DC32     0x4000c83c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     emSerialRxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x40000024         DC32     0x40000024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x........         DC32     emSerialRxQueueWraps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x4000C848         DC32     0x4000c848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x........         DC32     emSerialRxQueueSizes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x........         DC32     emSerialTxQueueWraps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x4000C85C         DC32     0x4000c85c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     SC1_UARTPER_SAVED

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x........         DC32     emSerialRxErrorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x........         DC32     emSerialRxError

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "uart.c">`:
   \   00000000   0x75 0x61          DC8 "uart.c"
   \              0x72 0x74    
   \              0x2E 0x63    
   \              0x00         
   \   00000007   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  halInternalForceReadUartByte
             16 -> _disableBasePri
             16 -> _writeBasePri
        8  halInternalForceWriteUartData
              8 -> emDebugSendVuartMessage
        0  halInternalPowerDownUart
        0  halInternalPowerUpUart
        0  halInternalRestartUart
        8  halInternalStartUartTx
              8 -> _disableBasePri
              0 -> _writeBasePri
              8 -> emDebugSendVuartMessage
              8 -> halInternalAssertFailed
              8 -> halInternalUartTxIsr
        0  halInternalStopUartTx
       16  halInternalUartInit
             16 -> halInternalUartSetBaudRate
       32  halInternalUartRxIsr
             32 -> uartErrorMark
        0  halInternalUartRxPump
        0  halInternalUartTxIsIdle
       16  halInternalUartTxIsr
        8  halInternalWaitUartTxComplete
              8 -> halInternalResetWatchDog
       16  halSc1Isr
             16 -> halInternalUartRxIsr
             16 -> halInternalUartTxIsr
       16  halStackReceiveVuartMessage
              0 -> uartErrorMark
       12  uartErrorMark


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "uart.c">
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      12  SC1_UARTPER_SAVED
          SC1_UARTFRAC_SAVED
          SC1_UARTCFG_SAVED
      20  baudSettings
      94  halInternalForceReadUartByte
      64  halInternalForceWriteUartData
      18  halInternalPowerDownUart
      48  halInternalPowerUpUart
       2  halInternalRestartUart
      88  halInternalStartUartTx
      16  halInternalStopUartTx
     148  halInternalUartInit
     124  halInternalUartRxIsr
       2  halInternalUartRxPump
      30  halInternalUartTxIsIdle
      58  halInternalUartTxIsr
      22  halInternalWaitUartTxComplete
      50  halSc1Isr
      74  halStackReceiveVuartMessage
      60  uartErrorMark

 
  12 bytes in section .bss
 990 bytes in section .text
 
 990 bytes of CODE memory
  12 bytes of DATA memory

Errors: none
Warnings: 1
